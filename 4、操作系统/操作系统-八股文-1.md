**<u>*这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对八股文总结。*</u>**

操作系统八股文来自：

1. [《代码随想录知识星球精华-大厂面试八股文v1.2.pdf》](D:\z_知识星球\代码随想录\代码随想录知识星球精华PDF-大厂面试八股文\代码随想录知识星球精华-大厂面试八股文v1.2.pdf)
2. [《JavaGuide面试突击版4.0.pdf》](D:\z_知识星球\JavaGuide\JavaGuide的知识星球\JavaGuide面试突击版\JavaGuide面试突击版4.0.pdf)（有5.0版的，再看的时候对比着看）

# 1、代码随想录

## 1.1操作系统基础

操作系统是介于硬件资源和应用程序之间的一个系统软件。

操作系统位于硬件资源之上，管理硬件资源；应用程序之下，为应用程序提供服务，同时管理应用程序。

### 1.1.1、操作系统的功能

操作系统位于硬件资源之上，管理硬件资源；应用程序之下，为应用程序提供服务，同时管理应用程序

1. 资源分配，资源回收
   计算机资源必要重要的硬件资源无非是CPU、内存、硬盘、I/O设备。
   而且这些资源都是优先的，因此需要有效的管理，资源管理最终只有两个问题：资源分配、资源回收。

   1. 资源分配：以现在CPU上，比如进程调度，多个进程同时请求CPU下，应该给哪个进程？再比如内存分配，内存不够了怎么办呢？A进程非法访问了B进程的的内存地址怎么办？内存内外碎片问题等。
   2. 资源回收：考虑内存回收后的合并等等

2. 为应用程序提供服务
   操作系统将硬件资源的操作封装起来，提供相对统一的接口（系统调用）供开发者调用。

   如果没有操作系统，应用程序将直接面对硬件，出去给开发者带来的编程困难不说，直接访问硬件，使用不当极有可能会导致直接损坏硬件资源

3. 管理应用程序
   即控制进程的生命周期：进程开始时的环境配置和资源分配、进程结束后的资源回收、进程调度等。

4. 操作系统内核的功能：

   1. 进程调度能力：管理进程、线程，决定哪个进程、线程使用CPU
   2. 内存管理能力：决定内存的分配和回收
   3. 硬件通信能力：管理硬件，为进程和硬件之间提供通信
   4. 系统调用能力：应用程序进行更加高权限运行的服务，需要系统调用，用户程序和操作系统之间的接口

健壮性，又称之为鲁棒性，即很粗鲁的对待程序，他还是可以运行的很棒！！！

### 1.1.2、操作系统的角色

魔术师与管理者

1. 管理者：主要分CPU管理、内存管理、外存管理、I/O管理；以及自己的健壮性和安全性管理
2. 魔术师：比如操作系统会让每个进程都觉得自己独占CPU、独占整片物理内存，而实际上每个进程只是在某一时间段内占用CPU，仅仅指示占用实际一点点物理内存

### 1.1.3、用户程序与操作系统的关系

相互调用

1. 操作系的角度

   计算机启动后启动的第一个软件就是操作系统，随后启动的所有进程都运行在操作系统之上，使用操作系统提供的服务，同时被操作系统统监控，进程结束后也由操作系统回收。

2. 进程的角度

   调用操作系统提供的服务，实现自己的功能。

## 1.2、进程

### 1.2.1、进程的概念

我们编译的代码可执行文件只是存储在硬盘的静态文件，运行时被加载到内存，CPU执行内存中的指令，这个运行的程序被称之为进程

### 1.2.2、进程的实现

中断发生后操作系统底层的工作步骤

1. 硬件压入堆栈程序计数器等
2. 硬件从中断向量载入新的程序计数器
3. 汇编语言过程保存寄存器值
4. 汇编语言过程设置新的堆栈
5. C中断服务例程运行（典型的读和缓冲输入）
6. 调度程序决定下一个将运行的进程
7. C过程返回至汇编代码
8. 汇编语言过程开始运行新的当前线程

进程表：为了实现进程模型，操作系统维护着一张表（一个结构数组），即进程表。

每个进程占有一个进程表项（有些著作称这些为进程控制块）

该表项包含了一个进程状态的重要信息；包括程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、账号的调度信息，以及其他在进程由运行状态转换到就绪态或者阻塞态时候必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。

### 1.2.3、并发与并行

1. 单个核在很短时间内分别执行多个进程，称为并发
2. 多个核同时执行多个进程成为并行
3. 对于并发来说，CPU需要从一个进程切换到另一个进程，这个过程需要保存进程的状态信息

### 1.2.4、进程的状态

1. 运行态：该时刻进程占用CPU
2. 就绪态：可运行，由于其他进程处于运行状态而暂时停止运行
3. 阻塞态：该进程正在该等待某一时间发生（如等待输入/输出操作的完成）而暂时停止；该状态的进程占用着物理内存，在虚拟内存管理的操作系统中，通常会把阻塞态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存

比如read系统调用阻塞，进程会占有内存空间，这是一种浪费行为，于是系统会有很内存管理中物理页置换磁盘一样的行为，吧阻塞的进程置换到磁盘中，此进程未占有物理内存，我们称之为挂起；观其不仅仅可能是物理内存不足，比如sleep系统调用过着用户执行Ctrl+Z可能导致挂起。



挂起态：新的状态，描述进程没有占用实际的物理内存的情况，这个状态就是挂起状态

1. 阻塞挂起：进程在外存（硬盘）并等待某个事件的出现，被激活进入内存后会成为阻塞状态。
2. 就绪挂起：进程在外存（硬盘），被激活进入内存后会成为就绪状态，可以马上运行。

![image-20220922210310885](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-八股文-1\image-20220922210310885.png)

特点：

1. 就绪态和运行态度可以相互转换，其他是单向转换（除了挂起态）。就绪态的进程通过调度算法从而获得CPU时间，转为运行状态。
2. 运行态的进程，在分配给他的CPU时间片用完之后就会转换为就绪状态，等待下一次调度
3. 阻塞态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行状态转换为就绪状态。

### 1.2.5、进程控制块（PCB）

操作系统对进程的感知，是通过进程控制块PCB数据结构来描述的。它是进程存在的唯一标识，其包括以下信息：

1. 进程描述信息：进程标识符，用户标识符等
2. 进程控制和管理信息：进程状态，进程优先级等
3. 进程资源分配清单：虚拟内存地址空间信息，打开文件列表，IO设备信息等
4. CPU相关信息：当进程切换时，CPU寄存器的值都被保存在PCB块中，以便CPU重新执行该进程时能从断点处继续执行

PCB通过链表形式组织起来，比如就绪队列，阻塞队列等，方便删除，方便进程管理

### 1.2.6、进程状态的切换

进程三个状态：就绪状态、运行状态、阻塞状态之间的转换关系：

1. 只有就绪态和运行态可以相互转换，其他都是单向转换。
2. 就绪态的进程通过调度算法从而获得CPU时间，转换为运行状态；而运行状态的进程，在分配给他们的CPU时间片用完之后就会转换成就绪状态，等待下一次调度。
3. 进程因为等待资源而阻塞，但是该资源不包括CPU时间，缺少CPU时间会从运行状态转换为就绪状态
4. 当进程等待的外部事件发生时（如果一些输入到达），则由阻塞状态转换为就绪状态，如果此时没有其他进程运行，便换转为运行状态，否则该进程处于就绪态，等待CPU空闲轮到她运行

### 1.2.7、进程切换为何比线程慢

涉及虚拟内存的问题，进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，所以同一个进程中的线程进行线程切换时不会涉及虚拟地址空间的转换。

把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程（至少访问2次内存），因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB（快表）。

由于每个进程都有⾃⼰的虚拟地址空间，那么显然每个进程都有⾃⼰的⻚表，那么当进程切换后⻚表也要进⾏切换，⻚表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运⾏会变慢，⽽线程切换则不会导致TLB失效，因为线程线程⽆需切换地址空间，这也就是进程切换要⽐同进程下线程切换慢的原因。

### 1.2.10、守护进程

守护进程是指在后台运行的，没有控制终端与它相连的进程。它独立于控制终端，周期性的执行某种任务。

Linux的大多数服务器就是用守护进程的方式实现的，如果web服务器进程http等。

### 1.2.12、多进程

进程结构是由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。

父进程创建子进程之后，父子进程处理pid之外，几乎所有的部分几乎一样。

父子进程共享全部数据，子进程在写数据时会使用写时复制技术将用工的数据重新拷贝一份，之后在拷贝出的数据上进行操作；不是对同一块数据进行操作

如果子进程想要运行自己的代码段，还可以调用execv函数重新加载新的代码段，之后就和父进程独立分开了。

## 1.3、进程调度算法

1. 批处理系统中的调度
   1. 先来先服务：非抢占的调度算法，按照请求的顺序进行调度；有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业有需要执行很长时间，造成了短租也等待时间过长
   2. 最短作业优先：非抢占式的调度算法，按照估计运行时最短的顺序进行调度；缠足哦耶有可能饿死，处于一直等待短作业执行完毕的状态。
   3. 最短剩余时间优先：最短作业优先的抢占式版本，按照剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
2. 交互式系统中的调度
   1. 时间片轮转调度：将所有就绪进程按照FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序使停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间片段分配给队首的进程
   2. 优先级调度：为每个进程分配一个优先级，按照优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级
   3. 多级队列：一个进程需要执行100个时间片段，如果采用时间片段轮转调度算法，那么需要交换100次；多级队列是为了这种需要连续执行多个事件片的进程考虑，他设置了多个队列，每个队列时间片段大小都不同，例如：1、2、4、8……。进程在第一个队列没执行完，就会被移动到下一个队列。这种方式下，之前的进程只需要交换7次。每个队列优先权不同，最上面的优先权最高因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。
   4. 最短进程优先
      如果我们将每一条命令的执行看作是一个独立的作业，则我们可以通过首先运行最短的作业来响应事件最短
3. 实时系统中的调度

## 1.4、进程通信

### 1.4.1、通信类型

1. 同一主机
   1. 无名管道
   2. 有名管道
   3. 信号
   4. 消息队列
   5. 共享内存
   6. 信号量
   7. 存储映射
2. 不同主机
   1. 不同主机的通信有socket

### 1.4.2、无名管道

1. 特点：
   1. 半双工，数据在同一时刻只能在一个方向上流动
   2. 数据只能从管道的一端写入，从另一端口读出
   3. 写入管道中的数据遵循先入先出的规则
   4. 管道所传送的数据是无格式的，这要求管道的读出方实现约定好数据的格式，如多少字节算一个消息
   5. 管道不是普通的文件，不属于某个文件系统，其只存在与内存中
   6. 管道在内存中对应一个缓冲区。不同的系统其大小不一定相同
   7. 从管道读数据是一次性操作，数据一旦被读走，他就从管道中被抛弃，释放空间以便写更多的数据
   8. 管道没有名字，只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用
   9. 存在阻塞方式
2. pipe函数创建无名管道

### 1.4.3、有名管道

命名管道（FIFO）不同于无名管道之处在于他提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中，这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能彼此通过FIFO相互通信，因此，通过FIFO，不相关的进程也能交换数据。

1. 与无命名管道的不同：
   1. FIFO在文件系统中作为一个特殊的文件而存在，但是无命名管道中的内容却存放在内存中
   2. 当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用
   3. FIFO有名字，不想关的进程可以通过打开命名管道进行通信。
2. 通过命令创建有命名管道
   1. mkfifo fifo;

### 1.4.4、共享存储映射

存储映射I/O，使一个磁盘文件与存储空间中的一个缓冲区相映射。

于是当从缓冲区取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。

共享内存可以说最有用的进程通信方式，也是最快的IPC形式，因为进程可以直接读写内存，而不需要任何数据的拷贝。
![image-20220922223159155](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-八股文-1\image-20220922223159155.png)

存储映射函数：mmap函数

### 1.4.5、消息队列

基本原理：A进程要给B进程发送消息，A进程把数据放在对应的消息队列后就可以正常返回了，B进程需要的时候再去读取数据就可以了。

特点：

1. 消息队列是保存在内核中的消息链表，每个消息体就是固定大小的存储块。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。
2. 如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在

缺点：

1. 通信不及时。附件也有大小限制
2. 消息队列不适合比较大数据的传输，每个消息体都有一个最大的长度限制，同时所有队列所包含的全部消息体的总长度也是有上限
3. 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销

### 1.4.6、信号

信号是Linux进程通信的最古老的方式

信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种<u>**异步**</u>通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件

信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知通知用户空间进程发生了那些系统事件。

信号的特点：

1. 简单
2. 不能携带大量信息
3. 满足某个特定条件才发送

一个完整的信号周期

1. 信号的产生
2. 信号在进程中的注册，信号再进程中的注销
3. 执行信号处理函数

## 1.5、守护进程

守护进程，也就是通常说的Daemon进程（精灵进程），是Linux中的后台服务进程

1. 它是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件
2. 一般采用以d结尾的名字
3. 所以服务存在于etc/init.d
4. 守护进程是个特殊的孤儿进程
5. 之所以脱离终端是为了避免进程被任何终端所产生的信息打断，其在执行过程中的信息也不在任何终端上显示
6. Linux的大多数服务器就是用守护进程实现的

守护进程模型：

1. 创建子进程，父进程退出（必须）：所有工作在子进程中进行形式上脱离了控制终端
2. 在子进程中创建新会话（必须）：使紫禁城完全独立出来，脱离控制
3. 改变当前目录为根目录（不是必须）：防止占用可卸载的文件系统，也可以换成其他路径
4. 重设文件权限掩码（不是必须）：防止继承的文件创建屏蔽字拒绝某些权限，增加守护进程灵活性
5. 关闭文件描述符（不是必须）：继承的打开文件不会用到，浪费系统资源，无法卸载
6. 开始执行守护进程的核心工作（必须）：守护进程退出处理程序模型

## 1.6、线程

### 1.6.1、线程的特点

1. 线程是轻量级进程，也有PCB，创建线程使用的底层函数和进程一样，都是clone
2. 从内核里看进程和线程是一样的，都有各自不同的PCB
3. 进程可以蜕变成线程
4. 在linux下，线程是最小执行单位；进程是最小分配资源单位。

实际上无论是创建进程的fork，还是创建线程的pthred_create，底层实现都是调用一个内核函数clone

1. 如果复制对方的地址空间，那么就会产出一个“进程”
2. 如果共享对象的地址空间，就产生一个“线程”

Linux内核是不区分进程和线程的，只再用户层面上进行区分。所以，线程所有操作函数pthread_*是库函数，而非系统调用。

三种线程的实现：

1. 用户线程：用户空间实现的线程，由基于用户态度的线程库管理
2. 内核线程：用操作系统管理、调度，其TCB是存放在内核中。一般由操作系统事先创建内核线程集（类似于线程池），数量有限
3. 轻量级线程LWP：内核支持的用户线程，像普通进程一样被调度，其类似于进程中的执行线程；每个LWP都需要一个内核线程的支持（CPU资源分配、调度），实际上用户线程是运行在LWP上的。

### 1.6.2、线程共享资源

1. 文件描述符表
2. 每种信号的处理方式
3. 当前工作目录
4. 用户ID和组ID

### 1.6.3、线程非共享资源

1. 线程id
2. 处理器现场和栈指针（内核栈）
3. 独立的占空间（用户空间栈）
4. errno变量
5. 信号屏蔽字
6. 调度优先级

### 1.6.4、线程的优缺点

优点：

1. 提高程序的并发性
2. 开销小
3. 数据通信、共享数据方便

缺点：

1. 库函数，不稳定
2. 调试困难
3. 对信号支持不好

线程如何减少开销
1.  线程创建快，进程创建需要资源管理信息，⽐如内存管理信息和⽂件管理信息，⽽线程创建后是共享其所属进程的资源管理信息;
2.  线程终⽌时间快，需要回收的仅有少寄存器和私有的栈区;
3.  线程切换快，因为线程切换仅涉及到少寄存器和栈区，⽽进程上下⽂切换有CPU寄存器和程序计数器(CPU上下⽂)、虚拟内存空间、⻚表切换、TLB失效等;
4.  线程因为创建时共享了其所述进程绝⼤多数资源，因此天⽣具有很好的线程间通信交互效率。

### 1.6.5、线程通信

线程间的通信目的主要用于线程同步。所以线程没有像进程通信中的用于数据交换的通信机制。

同一进程的不同线程共享一份内存区域，所以线程之间可以方便、快速的共享信息。只需要将数据复制到共享（全局或堆）变量中即可。但是需要避免出现多个线程试图同时修改同一份信息。

### 1.6.6、多线程

用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享；

i++在计算机中并不是原子操作，涉及内存取数、计算、写入内存几个环节，而线程的切换可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。

多线程的好处：
主要原因是许多应⽤中同时发⽣多个活动，某些活动随着时间推移⽽阻塞，将这些应⽤程序分解成并发运⾏的多个线程，简化设计模型。同时多线程有共享同⼀地址空间和可⽤数据的能⼒，这是多进程没有的。
线程⽐进程开销⼩，更容易创建和释放。
多个线程是IO密集型时，多线程可以使这些活动彼此叠运⾏，可以加快程序执⾏的速度。



## 1.7、存储系统

页面置换算法

1. 最佳页面置换算法
   置换在【未来最长时间不访问的页面，但是实际中系统中无法实现】，因为程序员访问的也卖你是动态的，我们无法预知每个页面在【下一次】访问前的等待时间，因此为作为实际算法效率标准
2. 先进先出置换算法
   将页面以队列的新式保存，先进先出的页面先被置换进入磁盘
3. 最近最久未使置换算法
   根据页面未被访问时间用升序列表将页面排列，每次将最久未被使用的页面置换出去
4. 时钟页面置换算法
   把所有的页面保存在一个类似时钟页面的【环形链表】中，页面包含一个访问位。
   当发生缺页中断时，顺时针遍历页面，如果访问位为1，将其改为0，继续遍历，直到访问到访问位为0的页，进行置换
5. 最不常用算法
   记录每个页面访问次数，当发生缺页中断的时候，将访问次数最少的页面置换出去，此方法需要对每个页面访问次数统计，额外开销。

**分段**：
虚拟内存采用的是分页技术，也就是将地址划分为固定大小的页，每一页再与内存进行映射。

如果使用分页系统的一维地址空间，动态增长的特点将会导致覆盖问题的出现。

分段的做法是把每个表分为段，一个段构成一个独立的地址空间。

每个段的长度可以不同，并且可以动态增长。

**虚拟内存**：

属于计算系统内存管理的一种技术，虚拟地址空间构成虚拟内存，他使得应用程序认为自己拥有连续的可用内存空间，但实际上是被分隔多个物理内存页、以及部分暂时存储在磁盘上的交换分区所构成的。虚拟内存的实现通过硬件异常、硬件地址翻译、贮存、磁盘以及内核软件共同完成。

1. 地址空间：是物理内存的抽象，是一个进程可用于寻址内存的一套地址集合
2. 分页：地址空间被分割成多个块，每一块称作一页。每一页有连续的地址范围，这些页被映射到连续的物理内存（页框）
3. 页表：页表的目的是把虚拟页面（虚拟地址）映射为页框（物理地址）。页表给出了虚拟地址与物理地址的映射关系。

**为什么要用虚拟内存？**

1. 虚拟内存可以结合磁盘和物理内存的优势为进程提供看起来速度足够快并且容量足够大的存储
2. 虚拟内存可以为进程提供独立的内存空间并引入多层的页表结构将虚拟内存翻译为物理内存，进程之间可以共享物理内存减少开销，也能简化程序的链接、装载以及内存分配的过程
3. 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的方问权限，提高系统的安全性。



## 1.8、死锁

如果一个进程集合中的每一个进程都在等待只能又该进程集合中的其他进程才能引发的事件，那么该进程集合就是死锁

1. 资源
   1. 可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用，存储器就是一类可抢占资源
   2. 不可抢占资源：指在不引起相关计算失败的情况下，无法把他从占有她的进程处抢占过来

**死锁的必要条件：**

1. 互斥：每个资源要么已经分配给一个进程，要么就是可用的
2. 占有和等待：已经得到了某个资源的进程可以再请求新的资源
3. 不可抢占：已经分配给一个进程的资源不能强制性的被抢占，它只能被占有它的进程显示的释放
4. 环路等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源

**处理死锁的方法：**

1. 鸵鸟算法：认为死锁对用户不会造成多大的影响，假装没发生
2. 死锁检测与死锁恢复：
   检测算法：通过检测有向图中是否存在环来实现，从一个节点出发进行深度优先所有，对访问过的节点进行标记，如果访问量已标记的节点，就表示有向图中存在环，也就是检测到死锁发生

**从死锁中恢复：**

1. 利用抢占恢复：将进程挂起，强行取走资源给另一个进程使用，用完再放回
2. 利用回滚恢复：复位到更早的状态，那时他还没有取得所需的资源
3. 同时杀死进程恢复：杀掉环中的一个进程或者多个，牺牲掉一个环外进程

**死锁预防：**

1. 破坏互斥条件
2. 破坏占有和等待条件：
   1. 规定所有进程在开始执行前请求所需要的全部资源
   2. 要求当一个进程请求资源时，先暂时释放其当前占有的所有资源，然后再尝试一次获得所需要的全部资源
3. 破坏不可抢占条件：
   1. 保证每一个进程在任何时刻只能占有一个资源，如果请求另一个资源必须显示放第一个资源
   2. 将所有的资源统一编号，进程可以再任何时刻提出资源请求，但是所有请求必须按照资源编号的顺序（升序）提出
4. 破坏环路等待

# 2、Java Guide

## 2.1、操作系统基础

### 2.1.1、什么是操作系统

1. 操作系统是管理计算机硬件与软件资源的程序，是计算机的基石
2. 操作系统本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源
3. 操作系统存在屏蔽了硬件层的复杂性
4. 操作系统的内核是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

### 2.1.2、什么是系统调用

根据进程访问资源的特点，我们把进程在系统上的运行分为了两个级别：

1. 用户态：用户态运行的进程可以直接读取用户程序的数据
2. 系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制

我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？这就需要系统调用了！！！

也就是说在我们运行的用户程序中，凡是与系统态级别有关的操作（如文件管理、进程控制、内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按照功能可以大致分为以下几类：

1. 设备管理：完成设备的请求或释放，以及设备启动等功能
2. 文件管理：完成文件的读、写、创建以及删除等功能
3. 进程控制：完成进程的创建、撤销、阻塞以及唤醒等功能
4. 完成进程之间的消息传递或信号传递等功能
5. 内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能

## 2.2、进程和线程

### 2.2.1、进程和线程的区别

![image-20220923094332634](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-八股文-1\image-20220923094332634.png)

从上图中可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区（JDK1.8之后的元空间）资源，但是每个进程都有自己的程序计数器、虚拟机栈和本地方法栈。

总结：线程是进程划分程的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程的最大的不同在于基本上各进程都是独立的，而各线程不一定，因为同一进程中的线程极有可能会相互影响。线程的执行开销小，但是不利于资源的管理和保护；而进程正好相反。

### 2.2.2、进程有那几个状态

1. 创建状态：进程正在被创建，尚未到就绪状态
2. 就绪状态：进程已处于准备运行的状态，而进程获得了除了CPU之外的一切所需要的资源，一旦得到CPU资源（处理器分配的时间片段）就可以运行
3. 运行状态：进程正在处理器上运行（单核CPU下任意时刻只能有一个进程处于运行状态）
4. 阻塞状态：又称之为等待状态，进程正在等待某一事件而暂时停止运行，如等待资源为可用或者等待IO操作完成；在这个状态下即处理器空闲，该进程也不能运行
5. 结束状态：进程正在系统中消失，可能是进程正常结束或其他烟瘾中断退出运行。

![image-20220923095317980](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-八股文-1\image-20220923095317980.png)

### 2.2.3、进程间的通信方式

1. 管道/匿名管道（pipe）

   1. 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道
   2. 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）
   3. 单独构成一种独立的文件结构：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中
   4. 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据

   ![image-20220923100126076](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-八股文-1\image-20220923100126076.png)

   **管道的实质：**是一个内核缓冲区，进程以先进先出的方式从缓冲区中存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

   该缓冲区一个数据只能被读一次，读出以后在缓冲区就不复存在了。

   当缓冲区空或者写满时，有一定的规则控制相应的读取进程或写进程进入等待队列，当空的缓冲区有新的数据写入或则和慢的缓冲区有数据读出的时候，就唤醒等待队列中的进程继续读写。

   **管道的局限：**

   1. 只支持的那箱数据流
   2. 只能用于具有亲缘关系的进程之间
   3. 没有名字
   4. 缓冲区优先

2. 有名管道（FIFO）
   为了款未付无名管道的缺点，提出了有名管道；它们的区别指出在于有名管道提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与又名管道的创建进程不存在亲缘关系的进程，只要可用访问该路径，就能彼此通过有名管道相互通信。
   有名字管道的名字存在于文件系统中，内容存放在内存中。

   

   匿名管道和有名管道总结：

   1. 管道是特殊类型的文件，在满足先进先出的原则下可以进行读写，但不能进行定位读写
   2. 匿名管道是单向的，只能再有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本及任意两个进程通信

3. 信号
   信号是Linux系统中用于进程间相互通信或操作的一种机制，信号可以在任何时候发送给某一个进程，而无需直到该进程的状态.

   如果该进程当前并未处于执行状态，则该信号就有内核保存起来，直到该进程恢复执行并传递给它为止

4. 消息队列
   存放在内核中的消息链表，每个消息队列由消息队列标识符表示。

   与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。

   另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。

   消息队列可以实现消息随机查询，消息不一定要先仅限出的次序读取，也可以按照消息的类型读取，比FIFO更有优势

5. 共享内存

   使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。

   为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

   由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

6. 信号量
   是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步

### 2.2.4、线程间的同步方式

线程同步是两个或多个共享关键资源的线程并发执行；应该同步线程以避免关键的资源使用冲突，操作系统一般有下面三种线程同步的方式：

1. 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问；比如Java中的synchronized关键字和各种Lock都是这种机制。
2. 信号量：它允许同一时刻多个线程访问同一资源，但是需控制同一时刻访问此资源的最大线程数量
3. 事件：通过通知操作的方式保持多线程同步，还可以方便的实现多线程优先级的比较操作





