**<u>*这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对面试题总结。*</u>**

操作系统面试题来自：

1. [《图解操作系统.pdf》](D:\z_知识星球\JavaGuide\JavaGuide的知识星球\计算机基础\图解操作系统.pdf)
2. [《操作系统面试题（2021最新版）.pdf》](D:\a_000企业面试题\我搜到的\牛客网上搜到的面经+八股文\Java八股文\操作系统面试题（2021最新版）.pdf)



# 1、图解操作系统

## 1.1、解释一下什么是操作系统

操作系统是运行在计算机上最重要的一种软件，它管理计算机的资源和进程以及所有硬件和软件，它为计算机硬件和软件提供了一种中间层。

操作系统所处的位置如下图：
![image-20220920231646058](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220920231646058.png)

通常情况下，计算机上会运行着许多应用程序，它们需要对内存和CPU 进行交互，操作系统的目的就是为了保证这些访问和交流能够准确无误的进行。



## 1.2、解释一下操作系统的主要目的是什么

操作系统是一种软件，它的主要目的有三种：

1. 管理计算机资源，这些资源包括CPU、内存、磁盘驱动器、打印机等
2. 提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁
3. 为其他软件提供服务，操作系统与软件进行交互，以便为其分配所需的任何必要资源

## 1.3、操作系统的种类有哪些

操作系统通常预装在你购买计算机之前。大部分用户都会使用默认的操作系统，但是你也可以升级甚至更更改操作系统。但是一般常见的操作系统只有三种：Windows、macOS、Linux

## 1.4、操作系统结构

1. 单体系统
   在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，连接在一块形成一个大的二进制可执行程序，这种系统称之为单体系统。

   在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包括这些过程的文件），然后使用系统连接器将他们全部固定到一个可执行文件中

   在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可以将各种过程划分为一个三层模型。

   ![image-20220920232932772](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220920232932772.png)

2. 分层系统

   分层系统使用层来分割不同的功能单元。每一层只与该层的上层和下层通信。每一层都是用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。
   ![image-20220920233546909](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220920233546909.png)

   

3. 微内核

   为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块——微内核——运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。
   MINIX 3是微内核的代表作，它的具体结构如下：

   ![image-20220920233608202](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220920233608202.png)

   MINI 3系统结构

   在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问I/O端口，也不能直接发出I/O命令。相反，为了能够对I/O设备变成，驱动器构建一个结构，支名哪个参数值写道哪个I/O端口，并声称一个内核调用，这样就完成了一次调用过程。
   
4. 客户-服务器模式
   微内核思想是把进程划分两类：`服务器`，每个服务器用来提供服务；`客户端`，使用这些服务。这个模式是所谓的  客户-服务器  模式。

   客户-服务器  模式会有两种载体，一种是情况是一台计算机即是客户机又是服务器，在这种方式下，操作系统会有某种优化；到那时普遍情况下是客户端和服务器在不同机器上，它们通过局域网或广域网连接。

   ![image-20220920234445035](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220920234445035.png)

   客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的；都是发送请求并得到响应。

## 1.5、什么是按需分页

在操作系统中，进程是以页为单位加载到内存种的，按需求分页是一种虚拟内存的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了缺页异常，操作系统才会将磁盘页面复制到内存中。

## 1.6、多处理系统的优势

随着处理器的不断增加，我们的计算机系统由单机系统变成了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等等。

![image-20220920235100764](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220920235100764.png)

多处理系统由于可以共享资源，因此可以开源节流，省钱。整个系统的可靠性也随之提高。

## 1.7、什么是内核

在计算机种，内核是一个计算机程序，它是操作系统的核心，可以控制系统种所有的内容。内核通常是在boot loader装载程序之前加载的第一个程序。

这里还需要了解以下什么是 boot loader。

boot loader 又被称之为引导加载程序，它是一个程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS会执行一些初始测试，然后将控制移动到引导加载程序所在的主导记录（MBR)。



## 1.8、什么是实时系统

实时操作系统对时间做出了严格的要求，实时操作系统分为两种：硬实时和软实时。

硬实时操作系统：规定某个动作必须在规定的时刻内完成或发生，比如生产车间，焊接机器必须在某一时刻完成焊接，焊接的太早或太晚都会对汽车造成永久性伤害。

软实时操作系统：虽然不希望偶尔违反最终的时限要求，但是任然可以接受。并且不会引起任何永久性的伤害，比如数字音频、多媒体、收集都是属于软实时操作系统。

## 1.9、什么是虚拟内存

虚拟内存是一种内存分配方案，是一项可以用来辅助内存分配的机制。我们知道，应用程序是按照页装载进内存的。但是不是所有的页都会装载入内存种，计算机种的硬件和软件都会将数据从RAM中临时传输到磁盘中来弥补内存的不足。如果没有虚拟内存的话，一旦你的计算机填充满之后，计算机会对你说：无法加载任何应用程序，请关闭另一些应用程序以为加载新的应用程序。对于虚拟内存，计算机可以执行操作是查看内存中最近未使用过的区域，然后再将其复制到硬盘上。虚拟内存通过复制技术实现了  能够装载多个程序的资。复制是自动进行的，你无法感知到他的存在。

## 1.10、什么是进程和进程表

进程就是正在执行程序的示例，比如说Web程序就是一个进程，shell也是一个进程，文章编辑器typora也是一个进程。

操作系统负责管理所有正在运行的进程，操作系统会为每个进程分配特定的时间来占用CPU，操作系统还会为每个进程分配特定的资源。

操作系统为了跟踪每个进程的活动状态，维护了一个进程表。在进程表内部，列出来了每个进程的窗台，以及每个进程使用的资源等。

## 1.11、什么是线程、线程和进程的区别

我们上面说到的进程是正在运行的程序的实例，而线程其实就是进程中的单条流向，因为线程具有进程中的某些属性，所以线程又被称之为轻量级的进程。浏览器如果看成是一个进程的话，那么浏览器下面的每个tab也买都可以看作是一个个的线程。

下面是进程和线程所持有的资源的区别：
![image-20220921144511882](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921144511882.png)

线程不想那样具有很强的独立性线程之间会共享数据。

创建线程的开销要比进程的开销小，因为线程创建仅仅需要堆栈指针和程序计数器就可以了，而创建进程需要操作系统分配新的地址空间，数据资源等，这个开销比较大。

## 1.12 使用多线程的好处是什么

1. 能够提高对用户的响应顺序
2. 在读流程中的资源共享
3. 比较经济适用
4. 能够对多线程架构较为深入的理解



## 1.13、什么是RR调度算法

RR调度算法主要针对分时系统，RR的调度算法会把时间片以相同的部分并循环的分配个每个线程，RR调度算法没有优先级的概念。这种算法的实现比较简单，而且每个线程都会占有时间片段，并不存在线程饥饿的问题。

## 1.14、导致系统出现死锁的情况

死锁出现需要同时满足以下四个条件

1. 互斥：一次只能有一个进程使用资源如果另一个进程请求该资源，则必须延迟该进程的请求，直到资源释为止。
2. 保持并等待：必须存在一个进程，该进程至少持有一个资源，并且在等待获取其他线程当前所持有的资源。
3. 无抢占：资源不能被抢占，也就是说：在进程完成其任务之后，只能由拥有它的进程自动释放资源
4. 循环等待：必须存在一组{p0, p1, p2 ……}的等待进程，使用p0等待p1持有的资源，p~1~等待p~2~持有的资源，p~n-1~正在等待p~n~持有的资源，而p~n~正在等待p~0~持有的资源。

解决死锁的几种方法：

1. 从死锁中恢复：
   1. 利用回滚恢复：复位到更早的状态，那时他还没有取得所需要的资源
   2. 同事杀死进程恢复：杀掉环中的一个进程或者多个，牺牲掉有一个环外进程
2. 死锁预防：
   1. 破坏互斥条件
   2. 破坏占有和等待条件：
      1. 规定所有线程在开始执行之前请求所需要的全部资源
      2. 保证每一个进程在任何时刻只能有一个资源，如果请求另一个资源，需要先释放第一个资源
      3. 将所有资源统一编号，线程获取资源时必须按照编号顺序获得

## 1.15、RAID的不同级别

RAID称之为磁盘冗余阵列，简称：磁盘阵列。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或者数据冗余。

1. RAID 0 - 无容错的条带化磁盘阵列
2. RAID 1 - 镜像和双工
3. RAID 2 - 内存式纠错码
4. RAID 3 - RAID 4 - 比特交错奇偶校验
5. RAID 5 - 块交错奇偶校验
6. RAID 6 - P + Q冗余

## 1.16、什么是DMA

DMA的中文名称是：直接内存访问，它意味着CPU授予I/O模块权限在不涉及CPU 的情况下去读或者写入内存。也就是DMA不需要CPU的参与。这个过程又称之为DMA控制器（DMAC）的芯片管理。由DMA设备可以直接在内存之间传输数据，而不是使用CPU作为中介，因此可以缓解总线上的拥塞。DMA通过允许CPU执行任务，同时DMA系统通过系统和内存总线传输数据来提高系统的并发性。

## 1.17、多线程编程的好处

为什么单线程能够处理的却要用多线程来处理？为了提高程序的并行能力。多线程在某些情况下能够使你程序运行的更加快速，这也是为什么多核CPU会出现，但是多核CPU会先会导致数据的一致性问题，不过这些问题程序员就能直接解决。另一个角度来说，多线程编程能够提高程序员的编程能力和编程思维。同时也会提高程序员的管理能力。

## 1.18、什么是设备驱动程序

在计算机中，设备驱动程序是一种计算机程序，它能够控制挥着操作连接到计算机的特定设备。驱动程序提供了与硬件进行交互的接口，使操作系统和其他计算机能够访问特定设备，不需要了解其硬件的具体构造。

## 1.19、进程间的通信方式

通信概念：
进程间的通信方式比较多，首先需要理解下面这几个概念：

1. 竞态条件：两个或多个线程同时对一个共享数据进行修改，从而影响程序运行的正确性，这种被称之为“竞态条件”

2. 临界区：不仅共享资源会造成竞态条件，事实上共享概念给文件、共享内存也会造成竞态条件，那么该如何避免呢？一句话概括：进程一个或多个进程在同一时刻多共享概念给资源（包括共享内存、共享文件等）进行读写。换句话说：我们需要一种互斥条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这件事（访问统一资源）。
   一个好的解决方案应该包含下面四种条件：

   1. 任何时候两个进程不能同时处于临界区
   2. 不应对CPU的速度和数量做出任何假设
   3. 位于临界区之外的进程不得阻塞其他进程
   4. 不能使用任何进程无限等待进入临界区

   使用临界区的互斥

   ![image-20220921152047944](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921152047944.png)

3. 忙等互斥：当一个进程在对资源进行修改的似乎后，其他进程必须进行等待，进程之间要有互斥性，我们讨论的解决方案其实都是基于忙等互斥提出的。

解决方案
进程的通信用专业一点的属于来表示就是IPC（Inter Process Communication），它主要又下面几种通信方式：

1. 消息传递：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行同行；消息传递分为发送方和接收方
2. 先进先出队列：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式
3. 管道：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工需要另一各管道。
4. 直接通信：在这种进程通信的方式中，进程与进程之间只存在一种链接，进程间需要明确通信双方的命名
5. 间接通信：间接通信是通信双方不会直接简历连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中方知消息，并且可以从中删除消息，以此达到进程间通信的目的
6. 消息队列：消息队列是内核中存储消息的链表，他是由消息队标识符进行标识，这种方式能够在不同进程之间提供全双工的通信链接。
7. 共享内存：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。

![image-20220921152434153](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921152434153.png)



## 1.20、进程间的状态模型

```linux
cat chapter1 chapter2 chapter3 | grep tree
```

第一个进程是cat，将三个文件级联并输出，第二个进程是grep，他从输入中选择具有包含关键字tree的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的CPU时间片），可能会发生下面这种情况，grep准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。

当一个进程开始运行时，它可能会经历下面这几种状态：

![image-20220921153736279](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921153736279.png)

以上是进程间的状态切换图。

图中会涉及三种状态：

1. 运行态：运行态指的是进程实际占用CPU时间片段运行时
2. 就绪态：就绪态是指可运行，但因为其他进程正在运行而处于就绪状态
3. 阻塞态：除非某种外部事件发生，否则进程不能运行

逻辑上来说，运行态和就绪态是很相似的。这两种情况下都标识进程可运行，但是第二种情况没有获得CPU的时间分片。第三种情况与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。

三种状态会涉及四种状态间的切换：

1. 转换1——>
   在<font color = "red">**操作系统发现进程不能继续执行时候会发生状态1的轮转**</font>，在<font color = "red">**某些系统中进程执行系统调用，例如 pause，来获取一个阻塞的状态**</font>。在其他系统中，包括UNIX，<font color = "red">**当进程从管道或者特殊文件中读取没有可用的输入时**</font>，该进程会自动被终止。

2. 转换2和转换3——>
   <font color = "red">**都是由进程调度程序等（操作系统的一部分）引起的，进程本身不知道调度程序的存在**</font>。转换2的出现说明<font color = "blue">**进程调度器认定当前进程已经运行了足够长的时间**</font>，是时候让其他进程运行CPU时间片了。<font color = "blue">**当所有其他进程都运行过后，这个时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3**</font>。

   > 程序调度指的是：决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。

3. 转换4——>
   当<font color = "red">**进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换4**</font>。如果此时没有其他进程在运行，则立刻出发转换3，该进程便开始运行，否则该进程就会处于就绪状态，等待CPU空闲后在轮到它运行。

## 1.21、进程调度算法有那些

调度算法分为三大类：批处理中的调度、交互式系统中的调度、实时系统中的调度。

1. 批处理中的调度

   1. 先来先服务
      很像是先到先得。。。可能最简单的非抢占式调度算法的设计就是先来先服务。使用此算法将按照请求顺序为进程分配CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。他不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞时，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪状态时，他会像一个新到达的任务排在对垒的末尾，即排在所有进程最后。
      ![image-20220921191648999](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921191648999.png)

      这个算法的强大之处在于以于理解和编程，在这个算法中一个单链表表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者和阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。

      不过，先来先服务也是有缺点的，那就是没有优先级的关系，试想一下，如果有100个I/O线程正在排队，第101个是一个CPU密集型的进程，那岂不是需要等100个I/O进程运行完毕之后才会等到一个CPU密集型进程运行，这在实际的情况下该根本不可能，所以需要优先级或者抢占式进程来优先选择重要的进程运行。
      
   2. 最短作业优先
      批处理中，第二种调度算法是：最短作业优先（Shortest Job First），我们假设运行时间已知。例如：一家保险公司，因为每天要做类似的工作，所以人们可以相当精确的预测处理1000个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短作业优先算法
   
      ![image-20220921192706196](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921192706196.png)
         如上图a所示，这里有4个作业A、B、C、D，运行是啊金分别是8、4、4、4分钟。若按图片中的次序运行，则A的周转时间为8分钟，B为12分钟，C为16分钟，D为20分钟，平均时间为14分钟。
         现在考虑使用最短作业优先算法运行4个作业，如上图b所示，目前的周转时间分别为4、8、12、20，平均分中为11分钟，可以证明最短作业优先是最优的。考虑4个作业的情况，其运行时间分别为a、b、c、d。第一个作业在时间a结束，第二个在a+b结束以此类推。平均周转时间为（4a+3b+2c+d）/4.显然a对平均值的影响最大，所以a应该是最淡优先作业，其次是b，然后是c，最后是d他只能影响自己的周转时间了。
   
      > **<font color = "red">需要注意的是，在所有进程都可以运行的情况下，最短作业优先的算法才是最优秀的。</font>**
   
   
   
   3. 最短剩余时间优先
         最短作业优先的抢占式版本被称为：`最短剩余时间优先 `  算法。使用这个算法，调度程序总是选择剩余时间最短的哪个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间比较，如果新的进程比当前运行进程需要更少时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。
   
2. 交互式系统中的调度
   交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度。

   1. 轮询调度
      一种最古老、最简单、最公平且最广泛使用的算法就是：`轮询算法`。每个进程都会被分配一个时间段，称之为`时间片`，在这个时间片内允许进程运行。
      如果时间片结束时进程还在运行的的话，则抢占一个CPU并将其分配给另一个进程。
      如果进程在时间片结束前阻塞或结束，则CPU立即进行切换。

      轮询算法比较容易实现。调度程序所作的就是维护一个可运行的列表，就像下图中的a，当一个进程用完时间片后就被移动到队列的末尾，就像下图的b。

      ![image-20220921195105569](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921195105569.png)
      
   2. 优先级调度
   
      事实情况是不是所有进程都是优先级相等的。例如：在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员、最后是学生，这种将外部情况考虑在内就实现了优先级调度（priority scheduling）。
   
      它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。
   
      但是也不意味着高优先级的进程都能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完之后，下一个高优先级的进程会得到运行的机会。
   
   3. 最短进程优先
   
      对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的哪一个。假设每个终端上每条命令的预估运行时间为T0，现在假设测量到其下一次运行时间为T1，可以用两个值的加权来改进估计时间，即aT0+(1-1)T1。通过选择a的值，可以决定是尽快忘掉老的运行时间，还是在一段时间内始终记住它们。当a = 1/2时，可以得到下面这个序列。
   
      ![image-20220921201303839](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220921201303839.png)
      可以看到，在三轮过后，T0在新的估计值中所占比重下降值1/8。
      有时把这种通过**当前测量值**和**先前预估值**进行<u>*加权平均*</u>从而<font color = "red">**得到下一个估计值的技术**</font>称之为：`老化`。这种方法会使用很多预测值基于当前值的情况。
   
   4. 彩票调度
       有一种即可以给出预测结果而又比较简单的实现方式的算法，就是：`彩票调度`  算法。它的基本思想为进程提供各种系统资源的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得资源。比如在CPU进行调度时，系统可以每秒持有50次抽奖，每个中奖进程会获得额外运行时的奖励。
   
     > 可以把彩票理解为buff，这个buff有15%的几率能让你产生速度之靴的效果。
   
   5. 公平分享调度
       如果用户1启动了9个进程，而用户2启动了一个进程，使用轮转或者优先级调度算法，那么用户1将得到90%的CPU的时间，而用户2将之得到的10%的CPU时间。
   
     为了阻止这种情况的出现，一些系统在调度之前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有50%的CPU时间片保证，那么无论一个用户又多少个进程，都将获得相同的CPU份额。
   
3. 实时系统中的调度
   没说

## 1.22、页面置换算法都有哪些

1. 最优算法：在当前页面中置换最后要访问的页面，不幸的是没有办法来判断哪个页面是最后一个要访问的。因此实际上该算法不能使用。但是他作为可以衡量其他算法的标准
2. NRU：根据R位和M位的状态将页面分为四类。从编号最小的类别中随机一个页面。NRU算法以于实现，但是性能不是很好，存在更好的算法。
3. FIFO：会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一种很好的选择。
4. 第二次机会：是对FIFO的一个修改，他会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留，这个改进大大提高了性能。
5. 时钟：是第二次机会算法的另一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。
6. LRU：是一个非常优秀的算法，但是没有特殊的硬件（TLB）很难实现。如果没有硬件，就不能使用LRU算法。
7. NFU：是一种类似于LRU的算法，它的性能不是非常好
8. 老化：是一种更接近LRU算法的实现，并且可以更好的实现，因此是一种更好的选择。
9. 最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。WSClock是另一种变体，它不仅能够提供良好的性能，而且可以高效的实现。

## 1.23、影响调度程序的指标是什么

1. CPU使用率：CPU正在执行任务（即不处于空闲状态）的时间百分比
2. 等待时间：这是进程轮流执行的时间，也就是进程切换的时间
3. 吞吐量：单位时间被完成进程的数量
4. 响应时间：这是从提交流程到获得有用输出所经过的时间
5. 周转时间：从提交流程到完成流程所经过的时间

## 1.24、什么是僵尸进程

僵尸进程是已经完成且处于终止状态，但在进程表中任然存在进程。僵尸进程通常发生在父子关系的进程中，由于父进程任然需要读取其紫禁城的退出状态所造成的。

我们都知道进程的工作原理。我们启动一个程序，开始我们的任务，然后等任务结束了，我们就停止这个进程。 进程停止后， 该进程就会从进程表中移除。
但是，有时候有些程序即使执行完了也依然留在进程表中。
那么，这些完成了生命周期但却依然留在进程表中的进程，我们称之为 “僵尸进程”。

僵尸进程的产生？
当你运行一个程序时，它会产生一个父进程以及很多子进程。 所有这些子进程都会消耗内核分配给它们的内存和 CPU 资源。这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 wait 命令来读取子进程的退出状态，并将子进程从进程表中移除。若父进程正确第读取了子进程的 Exit 信号，则子进程会从进程表中删掉。但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。

僵尸进程对系统有害吗？
不会。由于僵尸进程并不做任何事情， 不会使用任何资源也不会影响其它进程， 因此存在僵尸进程也没什么坏处。 不过由于进程表中的退出状态以及其它一些进程信息也是存储在内存中的，因此存在太多僵尸进程有时也会是一些问题。
例如：“你是一家建筑公司的老板。你每天根据工人们的工作量来支付工资。 有一个工人每天来到施工现场，就坐在那里， 你不用付钱， 他也不做任何工作。 他只是每天都来然后呆坐在那，仅此而已！”

那么如何找出僵尸进程呢？
打开终端并输入下面命令：ps -aux | grep Z；会列出进程表中所有僵尸进程的详细内容。





# 2、操作系统面试题（2021最新版）

## 2.1、Linux概述

### 2.1.1、什么是Linux

Linux是一套免费使用和自由传播的类UNIX操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。他能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。

### 2.1.2、什么是Linux内核

Linux系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。

1. 系统内存管理
2. 应用程序管理
3. 硬件设备管理
4. 文件系统管理

### 2.1.3、为什么Linux体系结构要分为用户空间和内核空间？

1. 现代CPU实现了不同的工作模式，不同模式下CPU可以执行的指令和访问的计算器不同
2. Linux从CPU的角度出发，为了保护内核的安全，把系统分成了两部分

用户空间和内核空间是程序执行的两种不同的状态，我们可以通过两种方式完成用户空间到内核空间的转移：

1. 系统调用
2. 硬件中断

### 2.1.4、Linux开机启动过程

1. 主机加电自检，加载BIOS硬件信息
2. 读取MBR的引导文件
3. 引导Linux内核
4. 运行第一个进程init（进程号永远是1）
5. 进入相应的运行级别
6. 运行终端，输入用户名和密码

### 2.1.5、什么是root账户

root账户就像一个系统管理员账户，允许你完全控制系统。你可以在此处创建和维护用户账户，为每个账户分配不同的权限。每次安装Linux时都是默认账户。



## 2.2、磁盘、目录、文件

### 2.2.1、Linux的目录结构是怎么样的

Linux文件系统的结构层次鲜明，就像一颗倒立的树，最顶层是其根目录；
![image-20220922173008744](D:\Tyora\AssociatedPicturesInTheArticles\操作系统-面试题-1\image-20220922173008744.png)

常见目录说明：

1. /bin：存放二进制可执行文件（ls、cat、mkdir等），常用命令一般放在这里
2. /etc：存放系统管理和配置文件
3. /home：存放所有用户文件的根目录，是用户主目录基点，比如用户user的主目录就是/home/user，可以用~user表示。
4. /user：用于存放系统应用程序
5. /opt：额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里
6. /proc：虚拟文件系统目录，是系统内存的映射。可以直接访问这个目录来获取系统信息
7. /root：超级用户（系统管理员）的主目录（特权阶级o）；
8. /sbin：存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；
9. /dev：用于存放设备文件
10. /mnt：系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统
11. /boot：存放用于系统引导时使用的各种文件
12. /lib：存放着用于系统引导时使用的各种文件
13. /tmp：用于存放各种临时文件，是公用的临时文件存储点
14. /var：用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等）等。
15. /lost+found：这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫xxx.chk）就在这里

## 





