#时间局部性 #空间局部性 

<u>这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对八股文总结。</u>

操作系统八股文来自：

1. [《代码随想录知识星球精华-大厂面试八股文v1.2.pdf》](D:\z_知识星球\代码随想录\代码随想录知识星球精华PDF-大厂面试八股文\代码随想录知识星球精华-大厂面试八股文v1.2.pdf)【在上一篇】
2. [《JavaGuide面试突击版4.0.pdf》](D:\z_知识星球\JavaGuide\JavaGuide的知识星球\JavaGuide面试突击版\JavaGuide面试突击版4.0.pdf)（有5.0版的，再看的时候对比着看）

续接 《操作系统-八股文-2.md》中的 2、Java Guide中的内容

## 2.3、操作系统内存管理基础

### 2.3.1、内存管理介绍

内存管理主要是做什么？

负责内存的分配与回收（malloc函数：申请内存、free函数：释放内存)，另外地转换，也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情

### 2.3.2、常见的几种内存管理机制

简单分为***连续分配管理方式***和***非连续分配管理方式***这两种。

1. 连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如<u>*块式管理*</u>；
2. 非连续分配管理方式允许一个程序使用的内存分布在离散或不相邻的内存中，常见的如<u>*页式管理*</u>和<u>*段式管理*</u>

**块式管理：** 远古时代计算机操作系统的内存管理方式，将内存分为几个固定的大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统分配给他一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中违背利用的空间，我们称之为碎片。

**页式管理：** 把主存分为大小相等且固定的一页一页的形式，页较小，相对于快式管理的划分粒度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址

**段式管理：** 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并没有任何实际的意义。段式管理把贮存分为一段段的，每一段的空间又比一页的空间小很多，但是最重要的时段是有实际的意义的，每个段定义了一组逻辑信息；例如：有主程序段MAIN、子程序段X、数据段D和栈段S等。段式管理通过段表对应逻辑地址和物理地址

**段页式管理：** 结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存县分为若干段，每个段又分为若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。

### 2.3.3、分页机制和分段机制的共同点和区别

共同点：

1. 都是为了提高内存利用率，较少内存碎片
2. 段和页都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的

区别：

1. 页的大小是固定的，由操作系统来决定；段的大小是不固定的额，取决于我们当前运行的程序
2. 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段、数据段，能够更好的满足用户的需要。



### 2.3.4、逻辑（虚拟）地址和物理地址

我们编程⼀般只有可能和逻辑地址打交道，⽐如在 C 语⾔中，指针⾥⾯存 
储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。

### 2.3.5、什么是CPU寻址？为什么需要虚拟地址空间？

CPU寻址：
现代处理器使用的是一种称为虚拟寻址的寻址方式。使用虚拟寻址，CPU需要将虚拟地址翻译为物理地址，这样才能访问到指针物理内存。实际上完成虚拟地址转换为物理地址转换的硬件是CPU中含有一个被称之为内存管理单元（MMU）的硬件。

为什么需要虚拟地址空间？：
先从没有虚拟地址空间的时候开始说，没有虚拟地址空间的时候，程序直接访问和操作的都是物理内存，这样有什么问题呢？

1. 用户程序可以访问任意内存，寻址内存的每个字节，这样很容易（有意或者无意）的破坏操作系统，造成操作系统崩溃
2. 想要通知运行多个程序特别困难，比如你想同时运行一个微信和一个QQ音乐都不行；为什么呢？举个简单的例子：微信在运行的时候给内存1xxx赋值之后，QQ音乐也同样给内存地址1xxx赋值，那么QQ音乐的赋值就会覆盖微信之前所赋的值，这就造成了微这个程序的崩溃

总结来说：如果直接把物理内存地址暴漏出来的话会代码来很严重的问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困困难。

通过虚拟地址访问内存有以下优势：

1. 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
2. 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页面（通常大小为4kb）保存到磁盘文件。数据或者代码页会根据需要在物理内存与磁盘之间移动
3. 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存



## 2.4、虚拟内存

### 2.4.1、什么是虚拟内存？

这个在我们平时使⽤电脑特别是 Windows 系统的时候太常⻅了。很多时候我们使⽤点开了很多占内存的软件，这些软件占⽤的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？  正是因为  虚拟内存  的存在，通过  虚拟内存  可以让程序可以拥有超过系统物理内存⼤⼩的可⽤内存空间。另外，虚拟内存为每个进程提供了⼀个⼀致的、私有的地址空间，它让每个进程产⽣了⼀种⾃⼰在独享主存的错觉（每个进程拥有⼀⽚连续完整的内存空间）。这样会更加有效地管理内存并减少出错。

虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存”。虚拟内存的重要意义在于是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。

> 维基百科的介绍：
> 使得应用程序认为他拥有连续的可用的内存（一个完整的地址空间），而实际上，他通常是被分割为多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上的，在需要的时候进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的百年西变得更加容易，对真正的物理内存（如RAM）的使用也更有效率。目前大多数操作系统都是用了虚拟内存，如：Windows家族的虚拟内存；

### 2.4.2、局部性原理

要更好的理解虚拟内存技术，必须要知道计算机中的局部性原理。另外局部性原理即适用于程序结构，也适用于数据结构，是非常重要的一个概念。

局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存中就可以开始运行。

局部性原理表现在以下两个方面：

1. <font color="red" size=5>时间局部性</font>：如果程序中某条执行一旦执行，不久之后该指令还可能再次执行；如果某条数据北方问过，不久后该数据可能再次被访问。产生时间局部性的典型原因是：在程序中存在大量的循环操作
2. <font color="red" size=5>空间局部性</font>：一旦程序访问了某个某个存储单元，在不久之后其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围内，这是因为指令通常是顺序存放、顺序执行的，数据一般是以向量、数组、表形式聚簇存储的。

时间局部性是通过将近来使用的指令和数据保存到 <u><font color="red" size=5>高速缓存存储器</font></u> 中，并使用高速缓存的层次结构实现。

空间局部性通常是使用<u><font color="red" size=5>较大的高速缓存</font></u>，并将预取机制集成到高速缓存控制逻辑中实现。

虚拟内存技术实际上就是建立了“内存——外存”的两级存储的结构，利用局部性原理实现高速缓存

### 2.4.3、再看虚拟内存

基于局部性原理，在程序装⼊时，可以将程序的⼀部分装⼊内存，⽽将其他部分留在外存，就可以启动程序执⾏。由于外存往往⽐内存⼤很多，所以我们运⾏的软件的内存⼤⼩实际上是可以⽐计算机系统实际的内存⼤⼩⼤的。在程序执⾏过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调⼊内存，然后继续执⾏程序。另⼀⽅⾯，操作系统将内存中暂时不使⽤的内容换到外存上，从⽽腾出空间存放将要调⼊内存的信息。这样，计算机好像为⽤户提供了⼀个⽐实际内存⼤的多的存储器——虚拟存储器。

实际上，我觉得虚拟内存同样是⼀种时间换空间的策略，你⽤ CPU 的计算时间，⻚的调⼊调出花费的时间，换来了⼀个虚拟的更⼤的空间来⽀持程序的运⾏。不得不感叹，程序世界⼏乎不是时间换空间就是空间换时间。

### 2.4.4、虚拟内存的技术实现

虚拟捏村的实现愮建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

1. 请求分页存储管理：建⽴在分⻚管理之上，为了⽀持虚拟存储器功能⽽增加了请求调⻚功能和⻚⾯置换功能。请求分⻚是⽬前最常⽤的⼀种实现虚拟存储器的⽅法。请求分⻚存储管理系统中，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏。假如在作业运⾏的过程中发现要访问的⻚⾯不在内存，则由处理器通知操作系统按照对应的⻚⾯置换算法将相应的⻚⾯调⼊到主存，同时操作系统也可以将暂时不⽤的⻚⾯置换到外存中。
2. 请求分段存储管理：建⽴在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理⽅式就如同请求分⻚储存管理⽅式⼀样，在作业开始运⾏之前，仅装⼊当前要执⾏的部分段即可运⾏；在执⾏过程中，可使⽤请求调⼊中断动态装⼊要访问但⼜不在内存的程序段；当内存空间已满，⽽⼜需要装⼊新的段时，根据置换功能适当调出某个段，以便腾出空间⽽装⼊新的段。
3. 请求段页式存储管理：

**这⾥多说⼀下？很多⼈容易搞混请求分⻚与分⻚存储管理，两者有何不同呢？**

请求分⻚存储管理建⽴在分⻚管理之上。他们的根本区别是是否将程序全部所需的全部地址空间同时都装⼊主存，这也是请求分⻚存储管理可以提供虚拟内存的原因，我们在上⾯已经分析过了；请求分⻚存储管理不要求将作业全部地址空间同时装⼊主存。基于这⼀点，请求分⻚存储管理可以提供虚存，⽽分⻚存储管理却不能提供虚存。

无论是以上三种方式的哪一种，我们一般都需要：

1. 一定容量的内存和外村：在载入程序的时候，只需要将程序的一部分装入内存，而将其他的部分留在外存，然后程序就可以执行了；
2. 缺页中断：在程序执行时，如果需要执行的指令或者访问的数据尚未存在于内存（称之为缺页或缺段），则由处理器通知操作系统将相应的页或段调入内存，然后继续执行程序。

### 2.4.5、页面置换算法

虚拟内存管理很重要的一个概念就是页面置换算法，常见的页面置换算法有哪些？

缺页中断：就是要访问的页不在贮存中，需要操作系统将其调入主存后再进行访问。在这个时候，被内存映射的文件实际上成了一个分页交换文件。

当发生缺页中断的时候，如果当前内存中并没有空闲的页面，那么操作系统就必须在内存中选择一个页面将其移除内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。我们可以把页面置换算法看是淘汰页面的规则。

1. OPT页面置换算法（最佳页面置换算法）：该算法所选择的被淘汰的页面将是以后不适用的，或是再最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程在内存下的若干页面中那个是未来最长时间不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。
2. FIFO页面置换算法（先进先出页面置换算法）：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最长的页面进行淘汰
3. LRU页面置换算法（最近最久未使用页面置换算法）：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当需要淘汰一个页面时，选择现有页面中T值最大的，并且未使用的页面予以淘汰
4. LFU页面置换算法（最少使用页面置换算法）：该置换算法选择在之前时期是用最少的页面作为淘汰页。









