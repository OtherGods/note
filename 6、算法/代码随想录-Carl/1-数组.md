# 声明

在本类笔记中，一个思路可能有多种解决方式，而一种解决办法只对应一种思路，本系列笔记基本都是这种结构。



# 1、数组理论基础

需要关注两点

1. 数组下标都是从0开始的。

2. 数组内存空间的地址是连续的（这说的是一维数组中的元素的地址，而二维数组中每一维的数组的地址是不连续的）

   1. 因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址来覆盖待删除的地址的元素。

   2. 二维数组中每一维的内存地址不连续，但是每一维数组中的元素对应的地址连续：

      ```java
      public static void test_arr() {
          int[][] arr = {{1, 2, 3}, {3, 4, 5}, {6, 7, 8}, {9,9,9}};
          System.out.println(arr[0]);
          System.out.println(arr[1]);
          System.out.println(arr[2]);
          System.out.println(arr[3]);
      }
      ```

      输出为：

      ```
      [I@7852e922
      [I@4e25154f
      [I@70dea4e
      [I@5c647e05
      ```

# 2、二分法

## 描述

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```text
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4     
```

示例 2:

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1        
```

提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

## 思路

**这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

### 方式一：[left, right]对应的代码

注意两点：

1. while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
2. if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

![704.二分查找](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\20210311153055723.jpg)

```java
/**
param: nums是二分查找的数组
	   target是在数组中要查找的值
*/
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```

### 方式二：[left, right)对应的代码

注意两点：

1. while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
2. if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

![704.二分查找1](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\20210311153123632.jpg)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid;
        }
        return -1;
    }
}
```



# 3、移除元素

## 描述

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**



## 方法一：暴力解法

思路：这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。删除过程如下：

![27.移除元素-暴力解法](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\008eGmZEly1gntrc7x9tjg30du09m1ky.gif)

很明显暴力解法的时间复杂度是O(n^2)

代码略



## 方法二：双指针法（快慢指针法）

思路：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**
快指针：寻找新数组的元素，新数组就是不含有目标元素的数组
慢指针：指向更新数组的下标的位置，



> 我的思路
>
> 我认为快指针的作用：
>
> 1. 找到目标元素之后通知慢指针：我发现了一个目标元素，你看看自己是不是可以指向这里；
> 2. 扫描数组中的元素，同时判断自己指向的元素是否是目标元素，如果指向的元素不是目标元素，那么将指向的非目标元素移动到慢指针指向的目标元素所在的索引下
>
> 综合下来：快指针指向的位置对应的元素：
>
> 1. 目标元素：通知慢指针这里有目标元素
> 2. 非目标元素：判断慢元素指向的值是否是目标元素，如果是则将快指针指向的元素移动到慢指针指向的位置；否则快指针继续向后移动
>
> 我认为慢指针的作用：
>
> 1. 接受快指针的通知并判断自己指向的元素是不是目标元素，如果不是目标元素，那么慢指针就可以指向快指针指向的位置；如果指向的是目标元素，那么慢指针指向的位置不动
>
> ```java
> public int simulateDelete(int[] nums,int val)
> {
>     int fast = 0;
>     int slow = 0;
>     //每次循环都会修改快指针的位置
>     for (fast = 0; fast < nums.length; fast++)
>     {
>         if(nums[fast] == val)
>         {
>             //只有当慢指针指向的位置是目标元素时才会修改慢指针指向的位置
>             if(nums[slow] != val){
>                 slow = fast;
>             }
>         } else if(nums[fast] != val) {
>             //如果慢指针指向的值是目标元素，并且快指针指向的值是不是目标元素
>             //就会发生交换
>             //只要发生交换元素，慢指针的值始终指向的是新数组中第一个目标元素
>             //的位置，最终该值也就是新数组中非目标元素的值的个数
>             if(nums[slow] == val){
>                 nums[slow] = nums[fast];
>                 nums[fast] = val;
>                 slow++;
>             }
>         }
>     }
>     //只要移动完毕后数组最后一个元素指向的位置的元素不是目标元
>     //素，那么证明该数组中没有目标元素，直接返回数组的长度即可（也就是快指针的值），如果该值为目标元素，那么
>     //证明数组中有元素发生了移动，那么慢指针索引的值就是修改后数组中非目标元素的个数
>     return (nums.length != 0)?(nums[nums.length-1] != val)?fast+1:slow:0;
> }
> ```
>
> 这个算法我在分析的时候没看清最后要返回的是最终数组中不包含目标元素的元素个数，所以在最后return的时候复杂了些；



删除过程如下：

![27.移除元素-双指针法](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\008eGmZEly1gntrds6r59g30du09mnpd.gif)

这种思路对应的代码：

```java
class Solution {
    public int removeElement(int[] nums, int val) {

        // 快慢指针
        int fastIndex = 0;
        int slowIndex;
        for (slowIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;

    }
}
```

# 4、有序数组的平方

## 描述

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]

## 方法一：双指针法

思路：

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];` 。

如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];` 。

如动画所示：

![img](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\977.有序数组的平方.gif)

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int right = nums.length - 1;
        int left = 0;
        int[] result = new int[nums.length];
        int index = result.length - 1;
        while (left <= right) {
            if (nums[left] * nums[left] > nums[right] * nums[right]) {
                // 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置
                result[index--] = nums[left] * nums[left];
                ++left;
            } else {
                result[index--] = nums[right] * nums[right];
                --right;
            }
        }
        return result;
    }
}
```



# 5、长度最小的子数组

## 描述

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

## 方法一：滑动窗口

思路：所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。

那么滑动窗口如何用一个for循环来完成这个操作呢。

首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？

此时难免再次陷入 暴力解法的怪圈。

`所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。`

> 这里的解释不是很清晰，这段话的目的应该是为了解释怎么才能让人想到为什么for循环的索引是滑动窗口的终止位置，但是这段话明显没有解释；
>
> 我认为正确的解释应该是：为了确保数组中每个元素都被遍历到同时又达到终止循环的目的，所以才将for循环的索引设置为滑动窗口的终止位置；因为滑动窗口的起始位置不一定能到达数组的最后一个位置，同时循环也不能依赖该位置决定循环知否应该结束，因为滑动窗口的起始位置和终止位置之间的元素的个数是不确定的。

那么问题来了， 滑动窗口的起始位置如何移动呢？

这里还是以题目中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：

![209.长度最小的子数组](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\209.长度最小的子数组.gif)

最后找到 4，3 是最短距离。

其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
  - 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。
- 如何移动窗口的起始位置？
  - 窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。
- 如何移动窗口的结束位置？
  - 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

解题的关键在于 窗口的起始位置如何移动，如图所示：

![leetcode_209](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\20210312160441942.png)

可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

窗口滑动的本质是通过数组上的指针的移动来实现的，只要在使用指针遍历数组，<font color="red"><u>***窗口就会根据数组中指针指向的元素与窗口中已有的元素的关系来判断窗口怎么滑动***</u></font>，最终导致我们看到的是窗口在滑动。



```java
class Solution {

    // 滑动窗口
    public int minSubArrayLen(int s, int[] nums) {
        int left = 0;//滑动窗口起始位置
        int sum = 0;//滑动窗口数值之和
        int result = Integer.MAX_VALUE;//用于记录滑动窗口中最小的长度
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            //这里使用while，每次循环都会判断是否需要更新滑动窗口的起始位置，如果需要，起始位置值++；
            while (sum >= s) {
                result = Math.min(result, right - left + 1);
                sum -= nums[left++];
            }
        }
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```

- 时间复杂度：O(n)
  - 不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)
- 空间复杂度：O(1)

# 6、最小覆盖字串

## 描述

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。


示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"
示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。


提示：

1 <= s.length, t.length <= 105
s 和 t 由英文字母组成

## 方法一：滑动窗口

思路：

本问题要求我们返回字符串 s 中包含字符串 t 的全部字符的最小窗口。我们称包含 t 的全部字母的窗口为「可行」窗口。

我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

![fig1](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\76_fig1.gif)

如何判断当前的窗口包含所有 t 所需的字符呢？我们可以用一个哈希表表示 t 中所有的字符以及它们的个数，用一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 t 的哈希表中的所有字符，并且对应的个数都不小于 t 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。

注意：这里 t 中可能出现重复的字符，所以我们要记录字符的个数。

考虑如何优化？ 如果 s = XX \... XABCXXXX，t = ABCt=ABC，那么显然  XX⋯XABC是第一个得到的「可行」区间，得到这个可行区间后，我们按照「收缩」窗口的原则更新左边界，得到最小区间。我们其实做了一些无用的操作，就是更新右边界的时候「延伸」进了很多无用的 XX，更新左边界的时候「收缩」扔掉了这些无用的 XX，做了这么多无用的操作，只是为了得到短短的 ABC。没错，其实在 s 中，有的字符我们是不关心的，我们只关心 t 中出现的字符，我们可不可以先预处理 s，扔掉那些 t 中没有出现的字符，然后再做滑动窗口呢？也许你会说，这样可能出现 XXABXXCXXABXXC 的情况，在统计长度的时候可以扔掉前两个 XX，但是不扔掉中间的 XX，怎样解决这个问题呢？优化后的时空复杂度又是多少？这里代码给出没有优化的版本，但是我感觉这里的描述有些像我用双指针删除数组中元素的作用。

这个思路对应的代码就略过了；如果我看完代码随想录的算法之后还有时间再来看看。



# 7、螺旋矩阵

## 描述

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]



## 思路

大家还记得我们在这篇文章[数组：每次遇到二分法，都是一看就会，一写就废 (opens new window)](https://programmercarl.com/0704.二分查找.html)中讲解了二分法，提到如果要写出正确的二分法一定要坚持**循环不变量原则**。

而求解本题依然是要坚持循环不变量原则。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是**一进循环深似海，从此offer是路人**。

这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。

那么我按照左闭右开的原则，来画一圈，大家看一下：

![螺旋矩阵](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\2020121623550681.png)

这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。

这也是坚持了每条边左闭右开的原则。

> 从这个图中可以看出来：当n是3、5、7时正方形的边便是3、5、7，而每次循环一次，下一次循环的正方形的边就是3-2、5-2、7-2，，由此可以每次循环一次都会执行n-2，可以将其想象成在找某个数的最中间的数字。
>
> 现在来描述一个场景：找一个包含正整数元素的数组被平分成两个数组的位置（数组的索引）；
> 		假设这个数组的长度为n，那么找到这个位置（数组的索引）的计算方式是：
> 			if (n/2 == (n-1)/2) index = n/2;		//这种情况下n为奇数
> 			else index 不存在;	//这种情况下n为偶数

```java
public int[][] generateMatrix(int n) {
    int startx = 0;     //相当于矩阵放坐标系下某个点的横坐标索引
    int starty = 0;     //相当于矩阵放坐标系下某个点的纵坐标索引
    int flag = n%2;     //用于记录n是奇数还是偶数
    int count = n/2;    //用于记录循环的次数，如果n是奇数还需要
    //在循环完之后需要给矩阵正中间的元素赋
    //值，该元素的横纵坐标都是n/2，否则不需要
    int[][] arr = new int[n][n];//最后输出的数组
    int minus = 0;      //矩阵边界控制
    int sum = 0;        //每个元素

    //外循环中的i代表的是循环的次数，也就是螺旋的第几层

    for (int i = 1; i <= count; i++)
    {
        //第一次螺旋时，内部循环的次数为n-1
        //每螺旋完一层（也就是外循环执行完一次），下一次内
        //部的循环循环的次数值为n-2*外循环次数，所以这里使用minus来记录
        minus++;

        //在每个内循环中都会修改startx和straty的值，来达到修改二维数组中
        //对应位置的元素的目的

        //在该内循环中遍历的值是startx，在螺旋中，遍历正方形上边界
        for (; startx <= n-1-minus; startx++)
        {
            arr[starty][startx] = ++sum;
        }
        //在该内循环中遍历的值是starty，在螺旋中，遍历正方形右边界
        for (; starty <= n-1-minus; starty++)
        {
            arr[starty][startx] = ++sum;
        }
        //在该内循环中遍历的值是startx，在螺旋中，遍历正方形下边界
        for (; startx >= minus; startx--)
        {
            arr[starty][startx] = ++sum;

        }
        //在该内循环中遍历的值是starty，在螺旋中，遍历正方形右边界
        for (; starty >= minus; starty--)
        {
            arr[starty][startx] = ++sum;
        }
        //保证每次循环都是从当前需要循环的矩阵的（0,0）位置开始
        startx++;
        starty++;
    }
    if (flag != 0)
        arr[n/2][n/2] = n*n;
    return arr;
}
```



# 8、总结

![img](D:\Tyora\AssociatedPicturesInTheArticles\1-数组\数组总结.png)











