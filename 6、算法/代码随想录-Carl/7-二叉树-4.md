# 1、合并二叉树

## 描述

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

![617.合并二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20210204153634809.png)

注意: 合并必须从两个树的根节点开始。



## 思路

相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？

其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。

### 方法一：递归

二叉树使用递归，就要想使用前中后哪种遍历方式？

**本题使用哪种遍历都是可以的！**

我们下面以前序遍历为例。

动画如下：

![617.合并二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\008eGmZEly1gnbjjq8h16g30e20cwnpd.gif)

那么我们来按照递归三部曲来解决：

1. **确定递归函数的参数和返回值：**

首先那么要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。

代码如下：

```java
TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
```

2. **确定终止条件：**

因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。

反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。

代码如下：

```java
if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
```

3. **确定单层递归的逻辑：**

单层递归的逻辑就比较好些了，这里我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。

那么单层递归中，就要把两棵树的元素加到一起。

```java
t1.val += t2.val;
```

接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。

t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。

最终t1就是合并之后的根节点。

代码如下：

```java
t1.left = mergeTrees(t1.left, t2.left);
t1.right = mergeTrees(t1.right, t2.right);
return t1;
```

此时前序遍历，完整代码就写出来了，如下：

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
};
```



我的代码：

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    //这一段代码有些多余
    if(root1 == null && root2 == null) return null;
    //直接将root2替换掉空的root1在root1所在树上的位置
    if(root1 == null && root2 != null) return root2;
    //不对root1做操作
    if(root1 != null && root2 == null) return root1;
    
    //当root1和root2都不是null的时候返回root1，只是把root1
    //对应的val改为root1.val+root2.val，指针什么的都没变化
    TreeNode leftnode = mergeTrees(root1.left, root2.left);     //左
    TreeNode rightnode = mergeTrees(root1.right, root2.right);  //右
    //修改在当前递归中root1的值或或指针：
    //  1. 修改值为root1.val+root2.val
    //  2. 修修改root1.left与root1.right的指向【如果在root1中为null而
    //     在root2中非null】
    root1.val = root1.val + root2.val;                          //中
    root1.left = leftnode;
    root1.right = rightnode;
    return root1;
}
```

### 方法二：迭代法

使用迭代法，如何同时处理两棵树呢？

思路我们在[二叉树：我对称么？ (opens new window)](https://programmercarl.com/0101.对称二叉树.html)中的迭代法已经讲过一次了，求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。

本题我们也使用队列，模拟的层序遍历，代码如下：

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue<TreeNode*> que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) {
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            // 此时两个节点一定不为空，val相加
            node1->val += node2->val;

            // 如果两棵树左节点都不为空，加入队列
            if (node1->left != NULL && node2->left != NULL) {
                que.push(node1->left);
                que.push(node2->left);
            }
            // 如果两棵树右节点都不为空，加入队列
            if (node1->right != NULL && node2->right != NULL) {
                que.push(node1->right);
                que.push(node2->right);
            }

            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1->left == NULL && node2->left != NULL) {
                node1->left = node2->left;
            }
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1->right == NULL && node2->right != NULL) {
                node1->right = node2->right;
            }
        }
        return t1;
    }
};
```

合并二叉树，也是二叉树操作的经典题目，如果没有接触过的话，其实并不简单，因为我们习惯了操作一个二叉树，一起操作两个二叉树，还会有点懵懵的。

这不是我们第一次操作两棵二叉树了，在[二叉树：我对称么？ (opens new window)](https://programmercarl.com/0101.对称二叉树.html)中也一起操作了两棵二叉树。

迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。

# 2、二叉树中的搜索树

## 描述

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，

![700.二叉搜索树中的搜索](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20210204155522476.png)

在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。

## 思路

之前我们讲了都是普通二叉树，那么接下来看看二叉搜索树。

在[关于二叉树，你该了解这些！ (opens new window)](https://programmercarl.com/二叉树理论基础.html)中，我们已经讲过了二叉搜索树。

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。

本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。

### 方法一：递归法

1. 确定递归函数的参数和返回值

递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。

代码如下：

```java
TreeNode searchBST(TreeNode root, int val)
```

2. 确定终止条件

如果root为空，或者找到这个数值了，就返回root节点。

```java
if (root == NULL || root.val == val) return root;
```

3. 确定单层递归的逻辑

看看二叉搜索树的单层递归逻辑有何不同。

因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。

如果root->val > val，搜索左子树，如果root->val < val，就搜索右子树，最后如果都没有搜索到，就返回NULL。

代码如下：

```java
TreeNode result = NULL;
if (root.val > val) result = searchBST(root.left, val);
if (root.val < val) result = searchBST(root.right, val);
return result;
```

很多录友写递归函数的时候 习惯直接写 `searchBST(root.left, val)`，却忘了 递归函数还有返回值。

递归函数的返回值是什么? 是 左子树如果搜索到了val，要将该节点返回。 如果不用一个变量将其接住，那么返回值不就没了。

所以要 `result = searchBST(root.left, val)`。

整体代码如下：

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == NULL || root.val == val) return root;
        TreeNode result = NULL;
        if (root.val > val) result = searchBST(root.left, val);
        if (root.val < val) result = searchBST(root.right, val);
        return result;
    }
}
```

### 方法二：迭代法

一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。

对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。

对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。

而**对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。**

例如要搜索元素为3的节点，**我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。**

中间节点如果大于3就向左走，如果小于3就向右走，如图：

![二叉搜索树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20200812190213280.png)

所以迭代法代码如下：

```java
public TreeNode searchBST(TreeNode root, int val) {
    while (root != null) {
        if (root.val == val) return root;
        else if (root.val > val) root = root.left;
        else root = root.right;
    }
    return null;
}
```

# 2、验证二叉搜索树

## 描述

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

![98.验证二叉搜索树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20210203144334501.png)

## 思路

<font color = "red">**要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。**</font>

有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。**

### 方法一：递归法

可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：

```java
ArrayList<Integer> result = new ArrayList<>();
public void traversal(TreeNode root) {
    if (root == null) return;
    traversal(root.left);
    result.add(root.val); // 将二叉搜索树转换为有序数组
    traversal(root.right);
}
```

然后只要比较一下，这个数组是否是有序的，**注意二叉搜索树中不能有重复元素**。

```java
traversal(root);
for (int i = 1; i < result.size(); i++) {
    // 注意要小于等于，搜索树里不能有相同元素
    if (result.get(i) <= result.get(i - 1)) return false;
}
return true;
```

整体代码如下：

```java
class Solution {

    ArrayList<Integer> result = new ArrayList<>();
    public void traversal(TreeNode root) {
        if (root == null) return;
        traversal(root.left);
        result.add(root.val); // 将二叉搜索树转换为有序数组
        traversal(root.right);
    }
    

    public boolean isValidBST(TreeNode root) {      
        traversal(root);
        for (int i = 1; i < result.size(); i++) {
            // 注意要小于等于，搜索树里不能有相同元素
            if (result.get(i) <= result.get(i - 1)) return false;
        }
        return true;
    }
};
```

以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。<font color="red">**<u>*因为递归的过程也就是将二叉搜索树种的节点从小到大的顺序排列，所以可以在排序的过程中比较节点的值是否符合排列的顺序。*</u>**</font>

这道题目比较容易陷入两个陷阱：

- 陷阱1

**不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**。

写出了类似这样的代码：

```JAVA
if (root.val > root.left.val && root.val < root.right.val) {
    return true;
} else {
    return false;
}
```

**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点**。所以以上代码的判断逻辑是错误的。

例如： [10,5,15,null,null,6,20] 这个case：

![二叉搜索树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20200812191501419.png)

节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！

- 陷阱2

**样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。**

此时可以初始化比较元素为longlong的最小值。

问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。





了解这些陷阱之后我们来看一下代码应该怎么写：

递归三部曲：

1. 确定递归函数，返回值以及参数

要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。

注意递归函数要有bool类型的返回值， 我们在[二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)](https://programmercarl.com/0112.路径总和.html)中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。

其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。

代码如下：

```C++
long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
bool isValidBST(TreeNode* root)
```

2. 确定终止条件

如果是空节点 是不是二叉搜索树呢？

是的，二叉搜索树也可以为空！

代码如下：

```cpp
if (root == NULL) return true;
```

3. 确定单层递归的逻辑

中序遍历，一直更新maxVal，一旦发现maxVal >= root->val，就返回false，注意元素相同时候也要返回false。

代码如下：

```cpp
bool left = isValidBST(root->left);         // 左

// 中序遍历，验证遍历的元素是不是从小到大
if (maxVal < root->val) maxVal = root->val; // 中
else return false;

bool right = isValidBST(root->right);       // 右
return left && right;
```

整体代码如下：

我不知道在java中那种数据类型可以对应c++中的long long类型所以就没有修改这里的c++代码为Java代码。

```c++
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
		//左
        bool left = isValidBST(root->left);
        
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        
        //右
        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

以上代码是因为后台数据有int最小值测试用例，所以都把maxVal改成了longlong最小值。

如果测试数据中有 longlong的最小值，怎么办？

不可能在初始化一个更小的值了吧。 建议避免 初始化最小值，如下方法取到最左面节点的数值来比较。<font color="red">**<u>*这种方法也就是在每次递归中都使用一个变量pre来保留上一次递归中的节点的值用来和本次递归中的节点的值比较大小，如果不符合排序的顺序就返回false，否则更新这个pre的值。*</u>**</font>

代码如下：

```java
class Solution {

    TreeNode pre = null; // 用来记录前一个节点
	public bool isValidBST(TreeNode root) {
        if (root == null) return true;

        //左
        bool left = isValidBST(root.left);
		
        //中
        //在第一次递归中才会初始化pre的值
        if (pre != null && pre.val >= root.val) return false;
        pre = root; // 记录前一个节点

        //右
        bool right = isValidBST(root.right);
        return left && right;
    }
};
```

### 方法二：迭代法

可以用迭代法模拟二叉树中序遍历，对前中后序迭代法生疏的同学可以看这两篇[二叉树：听说递归能做的，栈也能做！ (opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)，[二叉树：前中后序迭代方式统一写法(opens new window)](https://programmercarl.com/二叉树的统一迭代法.html)

迭代法中序遍历稍加改动就可以了，代码如下：

```java
public boolean isValidBST(TreeNode root) {
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    //记录前一个节点
    TreeNode pre = null;
    
    while(cur != null || !stack.isEmpty()){
        if(cur != null) {
            stack.push(cur);
            cur = cur.left;
        }else{
            cur = stack.pop();
            //判断迭代到的元素是否符合顺序，二叉搜索树中不能有重复的元素
            if(pre != null && pre.val >= cur.val) return false;
            //保留前一个访问节点
            pre = cur;
            
            cur = cur.right;
        }
    }
    return true;
}
```



# 3、二叉搜索树的最小绝对差

## 描述

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

示例：

![530二叉搜索树的最小绝对差](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20201014223400123.png)

提示：树中至少有 2 个节点。

## 思路

题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。

**注意是二叉搜索树**，二叉搜索树可是有序的。

遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。

### 方法一：递归

那么二叉搜索树采用中序遍历，其实就是一个有序数组。

**在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。**

最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。

代码如下：

```java
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
```

以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。

需要用一个pre节点记录一下cur节点的前一个节点。

如图：

![530.二叉搜索树的最小绝对差](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20210204153247458.png)

一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。

代码如下：

```cpp
class Solution {
private:
int result = INT_MAX;
TreeNode* pre = NULL;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur->left);   // 左
    if (pre != NULL){       // 中
        result = min(result, cur->val - pre->val);
    }
    pre = cur; // 记录前一个
    traversal(cur->right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

是不是看上去也并不复杂！

代码随想录中该思路的Java版：

```java
class Solution {
    TreeNode pre;// 记录上一个遍历的结点
    int result = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        if(root==null)return 0;
        traversal(root);
        return result;
    }
    public void traversal(TreeNode root){
        if(root==null)return;
        //左
        traversal(root.left);
        //中
        if(pre!=null){
            result = Math.min(result,root.val-pre.val);
        }
        pre = root;
        //右
        traversal(root.right);
    }
}
```

我的代码：

```JAVA
TreeNode prv = null;
int minDIF = Integer.MAX_VALUE;
public int getMinimumDifference(TreeNode root) {
    if(root == null) return -1;

    getMinimumDifference(root.left);	//左

    if(prv != null){					//中
        int temp = root.val-prv.val;
        //无用的操作，因为题目中已经给出限制，输入的是一个二叉搜索树，所以当前节点的值一定大于当前节点前一个节点的值，无需再判断
        if(temp <= 0)
            return -1;
        minDIF = temp > minDIF ? minDIF : temp;
    }
    prv = root;

    getMinimumDifference(root.right);	//右

    return minDIF;
}
```

### 方法二：迭代

看过这两篇[二叉树：听说递归能做的，栈也能做！ (opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)，[二叉树：前中后序迭代方式的写法就不能统一一下么？ (opens new window)](https://programmercarl.com/二叉树的统一迭代法.html)文章之后，不难写出两种中序遍历的迭代法。

```java
public int getMinimumDifference(TreeNode root) {
    if(root == null) return 0;
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;

    TreeNode pre = null;
    int minDIF = Integer.MAX_VALUE;

    while(cur != null || !stack.isEmpty()){
        if(cur != null){
            stack.push(cur);
            cur = cur.left;         //左
        }else{
            cur = stack.pop();

            if(pre != null)         //中
                minDIF = Math.min(minDIF, cur.val - pre.val);
            pre = cur;
            cur = cur.right;        //右
        }
    }
    return minDIF;
}
```



# 4、二叉树搜索树中的众数

## 描述

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

给定 BST [1,null,2,2],

![501. 二叉搜索树中的众数](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20201014221532206.png)

返回[2].

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内

## 思路

这道题目呢，递归法我从两个维度来讲。

首先如果不是二叉搜索树的话，应该怎么解题，是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。

### 方法一：递归法

#### 如果不是二叉搜索树

如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。

具体步骤如下：

1. 这个树都遍历了，用map统计频率

至于用前中后序那种遍历也不重要，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！

这里采用前序遍历，代码如下：

```cpp
//c++的代码我就不改动了，因为我不清楚c++中的数据结构
// map<int, int> key:元素，value:出现频率
void searchBST(TreeNode* cur, unordered_map<int, int>& map) { // 前序遍历
    if (cur == NULL) return ;
    map[cur->val]++; // 统计元素频率
    searchBST(cur->left, map);
    searchBST(cur->right, map);
    return ;
}
```

2. 把统计的出来的出现频率（即map中的value）排个序

有的同学可能可以想直接对map中的value排序，还真做不到，C++中如果使用std::map或者std::multimap可以对key排序，但不能对value排序。

所以要把map转化数组即vector，再进行排序，当然vector里面放的也是`pair<int, int>`类型的数据，第一个int为元素，第二个int为出现频率。

代码如下：

```cpp
//c++的代码我就不改动了，因为我不清楚c++中的数据结构
bool static cmp (const pair<int, int>& a, const pair<int, int>& b) {
    return a.second > b.second; // 按照频率从大到小排序
}

vector<pair<int, int>> vec(map.begin(), map.end());
sort(vec.begin(), vec.end(), cmp); // 给频率排个序
```

3. 取前面高频的元素

此时数组vector中已经是存放着按照频率排好序的pair，那么把前面高频的元素取出来就可以了。

代码如下：

```cpp
//c++的代码我就不改动了，因为我不清楚c++中的数据结构
result.push_back(vec[0].first);
for (int i = 1; i < vec.size(); i++) {
    // 取最高的放到result数组中
    if (vec[i].second == vec[0].second) result.push_back(vec[i].first);
    else break;
}
return result;
```

最后整合到一起的Java代码如下：

```java
/**
代码中用到了流的高级操作，但是我还没有来得及复习
*/
class Solution {
    public int[] findMode(FindModeInBinarySearchTree.TreeNode root) {
        //key：元素； value：元素出现的频率
        Map<Integer, Integer> map = new HashMap<>();
        //存放map中出现频率最高的key
        List<Integer> list = new ArrayList<>();

        if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();
        
        // 获得频率 Map
        searchBST(root, map);
        
        //将map中的键值对按照自定义的顺序（值从大到小）进行排序，（有关我对Comparator接口和Comparable接口的感悟，我记录在了思维导图：《Java核心技术卷Ⅰ 第六章 接口、lambda表达式与内部类.xmind》中），之后将按照我们指定的方式排序之后调用收集器将流中的元素收集到一个list中
        List<Map.Entry<Integer, Integer>> mapList = map.entrySet().stream()
            .sorted((c1, c2) -> c2.getValue().compareTo(c1.getValue()))
            .collect(Collectors.toList());
        //获取mapList列表中中第一个Map.Entry类型的键值对元素，获取对应的key值。
        list.add(mapList.get(0).getKey());
        
        // 把频率最高的但是还未加入list中的元素加入到list中，上面只是加入第一个频率最高的元素，可能还有相同频率的元素未加入到list中。
        for (int i = 1; i < mapList.size(); i++) {
            if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) {
                list.add(mapList.get(i).getKey());
            } else {
                break;
            }
        }
        return list.stream().mapToInt(Integer::intValue).toArray();
    }

    public void searchBST(FindModeInBinarySearchTree.TreeNode curr, Map<Integer, Integer> map) {
        if (curr == null) return;
        map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);
        searchBST(curr.left, map);
        searchBST(curr.right, map);
    }

}
```



**所以如果本题没有说是二叉搜索树的话，那么就按照上面的思路写！**

#### 是二叉搜索树

**既然是搜索树，它中序遍历就是有序的**。

如图：

![501.二叉搜索树中的众数1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20210204152758889.png)

中序遍历代码如下：

```java
void searchBST(TreeNode cur) {
    if (cur == NULL) return ;
    searchBST(cur.left);       // 左
    （处理节点）                 // 中
    searchBST(cur.right);      // 右
    return ;
}
```

遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。

关键是在有序数组上的话，好搞，在树上怎么搞呢？

这就考察对树的操作了。

在[二叉树：搜索树的最小绝对差 (opens new window)](https://programmercarl.com/0530.二叉搜索树的最小绝对差.html)中我们就使用了pre指针和cur指针的技巧，这次又用上了。

弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。

而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。

代码如下：

```java
if (pre == NULL) { // 第一个节点
    count = 1; // 频率为1
} else if (pre.val == cur.val) { // 与前一个节点数值相同
    count++;
} else { // 与前一个节点数值不同
    count = 1;
}
pre = cur; // 更新上一个节点
```

此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？

应该是<font color = "red">***先遍历一遍数组，找出最大频率（maxCount）***</font>，然后<font color = "red">***再重新遍历一遍数组把出现频率为maxCount的元素放进集合***</font>。（因为众数有多个）

这种方式<u>*遍历了两遍数组*</u>。

那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。

但这里其实只需要遍历一次就可以找到所有的众数。

那么如何只遍历一遍呢？

如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：

```java
if (count == maxCount) { // 如果和最大值相同，放进result中
    resList.add(cur.val);
}
```

是不是感觉这里有问题，resList怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。

所以下面要做如下操作：

频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为resList数组），因为结果集之前的元素都失效了。

```java
if (count > maxCount) { // 如果计数大于最大值
    maxCount = count;   // 更新最大频率
    resList.clear();     // 很关键的一步，不要忘记清空resList，之前resList里的元素都失效了
    resList.add(cur.val);
}
```

关于这种找众数的方式的分析图：
![image-20220925140206047](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\image-20220925140206047.png)



关键代码都讲完了，完整代码如下：（**只需要遍历一遍二叉搜索树，就求出了众数的集合**）

```java
class Solution {
    ArrayList<Integer> resList = new ArrayList<>();;
    int maxCount = 0;
    int count = 0;
    TreeNode pre = null;

    public int[] findMode(TreeNode root) {
        searchBST(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }

    public void searchBST(TreeNode root) {
        //在leetcode中在调用findMode1方法之前判断root!=null，而不在这里判断root!=null会报错，我感觉没有区别
        if (root == null) {
            return;
        }
        
        searchBST(root.left);	//左
								
        						//中
        int rootValue = root.val;
        // 计数
        if (pre == null) {		//第一个节点
            count = 1;
        } else if(rootValue == pre.val) {
            count++;			//与前一个节点值相同
        } else {
            count = 1;			//与前一个节点值不同
        }
        
        //如果这个条件满足的话意味着：在之前几次迭代中计算出来的
        //某个元素的频率(maxCount的值)并不一定是整棵树中的众数
        //而是这个新的频率最大的元素；这里这样判断会导致每次
        //迭代中都需要清空result并向其中添加元素，例如：当
        //二叉搜索树中所有的节点的val都是一样的，那么同一个元
        //素在不同的迭代中出现的频率都是不同的。
        if (count > maxCount) {
            //清空存放之前认为的最大频率的列表中的元素
            resList.clear();
            //添加有两种：
            // 1. 添加新值
            // 2. 重新添加resList被清空前唯一的元素 
            resList.add(rootValue);
            //更新maxCount的值
            maxCount = count;
        } else if (count == maxCount) {
            //找到频率最大的但是不同的元素，同样添加到结果中
            resList.add(rootValue);
        }
        //更新上一个节点
        pre = root;

        searchBST(root.right);	//右
    }
}
```



### 方法二：迭代法

只要把中序遍历转成迭代，中间节点的处理逻辑完全一样。

二叉树前中后序转迭代，传送门：

- [二叉树：前中后序迭代法(opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)
- [二叉树：前中后序统一风格的迭代方式(opens new window)](https://programmercarl.com/二叉树的统一迭代法.html)

下面我给出其中的一种中序遍历的迭代法，其中间处理逻辑一点都没有变（我从递归法直接粘过来的代码，连注释都没改，哈哈）

```java
class Solution {
    public int[] findMode(TreeNode root) {
        TreeNode pre = null;
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> result = new ArrayList<>();
        int maxCount = 0;
        int count = 0;
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur =cur.left;
            }else {
                cur = stack.pop();
                // 计数
                if (pre == null || cur.val != pre.val) {
                    count = 1;
                }else {
                    count++;
                }
                // 更新结果
                if (count > maxCount) {
                    maxCount = count;
                    result.clear();
                    result.add(cur.val);
                }else if (count == maxCount) {
                    result.add(cur.val);
                }
                pre = cur;
                cur = cur.right;
            }
        }
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```



## 总结

本题在递归法中，我给出了如果是普通二叉树，应该怎么求众数。

知道了普通二叉树的做法时候，我再进一步给出二叉搜索树又应该怎么求众数，这样鲜明的对比，相信会对二叉树又有更深层次的理解了。

在递归遍历二叉搜索树的过程中，我还介绍了一个统计最高出现频率元素集合的技巧， 要不然就要遍历两次二叉搜索树才能把这个最高出现频率元素的集合求出来。

**为什么没有这个技巧一定要遍历两次呢？ 因为要求的是集合，会有多个众数，如果规定只有一个众数，那么就遍历一次稳稳的了。**

最后我依然给出对应的迭代法，其实就是迭代法中序遍历的模板加上递归法中中间节点的处理逻辑，分分钟就可以写出来，中间逻辑的代码我都是从递归法中直接粘过来的。

**求二叉搜索树中的众数其实是一道简单题，但大家可以发现我写了这么一大篇幅的文章来讲解，主要是为了尽量从各个角度对本题进剖析，帮助大家更快更深入理解二叉树**。

> **需要强调的是 leetcode上的耗时统计是非常不准确的，看个大概就行，一样的代码耗时可以差百分之50以上**，所以leetcode的耗时统计别太当回事，知道理论上的效率优劣就行了。



# 5、二叉树的最近公共祖先

## 描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![236. 二叉树的最近公共祖先](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-4\20201016173414722.png)

示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

## 思路

遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。

那么二叉树如何可以自底向上查找呢？

回溯啊，二叉树回溯的过程就是从低到上。

<font color = "red">***后序遍历就是天然的回溯过程***</font>，最先处理的一定是叶子节点。

接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。

**有两种情况：**

1. **如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。**

2. **节点本身p(q)，它拥有一个子孙节点q(p)。**

针对情况一：使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现满足第一种情况的节点，就是最近公共节点了。

针对情况二：只需要找到一个节点是p或者q的时候，直接返回当前节点，无需继续递归子树。

如果接下来的遍历中找到了后继节点满足第一种情况则修改返回值为后继节点，否则，继续返回已找到的节点即可。

为什么满足第一种情况的节点一定是p或q的后继节点呢?大家可以仔细思考一下。





递归三部曲：

1. 确定递归函数返回值以及参数

需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。

但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。

代码如下：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)
```

2. 确定终止条件

如果找到了 节点p或者q，或者遇到空节点，就返回。

代码如下：

```java
if (root == q || root == p || root == NULL) return root;
```

3. 确定单层递归逻辑

值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。

我们在[二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)](https://programmercarl.com/0112.路径总和.html)中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！

如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：

```java
if (递归函数(root.left)) return ;

if (递归函数(root.right)) return ;
```

搜索整个树写法：

```java
left = 递归函数(root.left);
right = 递归函数(root.right);
left与right的逻辑处理;
```

