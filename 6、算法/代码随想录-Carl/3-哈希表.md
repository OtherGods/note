# 1、 哈希表理论基础

## 1.1 哈希表

首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。

> 哈希表是根据关键码的值而直接进行访问的数据结构。

这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。

哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：
![哈希表1](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\20210104234805168.png)

那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

例如要查询一个名字是否在这所学校里。

要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。

将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。

## 1.2 哈希函数

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

![哈希表2](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\2021010423484818.png)

如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

接下来**哈希碰撞**登场

## 1.3 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

![哈希表3](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\2021010423494884.png)

一般哈希碰撞有两种解决方法， 拉链法和线性探测法。

### 1.3.1 拉链法

![哈希表4](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\20210104235015226.png)

（数据规模是dataSize， 哈希表的大小为tableSize）

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。



### 1.3.2 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![哈希表5](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\20210104235109950.png)



## 1.4 常见的三种哈希结构

- 数组
- set（集合）
- map（映射）



# 2、有效的字母异位词

## 描述

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

**说明:** 你可以假设字符串只包含小写字母。

## 方法一：暴力

思路：，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。

暴力的方法这里就不做介绍了，直接看一下有没有更优的方式。

## 方法二：哈希表

思路：**数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。

需要定义一个多大的数组呢，定一个数组叫做record，大小为26 就可以了，初始化为0，因为字符a到字符z的ASCII也是26个连续的数值。

为了方便举例，判断一下字符串s= "aee", t = "eae"。

操作动画如下：
![242.有效的字母异位词](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\008eGmZEly1govxyg83bng30ds09ob29.gif)

定义一个数组叫做record用来记录字符串s里字符出现的次数。

需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。

```java
class Solution {
    public boolean isAnagram(String s, String t) {

        int[] record = new int[26];
        for (char c : s.toCharArray()) {
            record[c - 'a'] += 1;
        }
        for (char c : t.toCharArray()) {
            record[c - 'a'] -= 1;
        }
        for (int i : record) {
            if (i != 0) {
                return false;
            }
        }
        return true;
    }
}
```



# 3、两个数组的交集

> 如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费！

## 描述

题意：给定两个数组，编写一个函数来计算它们的交集。

![349. 两个数组的交集](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\20200818193523911.png)

**说明：** 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。

数值范围：

- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000



## 思路

这道题目，主要要学会使用一种哈希数据结构：set，这个数据结构可以解决很多类似的问题。

注意题目特意说明：**输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序**

这道题用暴力的解法时间复杂度是O(n^2)，那来看看使用哈希法进一步优化。

但是要注意，**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**

而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。

**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

此时就要使用另一种结构体了，set ；

那有同学可能问了，遇到哈希问题我直接都用set不就得了，用什么数组啊。

直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        //遍历数组1
        for (int i : nums1) {
            set1.add(i);
        }
        //遍历数组2的过程中判断哈希表中是否存在该元素
        for (int i : nums2) {
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }
        //将结果几何转为数组
        return resSet.stream().mapToInt(x -> x).toArray();
    }
}
```



- 时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 O(min(m,n)) 的时间，因此总时间复杂度是 O(m+n)。

- 空间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于两个集合。




# 4、快乐数

## 描述

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

**示例：**

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

## 思路

题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现，这对解题很重要！**

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。**

所以这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。

判断sum是否重复出现就可以使用set。

**还有一个难点就是求和的过程，如果对取数值各个位上的单数操作不熟悉的话，做这道题也会比较艰难。**



```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```

# 5、两数之和

## 描述

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]



## 思路

首先我在强调一下 **什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

本题呢，我就需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。

那么我们就应该想到使用哈希法了。

因为本地，我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，**需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适**。

再来看一下使用数组和set来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断key是否存在而且还要记录key的下标位置，因为要返回key的下标。所以set 也不能用。

此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

所以 map中的存储结构为 {key：数据元素，value：数组元素对应的下表}。

在遍历数组的时候，只需要向map去查询是否有和目前遍历元素比配的数值，如果有，就找到的匹配对，并同时把map中相关的键值对 对 删除，因为题目中说同一个元素不能被使用第二次，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。

![过程一](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\20220711202638.png)

![过程二](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\20220711202708.png)

本题其实有四个重点：

- 为什么会想到用哈希表
- 哈希表为什么用map
- 本题map是用来存什么的
- map中的key和value用来存什么的

```java
/**
这个算法是专门针对这个额问题来说的，没有什么技巧性
*/
public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    if(nums == null || nums.length == 0){
        return res;
    }
    Map<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < nums.length; i++){
        int temp = target - nums[i];
        if(map.containsKey(temp)){
            res[1] = i;
            res[0] = map.get(temp);
        }
        map.put(nums[i], i);
    }
    return res;
}
```



# 6、四数相加Ⅱ

## 描述

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

**例如:**

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:

2

**解释:**

两个元组如下:

1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0



## 思路

**本题是使用哈希法的经典题目，而[0015.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)，[0018.四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)并不合适使用哈希法**，因为三数之和和四数之和这两道题目使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。

**而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于题目18. 四数之和，题目15.三数之和，还是简单了不少！**

如果本题想难度升级：就是给出一个数组（而不是四个数组），在这里找出四个元素相加等于0，答案中不可以包含重复的四元组，大家可以思考一下，后续的文章我也会讲到的。

~~本题解题步骤：~~

1. ~~首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。~~
2. ~~遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。~~
3. ~~定义int变量count，用来统计 a+b+c+d = 0 出现的次数。~~
4. ~~在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。~~
5. ~~最后返回统计值 count 就可以了~~

上面这个思路是代码随想录中的思路，但是这个思路没有说明为什么会有这样的思路，这样的思路出现的很突兀，我在leetcode中找到了一个有完整思路的分析：

> - 一采用分为两组，HashMap 存一组，另一组和 HashMap 进行比对。
> - 这样的话情况就可以分为三种：
>   - HashMap 存一个数组，如 A。然后计算三个数组之和，如 BCD。时间复杂度为：O(n)+O(n^3)，得到 O(n^3).
>   - HashMap 存三个数组之和，如 ABC。然后计算一个数组，如 D。时间复杂度为：O(n^3)+O(n)，得到 O(n^3).
>   - HashMap存两个数组之和，如AB。然后计算两个数组之和，如 CD。时间复杂度为：O(n^2)+O(n^2)，得到 O(n^2).
> - 根据第二点我们可以得出要存两个数组算两个数组。
> - 我们以存 AB 两数组之和为例。首先求出 A 和 B 任意两数之和 sumAB，以 sumAB 为 key，sumAB 出现的次数为 value，存入 hashmap 中。
>   然后计算 C 和 D 中任意两数之和的相反数 sumCD，在 hashmap 中查找是否存在 key 为 sumCD。
>   算法时间复杂度为 O(n2)。
>
> 作者：guo-sheng-fei
> 链接：https://leetcode.cn/problems/4sum-ii/solution/chao-ji-rong-yi-li-jie-de-fang-fa-si-shu-xiang-jia/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        Map<Integer, Integer> map = new HashMap<>();
        //Map<Integer, Integer> map = new HashMap<>();
        int res = 0;
        //统计两个数组中的元素值和，同时统计出现的次数，放入map中
        for(int i = 0;i<A.length;i++){
            for(int j= 0;j<B.length;j++){
                int sumAB = A[i]+B[j];
                if(map.containsKey(sumAB)) map.put(sumAB,map.get(sumAB)+1);
                else map.put(sumAB,1);
            }
        }
		//统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for(int i = 0;i<C.length;i++){
            for(int j = 0;j<D.length;j++){
                int sumCD = -(C[i]+D[j]);
                if(map.containsKey(sumCD)) res += map.get(sumCD);
            }
        }
        return res;
    }
}

作者：guo-sheng-fei
链接：https://leetcode.cn/problems/4sum-ii/solution/chao-ji-rong-yi-li-jie-de-fang-fa-si-shu-xiang-jia/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 7、赎金信

## 描述

给定一个赎金信（ransom）字符串和一个杂志（magazine）字符串，判断第一个字符串ransom能不能由于第二个字符串magazine里面的字符构成，如果可以构成，返回teur；否则返回false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

你可以假设两个字符串均只含有小写字母。

canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true

## 思路

这道题目和[242.有效的字母异位词 (opens new window)](https://programmercarl.com/0242.有效的字母异位词.html)很像，[242.有效的字母异位词 (opens new window)](https://programmercarl.com/0242.有效的字母异位词.html)相当于求 字符串a 和 字符串b 是否可以相互组成 ，而这道题目是求 字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。

本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。

- 第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思” 这里*说明杂志里面的字母不可重复使用。*
- 第二点 “你可以假设两个字符串均只含有小写字母。” *说明只有小写字母*，这一点很重要

### 方式一：暴力

略

### 方式二：哈希表

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        // 定义一个哈希映射数组
        int[] record = new int[26];

        // 遍历
        for(char c : magazine.toCharArray()){
            record[c - 'a'] += 1;
        }

        for(char c : ransomNote.toCharArray()){
            record[c - 'a'] -= 1;
        }
        
        // 如果数组中存在负数，说明ransomNote字符串中存在magazine中没有的字符
        for(int i : record){
            if(i < 0){
                return false;
            }
        }

        return true;
    }
}
```



# 8、三数之和

## 描述

给你一个包含n个中整数的数组nums，判断nums中是否存在三个元素a、b、c，使得a+b+c = 0 ? 请找出所有满足条件且不重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]



## 思路

> 这段描述是对于代码随想录中该题的思路的介绍，在代码随想录中表达的不是很清楚，但是这两种表当方式介绍的思路都是一致的
>
> - 标签：数组遍历
>
> - 首先对数组进行排序，排序后固定一个数nums[i]，再使用左右指针指向nums[i]后面的数组的两端，数字分别为nums[L]和nums[R]，计算三个数的和sum判断是否满足为 0，满足则添加进结果集
>
> - 如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环
>
> - 如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过
>
> - 当 sum == 0时，如果nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++
>
> - 当 sum == 0 时，如果nums[R] == nums[R-1] 则会导致结果重复，应该跳过，R--
>
> - 时间复杂度：O(n^2)，n 为数组长度
>
>   作者：guanpengchn
>   链接：https://leetcode.cn/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/
>   来源：力扣（LeetCode）
>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

动图描述上面的过程：如下动图中left指针就是上面思路中说的L指针，right指针就是上面思路中说到的R指针

![15.三数之和](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\15.三数之和.gif)



### 有关代码中去重的逻辑的分析

去重主要考考虑三个数的去重，a、b、c对应的就是nums[i]、nums[left]、nums[right]。

1. a的去重
   a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。
   但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。

   有同学可能想，这不都一样吗。

   其实不一样！

   都是和 nums[i]进行比较，是比较它的前一个，还是比较他的后一个。
   如果我们的写法是这样的：

   ```java
   if (nums[i] == nums[i + 1]) { // 去重操作
       continue;
   }
   ```

   那么就会把三元组中出现重复元素的情况直接pass掉了。例如{-1，-1，2}这组数据，当遍历到第一个-1的时候，判断下一个也是-1，那这组数据就直pass了，但是这个三元组可能没有重复，导致漏过。

   所以这里是有两个重复的维度。

   那么应该这么写：

   ```java
   if (i > 0 && nums[i] == nums[i - 1]) {
       continue;
   }
   ```

   这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。

   这是一个非常细节的思考过程。

   
2. b、c的去重很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）

   ```java
   while (right > left) {
       if (nums[i] + nums[left] + nums[right] > 0) {
           right--;
           // 去重 right
           while (left < right && nums[right] == nums[right + 1]) right--;
       } else if (nums[i] + nums[left] + nums[right] < 0) {
           left++;
           // 去重 left
           while (left < right && nums[left] == nums[left - 1]) left++;
       } else {
       }
   }
   ```

   但细想一下，这种去重其实对提升程序运行效率是没有帮助的，仅仅是加速代码的执行，并没有实际完成去重，实际的去重操作是在a+b+c = 0条件中进行的。
   

   拿right去重为例，即使不加这个去重逻辑，依然根据 `while (right > left)` 和 `if (nums[i] + nums[left] + nums[right] > 0)` 去完成right-- 的操作。

   多加了 `while (left < right && nums[right] == nums[right + 1]) right--;` 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。

   最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。

   所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。

### 方式一：排序+双指针法

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        //对数组进行排序
        Arrays.sort(nums);
		//枚举a
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                return result;
            }
            //需要和上一次枚举的值不同
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
			//left指针指向的位置是b值所在的初始位置
            int left = i + 1;
            //right指针初始值始终为数组的最后一个元素
            int right = nums.length - 1;
            //始终保证right指针指向left指针的右侧
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                //由于数组排序，所以数组右侧的值比较大，可以移动right指针来减少sum的值，同理可以移动left指针的位置来增加sum的值，如果sum的值为0，那么就可以将该值保存到list中
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    //给b和c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
					
                    //照常移动指针的位置
                    right--; 
                    left++;
                }
            }
        }
        return result;
    }
}
```

- 时间复杂度：O(N^2)，其中N是数组nums的长度
- 空间复杂度：O(log N)。（没说怎么算出来的）

# 9、四数之和

## 描述

题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

**注意：**

答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

## 思路

四数之和，和[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)是一个思路，都是使用双指针法, 基本解法就是在[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)的基础上再套一层for循环。

但是有一些细节需要注意，例如： 不要判断`nums[k] > target` 就返回了，三数之和 可以通过 `nums[i] > 0` 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是`[-4, -3, -2, -1]`，`target`是`-10`，不能因为`-4 > -10`而跳过。但是我们依旧可以去做剪枝，逻辑变成`nums[i] > target && (nums[i] >=0 || target >= 0)`就可以了。

[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。

四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n^2^)，四数之和的时间复杂度是O(n^3^) 。

那么一样的道理，五数之和、六数之和等等都采用这种解法。

对于[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)双指针法就是将原本暴力O(n^3^)的解法，降为O(n^2^)的解法，四数之和的双指针解法就是将原本暴力O(n^4^)，降为O(n^3^)的解法。

之前我们讲过哈希表的经典题目：[454.四数相加II (opens new window)](https://programmercarl.com/0454.四数相加II.html)，相对于本题简单很多，因为本题是要求在一个集合中找出四个数相加等于target，同时四元组不能重复。

而[454.四数相加II (opens new window)](https://programmercarl.com/0454.四数相加II.html)是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况，所以相对于本题还是简单了不少！

我们来回顾一下，几道题目使用了双指针法。

双指针法将时间复杂度：O(n^2^)的解法优化为 O(n)的解法。也就是降一个数量级，题目如下：

- [27.移除元素(opens new window)](https://programmercarl.com/0027.移除元素.html)
- [15.三数之和(opens new window)](https://programmercarl.com/0015.三数之和.html)
- [18.四数之和(opens new window)](https://programmercarl.com/0018.四数之和.html)

链表相关双指针题目：

- [206.反转链表(opens new window)](https://programmercarl.com/0206.翻转链表.html)
- [19.删除链表的倒数第N个节点(opens new window)](https://programmercarl.com/0019.删除链表的倒数第N个节点.html)
- [面试题 02.07. 链表相交(opens new window)](https://programmercarl.com/面试题02.07.链表相交.html)
- [142题.环形链表II(opens new window)](https://programmercarl.com/0142.环形链表II.html)

双指针法在字符串题目中还有很多应用，后面还会介绍到。



```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        //对nums数组进行排序
        Arrays.sort(nums);

        //存放找到的四元组对应的列表
        ArrayList<List<Integer>> lists = new ArrayList<>();
        //由于数组是有序的，所以在
        for(int a = 0;a < nums.length;a++){

            //剪枝操作
            //不能因为nums[a]>target就直接跳出这次外循环了，因为当四个数字都是负数的时候
            //会导致四个数值和等于target，但是nums[a]>target；要解决这样的问题，需要在
            //判断num[a]>target的时候同时判断：
            //      1、nums[a]是否大于0，因为a指针始终指向四个数字中最小的一个，所以只要它大于0，就没有那种情况发生
            if(nums[a] > target && nums[a] > 0) break;

            //去重操作
            if (a > 0 && nums[a - 1] == nums[a]) {
                continue;
            }
            //b指针指向的位置对应的索引在区间[1,nums.length-3]之间，因为nums.length-2是c指针最后的位
            //置，nums.length-1是d指针最后的位置
            for(int b = a+1;b < nums.length-2;b++)
            {

                // 对nums[i]去重,判断b > a + 1是为了防止[2,2,2,2,2,2]这样的数组
                if (b > a + 1 && nums[b] == nums[b - 1]) {
                    continue;
                }

                //双指针对应的索引值,c相当于左指针,d相当于右指针
                //右指针始终指向数组的最后一位
                int c = b+1;
                int d = nums.length-1;
                //减枝操作
                //当四元组中最小的元素大于0，并且四元组中某个元素大于target的时候就要退出，因为值一定大于target
                if((nums[b] > target && nums[a] > 0) || (nums[c] > target && nums[a] > 0) || nums[d] > target && nums[a] > 0) break;

                //在一次外循环中已经把a的值固定下来了，接着判断b、c、d分别是最小值和最大值的时候与target的关系，
                //根据这个关系判断是否需要剪枝
                if(nums[a] + nums[b] + nums[b+1] + nums[b+2] > target) continue;
                //在这种条件下无意义的判断
                // if(nums[a] + nums[d-2] + nums[d-1] + nums[d] < target) continue;

                //在最内部循环中不断移动c和d的指针，并判断a、b、c、d四个指针指向的元素的和与target的关系
                //并且移动c、d指针
                while(c < d)
                {
                    int sum = nums[a] + nums[b] + nums[c] + nums[d];
                    if(sum > target) d--;
                    else if(sum < target) c++;
                    else{
                        ArrayList<Integer> integers = new ArrayList<>();
                        integers.add(nums[a]);
                        integers.add(nums[b]);
                        integers.add(nums[c]);
                        integers.add(nums[d]);
                        lists.add(integers);

                        //判断下一个循环中c和d指向的位置的元素是否和这个循环中对应位置的元素是否重复，如果重复则跳过该元素
                        while(c < d && nums[c] == nums[c + 1]) c++;
                        while(c < d && nums[d] == nums[d - 1]) d--;
                        //用于给下一个循环中的c和d去重，首先要把c和d的指针移动要下一次循环中要用到的位置
                        c++;
                        d--;
                    }

                }
            }
        }
        return lists;

    }
}
```

- 时间复杂度：O(n^3^)其中 nn 是数组的长度。排序的时间复杂度是 O(nlogn)，枚举四元组的时间复杂度是 O(n^3)，因此总时间复杂度为 O(n^3^+nlog n)=O(n^3^ )。
- 空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度主要取决于排序额外使用的空间。此外排序修改了输入数组 nums，实际情况中不一定允许，因此也可以看成使用了一个额外的数组存储了数组nums 的副本并排序，空间复杂度为 O(n)。


# 10、关于三元组和四元组查找元素的思路

![image-20220828204221357](D:\Tyora\AssociatedPicturesInTheArticles\3-哈希表\image-20220828204221357.png)

三元组和四元组在查找时使用的暴力枚举法是通过使用三个或四个for循环来查找，最先查找到的是第三、四元素，因为最先运行完的是最内部的循环，在这个循环中查找的就是最后一个元素，这种查找方式就像上图中画的一样，先固定两、三个元素，查找最后一个元素；当最后一个循环执行结束之后会进行倒数第二个元素的查找，在查找倒数第二个元素的时候也会进行第三、四个元素的查找；查找倒数第三个元素的时候也是同样。

而使用的双指针方式进行查找得时候，最后两个元素是使用两个指针在指定范围内进行查找，调整指针的方式是根据target和这两个指针指向的元素的和的大小来进行移动；当两个指针移动到left>=right的时候就会进行倒数第三个元素的查找，在查找倒数第三个元素时也会进行第三、四个元素的查找；当倒数第三个元素查找完毕之后就会进行倒数第四个元素的查找，查找的方式和倒数第三个元素的查找时也是同样的。



# 11、总结

**一般来说哈希表都是用来快速判断一个元素是否出现集合里**。

对于哈希表，要知道**哈希函数**和**哈希碰撞**在哈希表中的作用.

哈希函数是把传入的key映射到符号表的索引上。

哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。

接下来是常见的三种哈希结构：

- 数组
- set（集合）
- map（映射）

# 哈希表经典题目

## 数组作为哈希表

一些应用场景就是为数组量身定做的。

在[242.有效的字母异位词 (opens new window)](https://programmercarl.com/0242.有效的字母异位词.html)中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！

这道题目包含小写字母，那么使用数组来做哈希最合适不过。

在[383.赎金信 (opens new window)](https://programmercarl.com/0383.赎金信.html)中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！

本题和[242.有效的字母异位词 (opens new window)](https://programmercarl.com/0242.有效的字母异位词.html)很像，[242.有效的字母异位词 (opens new window)](https://programmercarl.com/0242.有效的字母异位词.html)是求 字符串a 和 字符串b 是否可以相互组成，在[383.赎金信 (opens new window)](https://programmercarl.com/0383.赎金信.html)中是求字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。

一些同学可能想，用数组干啥，都用map不就完事了。

**上面两道题目用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！**

## set作为哈希表

在[349. 两个数组的交集 (opens new window)](https://programmercarl.com/0349.两个数组的交集.html)中我们给出了什么时候用数组就不行了，需要用set。

这道题目没有限制数值的大小【数组的题目中有要求数组中的元素都是小写字母，这样就限制了数组的大小】，就无法使用数组来做哈希表了。

**主要因为如下两点：**

- 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
- 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

所以此时一样的做映射的话，就可以使用set了。

关于set，C++ 给提供了如下三种可用的数据结构：（详情请看[关于哈希表，你该了解这些！ (opens new window)](https://programmercarl.com/哈希表理论基础.html)）

- std::set
- std::multiset
- std::unordered_set

std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 使用unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

在[202.快乐数 (opens new window)](https://programmercarl.com/0202.快乐数.html)中，我们再次使用了unordered_set来判断一个数是否重复出现过。

## map作为哈希表

在[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)中map正式登场。

来说一说：使用数组和set来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断key是否存在而且还要记录key的下标位置，因为要返回key的下标。所以set 也不能用。

map是一种`<key, value>`的结构，本题可以用key保存数值，用value在保存数值所在的下标。所以使用map最为合适。

C++提供如下三种map：：（详情请看[关于哈希表，你该了解这些！ (opens new window)](https://programmercarl.com/哈希表理论基础.html)）

- std::map
- std::multimap
- std::unordered_map

std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。

同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），[1.两数之和 (opens new window)](https://programmercarl.com/0001.两数之和.html)中并不需要key有序，选择std::unordered_map 效率更高！

在[454.四数相加 (opens new window)](https://programmercarl.com/0454.四数相加II.html)中我们提到了其实需要哈希的地方都能找到map的身影。

本题咋眼一看好像和[18. 四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)，[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)差不多，其实差很多！

**关键差别是本题为四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑重复问题，而[18. 四数之和 (opens new window)](https://programmercarl.com/0018.四数之和.html)，[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)是一个数组（集合）里找到和为0的组合，可就难很多了！**

用哈希法解决了两数之和，很多同学会感觉用哈希法也可以解决三数之和，四数之和。

其实是可以解决，但是非常麻烦，需要去重导致代码效率很低。

在[15.三数之和 (opens new window)](https://programmercarl.com/0015.三数之和.html)中我给出了哈希法和双指针两个解法，大家就可以体会到，使用哈希法还是比较麻烦的。

所以18. 四数之和，15.三数之和都推荐使用双指针法！





# 12、补充：排列组合和二项式定理

## 1、乘法原理与加法原理

### 1.1乘法原理

如果完成一件事需要n个步骤，第一步有m~1~ 种不同的方法，第2步有 m~2~ 种不同的方法， ......，第n步有 m~n~种不同的方法，那么完成这件事共有 N=m~1~∗m~2~∗......∗m~n~ 种不同的方法

举个具体的例子

比如你有10件不同的衬衣，8条不同的裤子，5双不同的鞋子，那么你每天出门的穿着，衬衣有10种选择，裤子有8种选择，鞋子有5种选择，总共就有10*8*5=400种搭配的可能

衬衣、裤子、鞋子三样东西的选择之间都是相互独立的，先选哪个后选哪个对之后的选择没有影响

这就是乘法原理，在各种涉及到“搭配”的事件中都会遇到

### 1.2、加法原理

如果完成一件事有n类办法，在第1类办法中有 m~1~ 种不同的方法，在第2类办法中有 m~2~ 种不同的方法，......，在第n类办法中有 m~n~ 种不同的方法，那么完成这件事总共有： m~1~+m~2~+......+m~n~ 种方法

这叫做加法原理

加法原理其实就是把本来就有的全部n种（n=m1+m2+......+mn种）方法，先按照某些共性或者特点进行了归类，归为m1、m2......mn

在排列组合中，这种“归类”的思想非常重要，可以使题目大大的简化，更加有条理

举个具体的例子：

从北京去上海，可以坐飞机，假设有10趟航班；可以坐高铁，假设有20班高铁；可以坐大巴，假设有30班大巴；也可以自驾，只能自己开车。

因此，从北京去上海，总共有10+20+30+1=61种方法

这就是加法原理，本质就是在大类中再细分小类

### 1.3、小结

乘法原理和加法原理是排列组合以及后面要学的概率统计最为基本、最为重要的原理，必须要非常的熟练才行。

乘法原理和加法原理本身非常简单，在生活中经常会遇到，但是现在要专门地把它们当做数学问题来看待，并加以区分和明确。

不妨留意下生活中遇到的各种用到乘法原理和加法原理的事情，比如每天的穿衣（衣服裤子鞋子）、聚餐点菜（主食、荤菜、素菜、汤、饮料）用到乘法原理，假期旅游目的地的选择（省内、国内省外、国外）、课外书的购买（小说、漫画、杂志、科普等等）用到加法原理。

## 2、排列

从n个不同元素中取出m个元素的所有排列的个数叫作从n个不同元素中取出m个元素的排列数。

这句话有些拗口，通俗说来，就是总共有n个元素 ，现在从里面挑出m个来，对这m个进行排队。这种先“从n里面挑出m个”，再“给这m个排队”，最后能产生的可能的不同的排队的种类数，叫做“从n个不同元素中取出m个元素的排列数”。

本质上排列数就是排队的种类的数量，或者可能性的数量。根据常识可以得知：m≤n

排列就是排队的意思，给一堆不同的元素，从中选几个进行排队。

比如班级同学按顺序排队，各科家庭作业挨个完成，排出你心目中的十大科学家/歌手/球星等等。

排列研究的就是给他们进行排队的方法。

### 2.1 全排列

就以给同学们排队为例，从前往后排纵队。

**1人队**

没什么好排的，1人只有1种排法，把ta放那儿就行

**2人队**

假设有A和B两人，给他们进行排队

排法1：AB

排法2：BA

**3人队**

假设有ABC三人，给他们进行排队

好像有些乱，让我们先确定第一位：

A排第一时，还剩B和C，有BC和CB两种排法，也就是ABC和ACB两种排法

B排第一时，还剩A和C，有AC和CA两种排法，也就是BAC和BCA两种排法

C排第一时，还剩A和B，有AB和BA两种排法，也就是CAB和CBA两种排法

总共就是2+2+2=3*2=6种排法

**n人队**

用这种“先确定第一位，再给剩下的人进行排队”的方法（数学归纳法的思想）

假设给n人进行排队共有 a~n~ 种方法，那么给n+1人排队就有 (n+1)∗a~n~ 种方法（相当于第n+1个人在这a~n~种已经排好的队列中找位置，而一个n人的队列有n+1个位置可以站人构成一个新的队列，一共有a~n~个这种队列，所以是(n+1)*a~n~）

又由于 a1=1 ，所以

a2=2∗a1=2∗1【相当于第2个人在  已经排好队列并且该队列中只有一个人的队列  中找位置，这样的位置有2个】

a3=3∗a2=3∗2∗1【相当于第3个人在  已经排好队列并且该队列中只有两个人的队列  中找位置，这样的位置有3个】

a4=4∗a3=4∗3∗2∗1【相当于第4个人在  已经排好队列并且该队列中只有三个人的队列  中找位置，这样的位置有4个】

......

an=n∗(n−1)∗(n−2)∗.....∗2∗1【同上】



> 插入概念：阶乘
> 这里我们要学一个新的运算符号：阶乘
> 阶乘只能对**正整数**使用，它表示从这个数字依次乘以它减一、它减二、减三，一直到一
> 阶乘的记法就是在正整数后面加上惊叹号“！”
> 比如
> $$
> 5!=5*4*3*2*1=120
> $$
>
> $$
> 10!=10*9*8*7*6*5*4*3*2*1=3628800
> $$
>
> $$
> n!=n*(n-1)*(n-2)*(n-3)......2*1
> $$
>
> 
>
> 特别的，规定0!=1，原因与指数中规定 a~0~=1 类似



给n人进行排队，排队的可能性就是n!，这也叫做对n人进行全排列

这种排列是没有任何专门要求的，没有要求成绩好的排前面，也没有要求个子高的排后面，谁都可以站在任何地方，

除了人，给其他的东西也可以进行排列，是一样的

### 2.2 排列

上面的全排列是对全部n人（或物）进行排列

如果是从n人里选m个进行排列，这种更为一般的排列有多少排法呢？

#### 2.2.1 排列的标记

从n个元素中取m个进行排列，记作 Anm （沪教版用Pnm，二者含义完全相同，A代表单词array，P代表单词permutation，请根据当地教材选用A或P）

这里要注意n和m的位置，n在下面，m在上面，可以类比真分数的分母与分子

#### 2.2.2 举例

现在我们有ABCDEFG七人

**7选1排队**

假设从中选1人进行排队，只有1种排法，从中任选一位就行

**7选2排队**

假设从中选2人进行排队，就有......该怎么排呢？

还是先确定第一位，有7种可能：A或B或C或D或E或F或G

再确定第二位：

当第一位是A时，第二位有6种可能：B或C或D或E或F或G

当第一位是B时，第二位有6种可能：A或C或D或E或F或G

当第一位是C时，第二位有6种可能：A或B或D或E或F或G

当第一位是D时，第二位有6种可能：A或B或C或E或F或G

当第一位是E时，第二位有6种可能：A或B或C或D或F或G

当第一位是F时，第二位有6种可能：A或B或C或D或E或G

当第一位是G时，第二位有6种可能：A或B或C或D或E或F

总共有7+7+7+7+7+7=7*6种可能

**7选3排队**

方法同上，先确定第一位，有7种可能：A或B或C或D或E或F或G

再确定第二位：

当第一位是A时，第二位有6种可能：B或C或D或E或F或G

当第一第二位是AB时，第三位有5种可能：C或D或E或F或G

当第一第二位是AC时，第三位有5种可能：B或D或E或F或G

当第一第二位是AD时，第三位有5种可能：B或C或E或F或G

当第一第二位是AE时，第三位有5种可能：B或C或D或F或G

当第一第二位是AF时，第三位有5种可能：B或C或D或E或G

当第一第二位是AG时，第三位有5种可能：B或C或D或E或F

也就是当第一位是A是，总共有5+5+5+5+5+5=6*5=30种可能

当第一位分别是B、C、D、E、F、G时，也分别有6*5=30种可能

因此总共就是7*6*5=210种可能

使用这种方法，

7选4的排队就有7*6*5*4种可能

7选5的排队就有7*6*5*4*3种可能

7选6的排队就有7*6*5*4*3*2种可能

7选7的排队就有7*6*5*4*3*2*1种可能，这已经是对7人进行全排列了

#### 2.2.3 n人中选m人进行排队



现在我们跳出具体的数字“7”，从n人中选m个进行排列

（1）先确定排第一的人，有n种可能

（2）再来确定排第二的人，由于第一已经用掉1人，现在还剩下n-1人。

也就是在排好第一的前提下，第二有n-1种可能

（3）再来确定排第三的人，由于第一、第二分别用掉一人，现在还剩下n-2人。

也就是在排好第一和第二的前提下，第三有n-2种可能

......

（m）依次类推，当前面的m-1位都确定时，还剩下n-(m-1)人。

也就是在排好第一到第m-1的前提下，第m位有n-(m-1)种可能



现在根据开头学的乘法原理，从n人里选m人进行排列，总共有
$$
n*(n-1)*(n-2)*...*[n-(m-2)]*[n-(m-1)]
$$
种排法



把n-(m-1)的括号去掉再变号，就是：
$$
n*(n-1)*(n-2)*...*(n-m+2)*(n-m+1)
$$
这里总共有m个数相乘

记作 n∗(n−1)∗(n−2)∗...∗(n−m+2)∗(n−m+1)=A~n~^m^

也就本章开头讲到 A~n~^m^的定义：从n个元素中取m个进行排列

### 2.3 A~n~^m^的几个性值

性质1：A~n~^m^=n!/(n−m)!

性质2： A~n+1~^n+1^=(n+1)∗A~n~^n^

性质3： A~n~^n-1^=A~n~^n^=n!

### 2.4 小结

“排列”的关键就在于每个位置都是**独一无二**的



## 3、组合

从n个不同元素中取出m个元素的所有组合的个数，叫作从n个不同元素中取出m个元素的组合数。

这句话依然拗口，通俗来讲，就是总共有n个不同的元素，现在要从里面选出m个来。这种“从n个里面选出m个来”总共的可能数，就是“从n个不同元素中取出m个元素的组合数”。

组合数就是挑东西的可能性的个数。根据常识可以得知，m≤n。



组合就是“挑选”的意思，从一堆东西里挑出几个，看有几种不同的挑法。

比如去餐馆吃饭，从菜单上各种式样的菜品中选几个。

“组合”只要把元素挑出来就行，不涉及到“排序”，感觉上似乎比“排列”要简单

但其实组合比排列要稍微复杂一些，因为排列是有序的，而组合是无序的，虽然在实际生活中排顺序比较麻烦，但是在数学中有序比无序（混乱）要容易处理得多。

### 3.1 点菜

就以点菜为例，来研究组合

现在我们去餐馆吃饭，假设餐馆里有5种菜，ABCDE。



**5选1**

只点1个菜。

太简单了吧，5种选择，A或B或C或D或E



**5选2**

点2个菜。

这个有些复杂了，有两种思路



思路一：挨个决定每个菜是否点

（1）点A，那么另一个菜有4种可能：B或C或D或E

（2）不点A，并且点B，那么另一个菜有3种可能：C或D或E

（3）不点A、不点B，并且点C，那么另一个菜有2种可能：D或E

（4）不点A、不点B、不点C，并且点D，那么另一个菜有1种可能：E

综上，总共有4+3+2+1=10种可能



思路二：先给点的菜排个序，然后把重复的组合去掉

第一步

根据排列2.2.3章节中的原理

（1）第一道菜有5种可能：A或B或C或D或E

（2）第二道菜有4种可能：就是除去已被选为第一道菜剩下的4个中的某个

因此总共有5*4=20种排列

第二步：

排列AB：第一道菜是A、第二道菜是B

排列BA：第一道菜是B、第二道菜是A

以上是两种排列，但是组合是不分先后的，AB和BA没区别

此外还有其他很多这种重复的，比如AC和CA、DE和ED

每有一个XY的排列，必还有一个YX的排列

第三步：

因此组合的种类是排列种类的二分之一，因此是20/2=10种



### 3.2 分析

现在来分析这两种思路，这两种思路都是走得通的

思路一需要把每种组合都列出来，是非常麻烦的，5选2还比较简单，如果数字再大，这种方法用起来会非常非常麻烦

思路二是用排列的方法，饶了一圈绕回来，虽然思路上绕了，但是不用一一罗列，并且排列是有公式可套的，因此用起来要简便的多

下面看个稍微复杂些的情况：



5选3

还是ABCDE五种菜，点3样

思路一：挨个确定菜品点不点：

（1）点A，剩下BCDE四选二：

点A，并且点B，第三样有3种可能：C或D或E

点A、不点B、并且点C，第三样有2种可能：D或E

点A、不点B、不点C、并且点D。第三样有1种可能：E

（2）不点A，并且点B，剩下CDE三选二

不点A、点B、并且点C，第三样有2种可能：D或E

不点A、点B、不点C、并且点D，第三样有1种可能：E

（3）不点A、不点B，只有一种可能：点CDE

因此总共有(3+2+1)+(2+1)+1=10种可能



思路二：先排列，再除去重复的排列：

第一步：

5选3就是 A~5~^3^=5∗4∗3=60

第二步：

先点A、再点B、最后点C

先点A、再点C、最后点B

先点B、再点A、最后点C

先点B、再点C、最后点A

先点C、再点A、最后点B

先点C、再点B、最后点A

以上是6种排列，但是作为ABC的组合是没有区别的

也就是选择ABC三样菜的组合在排列中被计算了 A~3~^3^=6 次，但是在组合中实际上是同一种组合。

第三步：

因此总的组合种类数就是 A~5~^3^/A~3~^3^=60/6=10 种可能



**n选m**

从上面的例子中已经可以看出，思路二已经要比思路一逻辑更加简单

思路一对简单的可以分情况罗列，对复杂的分情况罗列会麻烦死的

思路二的步骤就三个：

第一步：先做n选m的排列，得到 A~n~^m^ 种排列

第二步：对于选中的m个元素，它们的全排列 A~m~^m^ 在组合中其实是没有区别的，也就是说所有的A~m~^m^种排列在组合中只能算作是一种组合

第三步：把重复计算的次数消去即可，也就是A~n~^m^/A~m~^m^

### 3.3 组合C~n~^m^

我们把从n个不同元素中选取m个元素的组合的种类数用C~n~^m^表示;

C~n~^m^ = A~n~^m^/A~m~^m^ = n! / [(n-m)! * m!]



### 3.4 组合的性质

#### 3.4.1 性质一：互补性质

C~n~^m^ = C~n~^n-m^

#### 3.4.2 性质二：组合恒等式

C~n~^m^  + C~n~^m-1^ = C~n+1~^m^











