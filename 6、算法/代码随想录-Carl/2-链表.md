# 1、移除链表元素

## 描述

题意：删除链表中等于给定值 val 的所有节点。

示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

示例 2：
输入：head = [], val = 1
输出：[]

示例 3：
输入：head = [7,7,7,7], val = 7
输出：[]

```java
static class ListNode
{
    int val;
    ListNode next;

    ListNode() {}

    ListNode(int val)
    {
        this.val = val;
    }

    ListNode(int val, ListNode next)
    {
        this.val = val;
        this.next = next;
    }
}

/**
 * 添加虚节点方式
 * 时间复杂度 O(n)
 * 空间复杂度 O(1)
 * @param head
 * @param val
 * @return
 */
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return head;
    }
    // 因为删除可能涉及到头节点，所以设置dummy节点，统一操作
    ListNode dummy = new ListNode(-1, head);
    ListNode pre = dummy;
    ListNode cur = head;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return dummy.next;
}
/**
 * 不添加虚拟节点方式
 * 时间复杂度 O(n)
 * 空间复杂度 O(1)
 * @param head
 * @param val
 * @return
 */
public ListNode removeElements(ListNode head, int val) {
    while (head != null && head.val == val) {
        head = head.next;
    }
    // 已经为null，提前退出
    if (head == null) {
        return head;
    }
    // 已确定当前head.val != val
    ListNode pre = head;
    ListNode cur = head.next;
    while (cur != null) {
        if (cur.val == val) {
            pre.next = cur.next;
        } else {
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}
```

# 2、设计链表

题意：

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

代码略

# 3、反转链表

## 描述

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

## 方法一：双指针

思路：创建一个指向当前节点的指针（称之为当前指针）指向当前列表中指针指向的节点，之后将当前指针指向下一个元素，而头指针不动，同时将头指针指向的节点的next指针指向null（也就是将当前链表分成两个链表），之后将当前指针指向当前节点临时保存起来，将当前指针指向当前节点的下一个节点，依次类推知道当前指针指向的节点为nnull；

![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

```java
public ListNode reverseList(ListNode head) {
    if(head == null) return null;
    ListNode current = head.next;
    ListNode temp = current;
    head.next = null;

    while(current != null){
        current = current.next;
        temp.next = head;
        head = temp;
        temp = current;
    }
    return head;
}
```

## 方法二：递归

> 在链表中使用递归时，我感觉有些不太符合递归的定义，为此我从百度上找了一句递归的定义：
> 		**递归定义**是[数理逻辑](https://baike.baidu.com/item/数理逻辑/18105)和[计算机科学](https://baike.baidu.com/item/计算机科学/9132)用到的一种[定义](https://baike.baidu.com/item/定义/483965)方式，使用被定义对象的自身来为其下定义（简单说就是自我复制的定义）。
> 		大部分的递归定义都由三个部分构成：基本情况的定义，递归法则和递归结束的情况。如果定义的对象是无限的，那么可以省略第三个部分（递归结束的情况）。比如说，可以用递归定义的方式来定义如下的一个[自然数](https://baike.baidu.com/item/自然数)集上的[函数](https://baike.baidu.com/item/函数/301912)f： 
>
> ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\852bf7f19ef40082e191b67ff45224ac.svg)
>
> ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\f59608ebefcd8991e47054d7afb0d661.svg)
>
> 这个定义在[逻辑](https://baike.baidu.com/item/逻辑/2139465)上是成立的，因为它首先定义了f在最小的自然数0上的取值，接下来对每个大于零的自然数n，只要重复有限多次定义的过程，最终就会回到对0的定义上。这样定义出的函数f就是[阶乘](https://baike.baidu.com/item/阶乘)函数。
>
> 递归定义和循环定义的不同之处在于，后者不包括对基本情况的定义。比如定义建立在[整数](https://baike.baidu.com/item/整数)集上的函数g：
>
> ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\7f31c7bc2f7196a1765b9e2e5fafe3df.svg)
>
> 则我们永远无法确定g的取值，这便是循环定义。



下面两种实现递归的方式都是用这个节点类：

```java
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

我的解法（第一版，有问题）：

我的这种思路是从后向前递归

```java
//这个类中的方法会返回链表的尾节点，同时将链表
//的头节点保存在全局变量中，和题目要求的有些不
//一样
class Solution {
    ListNode H = new ListNode();
    public ListNode reverseAndGetTail(ListNode head) {
        //用来判断链表中第一个节点是否为空
        if(head == null)
            return null;

        //用于退出迭代，也就是迭代链中的最后一步
        //因为每次返回的都当前节点，所以在递归链结束的时候
        //最后返回给用户的是链表的最后一个节点，但是这样就不能打印出
        //反转后的链表了，所以我定义了一个全局变量，用于保存链表的头节点
        if(head.next == null)
        {
            this.H = head;
            return H;
        }
        //递归调用返回的节点的next引用当前节点
        reverseAndGetTail(head.next).next = head;
        //将当前节点的next设置为null，否则会导致：A.next = B; B.next = A;
        //这是由于递归导致的
        head.next = null;
        //最后递归完一次返回当前节点
        return head;
    }
}
```

第一版中存在的问题是：每次递归返回的都是当前递归中参数传递进来的节点，导致最后整个递归执行完毕之后只能得到新链表的尾节点；

出现这样的问题的表面原因是：在递归链的最后一次递归中保存反转后新的链表的头节点指针的变量在递归链执行完最后一次递归之后，随着栈中方法的弹出而生命周期结束，结果就是每次递归中都返回当前递归中使用的节点（也就是参数指向的节点），直到最后整个递归链执行结束；

出现这样的问题的更深层次的原因是：在分析算法的时候认为递归链中每一次递归都要使用下一次递归中返回的值进行操作，从而达到反转链表的目的；为了达到这样的目的，我在每次递归的时候都会返回当前递归中使用的节点，这样可以在当前递归的下一次递归调用处得到下一次递归中使用的节点（记作Q），也就是当前递归中使用的节点的下一个节点，之后在当前递归中执行伪代码：Q.next = 当前节点；也正是这样的设计导致整条递归链执行结束之后得到的是反转后的链表的尾节点。

解决方式：根据链表的特点，每个节点都有指向下一个节点的指针，因此在递归链中的每次递归中即使不使用下一次递归返回的值也可以达到反转链表的操作，使用伪代码：current.next.next = current;因为在我递归链执行到最后一个递归的过程中的每个递归都不会修改当前递归中的节点的next指针，这样就可以在从递归链最后一个递归开始返回到递归链第一个递归的过程中使用这个当前节点的next指针来按照current.next.next = current;的形式反转链表。



我的解法（第二版，参考leetcode中的一个算法）：

在leetcode上有人和我的思路差不多，我对比了一下，找到了第一版中的问题：<u>递归链的最后一次递归最后返回的是head指针指向的新的头节点，但是这个头节点不一定要用于递归中，而是看实际的情况；因为原来链表中每个节点的next的指针还没有删除，所以可以用这个指针来执行反转操作</u>，关键代码是递归调用那段代码下的head.next.next=head;因为此时head指的是当前递归过程中的节点，而这个当前节点在原来链表中的next指针还在，所以可以用这个指针来对下一个节点的next指针进行操作（**<font color = "red">调用当前节点【head】的next指针得到下一个节点【记作N】，使用N.next = head执行反转链表的操作</font>**）

改版后的代码

```java
public ListNode reverseList(ListNode head){
    if(head == null || head.next == null){
        return head;
    }

    //递归调用，得到的值是最后反转后的链表的头节点
    ListNode cure = reverseList(head.next);
    
    //这些操作是从递归链的最后一个递归开始，到递归链的第一个
    //递归的过程中要执行的操作，这个操作要涉及到链表中
    //的两个节点，也就是当前节点和当前节点的下一个节点，所
    //以要在方法的最开头做出判断，以确定当前节点存在下一
    //个节点
    //使用旧链表中的指针关系进行反转操作
    head.next.next = head;
    head.next = null;
    
    //返回递归链中最后一次递归调用中得到的头节点
    return cur;
}
```



代码随想录中的另一种解法：

正向递归

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }
	/**
	param: prev相当于虚拟头节点
		   cur相当于头节点
		   也就是在这个函数中执行反转操作的两个节点
    return: 返回的值有两种————>一种是null,如果返回null，则代表当前链表没有节点；另一种是ListNode，这个ListNode一定是旧链表的尾节点（也就是新链表的头节点），这个尾节点也有可能是链表的头节点，这种情况下链表只有一个节点；
	*/
    private ListNode reverse(ListNode prev, ListNode cur) {
        //这个条件可以判断链表中是否有节点以及
        //当前遍历的节点是否是旧链表的尾节点
        if (cur == null) {
            return prev;
        }
        //临时节点，用于交换
        ListNode temp = null;
        temp = cur.next;// 先保存下一个节点
        cur.next = prev;// 反转
        // 更新prev、cur位置，向后移动一位
        // prev = cur;
        // cur = temp;
        return reverse(cur, temp);
    }
}
```

关于我对链表的正向递归和反向递归的分析：
![image-20220826201758595](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\image-20220826201758595.png)



## 拓展：反转部分链表

### 描述

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。


示例 1：


输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
示例 2：

输入：head = [5], left = 1, right = 1
输出：[5]


提示：

链表中节点数目为 n
1 <= n <= 500
-500 <= Node.val <= 500
1 <= left <= right <= n

### 思路

我的思路：和链表全部反转的思路一样，我在这里使用双指针的方式，在一次循环中完成链表的反转；首先要记录链表中要反转链表的前一个节点和后一个节点，以及部分链表的头节点和尾节点，在完成部分链表的反转之后通过这四个节点将整个链表连接起来。

我的代码：

```java
public ListNode<Integer> reverseBetween(ListNode<Integer> head, int left, int right) {
    ListNode virtualHead = new ListNode();
    ListNode reverseHead = virtualHead;
    virtualHead.next = head;
    virtualHead.data = -1;

    ListNode firstNode = null;
    ListNode secondNode = null;

    //保存反转链表部分的前后四个节点
    ListNode leftFrontNode = virtualHead;
    ListNode leftBehindNode = virtualHead;
    ListNode rightFrontNode = virtualHead;
    ListNode rightBehindNode = virtualHead;


    int i = 1;
    while(i <= right){
        if(i == left){
            firstNode = reverseHead.next;
            secondNode = firstNode.next;
            //用于将反转后的链表连接
            leftFrontNode = reverseHead;
            leftBehindNode = firstNode;
        }
        if(i == right){
            //用于将反转后的链表连接
            rightFrontNode = firstNode;
            rightBehindNode = firstNode.next;
        }

        //移动的方式与是否达到子链表的左边界有关
        if(firstNode == null){
            reverseHead = reverseHead.next;
        }else{
            //当i指向的位置是示例中输入的（2,4）中的2的时候，2对应的链表中的节点不能再指向前一个节点
            if(i != left ) {
                firstNode.next = reverseHead;
            }else{
                firstNode.next = null;
            }
            reverseHead = firstNode;
            firstNode = secondNode;
            secondNode = secondNode != null?secondNode.next:null ;
        }
        i++;
    }
    leftFrontNode.next= rightFrontNode;
    leftBehindNode.next = rightBehindNode;

    return virtualHead.next;
}
```



# 4、两两交换链表中的节点

## 描述

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：

![24.两两交换链表中的节点-题意](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\24.两两交换链表中的节点-题意.jpg)

## 方法一：迭代

思路：具体分析过程看下图

![image-20220825193047747](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\image-20220825193047747.png)

下面是我的代码，但是其中有很多多余的部分没有修改

```java
class ListNode
{
    int val;
    ListNode next;

    ListNode(){}

    ListNode(int val){this.val = val;}

    ListNode(int val, ListNode next)
    {
        this.val = val;
        this.next = next;
    }

    @Override
    public String toString()
    {
        return "{" +
            "val=" + val +
            ", next=" + next +
            '}';
    }
}

class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null)return null;
        if(head.next == null) return head;

        ListNode p = new ListNode(-1);
        p.next = head;
        head = p;
        ListNode l = head.next;
        ListNode r = l.next;
        ListNode temp;
        //进入循环开始交换L、R指针对应的节点，交换完毕之后再
        //交换P指针和L指针的位置，最后如果P指针之后的节点个数>=2
        //则将L、R指针平移到P指针之后，为下一次循环做准备
        while(true)
        {
            p.next = r;
            l.next = r.next;
            r.next = l;
            temp = p;
            p = l;
            l = temp;

            //如果P指针指向的位置没有元素或只有一个元素，就会直接退出循环
            if (p.next == null || p.next.next == null) break;

            l = p.next;
            r = l.next;
        }
        return head.next;
    }
}
```

- 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。
- 空间复杂度：O(1)



## 方法二：递归

反向递归

```java
//内部类的节点同上一种方法中的ListNode节点

public ListNode swapPairs(ListNode head) {
    //第一个条件判断链表中有没有元素，同时也判断链表节点个数是否是偶数
    //第二个条件判断链表节点个数是不是奇数
    if(head == null || head.next == null) return head;
    
    //这个节点值用于迭代执行完毕（执行到最后一行代码）后的返回
    ListNode next = head.next;

    //执行一次递归之后返回来的是两个节点交换后的第一个节点
    //或者如果最后一次递归中只有一个节点，那么就返回该节点
    //注意这里和反转链表中的递归方法中的我的解法（第二版的
    //区别），在哪里参数传递的是head.next，因为哪个算法
    //是整个链表反转，这个算法是链表奇数位的节点和偶数位的
    //节点进行交换
    ListNode listNode = swapPairs(head.next.next);

    //开始交换节点
    head.next.next = head;
    head.next = listNode;

    //每次迭代执行完毕之后都会将当前迭代中交换后的两个节点的第一个节点返回去
    return next;
}
```



# 5、删除链表的倒数第N个节点

## 描述

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：

![19.删除链表的倒数第N个节点](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\20210510085957392.png)

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：

输入：head = [1], n = 1 输出：[] 示例 3：

输入：head = [1,2], n = 1 输出：[1]

## 思路

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

步骤：

- 定义fast指针和slow指针，初始值为虚拟头结点，如图：

  ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\19.删除链表的倒数第N个节点.png)

- fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\19.删除链表的倒数第N个节点1.png)

- fast和slow同时移动，直到fast指向末尾，如题： ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\19.删除链表的倒数第N个节点2.png)

- 删除slow指向的下一个节点，如图： ![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\19.删除链表的倒数第N个节点3.png)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;

        ListNode slow = dummy;
        ListNode fast = dummy;
        while (n-- > 0) {
            fast = fast.next;
        }
        // 记住 待删除节点slow 的上一节点
        ListNode prev = null;
        while (fast != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next;
        }
        // 上一节点的next指针绕过 待删除节点slow 直接指向slow的下一节点
        prev.next = slow.next;
        // 释放 待删除节点slow 的next指针, 这句删掉也能AC
        slow.next = null;

        return dummy.next;
    }
}
```





# 6、链表相交

## 描述

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\20211219221657.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

示例1：


![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\20211219221723.png)



示例2：
![img](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\20211219221812.png)

## 方法一：

思路：简单来说，就是求两个链表交点节点的**指针**。 这里同学们要注意，交点不是数值相等，而是指针相等。

为了方便举例，假设节点元素数值相等，则节点指针相等。

看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：![面试题02.07.链表相交_1](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\面试题02.07.链表相交_1.png)

我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：

![面试题02.07.链表相交_2](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\面试题02.07.链表相交_2.png)

此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

否则循环退出返回空指针。

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != null) { // 求链表A的长度
            lenA++;
            curA = curA.next;
        }
        while (curB != null) { // 求链表B的长度
            lenB++;
            curB = curB.next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            //1. swap (lenA, lenB);
            int tmpLen = lenA;
            lenA = lenB;
            lenB = tmpLen;
            //2. swap (curA, curB);
            ListNode tmpNode = curA;
            curA = curB;
            curB = tmpNode;
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap-- > 0) {
            curA = curA.next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != null) {
            if (curA == curB) {
                return curA;
            }
            curA = curA.next;
            curB = curB.next;
        }
        return null;
    }

}
```

- 时间复杂度：O(n + m)
- 空间复杂度：O(1) 

## 方法二：双指针

思路：
![image-20220826225759086](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\image-20220826225759086.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode pA = headA, pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

- 时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。
- 空间复杂度：O(1)。

# 7、环形链表

## 描述

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

**说明**：不允许修改给定的链表。

![循环链表](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\20200816110112704.png)



## 方法一：迭代+哈希表

> 
>
> 我的思路：（但是感觉计算出来时间复杂度和普通的迭代没有什么区别，因为时间复杂度的计算不仅仅是判断循环执行的次数）
>
> 最少三个点构成一个圆圈，所以如果有环出现的话，那么这个环中的节点的数量一定大于3；
>
> 在判断是否存在环并确定起始位置的时候需要控制两个问题：
>
> 1. 在迭代的时候一次选的查找节点的个数（在我的算法中我一次查找三个节点，实际只是判断两个节点是否是环的起始节点）；
> 2. 减少迭代查找环的时间复杂度；
>
> 关于这两个问题，我的一个分析：
>
> ​		在一次迭代中查找节点的个数越多会导致查找所选的一系列节点的尾节点需要的时间复杂度提升，同时在判断是否已经走完一次循环的时候会更加复杂，例如：如果环有2000个节点，而选择的查找节点个数为1000，那么只需要查找3次就可以找到环的起始位置，同时也会一定程度上减少迭代查找环的时间复杂度，在这种情况下虽然只找了三次，但是如果环中有2500个节点，那么在查询的时候判断是否已经到达了环的起始位置就会很复杂（可能会再次用到一个循环）
> ​		因此我在这个算法中一次迭代中只是选择了判断两个节点是否是环的起始节点，而我在一次迭代中之所以选择3个节点是因为进入下一次起始节点只需要移动到第三个节点的位置即可无需多余的操作。

leetcode思路：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode pos = head;
        Set<ListNode> visited = new HashSet<ListNode>();
        while (pos != null) {
            if (visited.contains(pos)) {
                return pos;
            } else {
                visited.add(pos);
            }
            pos = pos.next;
        }
        return null;
    }
}
```

时间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。

空间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。

## 方法二：快慢指针

思路：这道题目，不仅考察对链表的操作，而且还需要一些数学运算。

主要考察两知识点：

- 判断链表是否环
- 如果有环，如何找到这个环的入口

### 1. 判断链表是否有环

可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。【注意：这里说的相遇指的是快指针和慢指针指向同一个节点，而不是快指针路过慢指针指向的节点，例如一种情况：慢指针下一步要指向环口处的节点，而快指针此时已经将环走了一次，停在环口处的上一个节点除，那么快指针和慢指针再走一步的话就会出现这样的情况，快指针指向入环口处节点，快指针路过该节点并指向该节点的下一个节点，这种追赶和高中物理中的追赶有区别】

为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢？

> 我认为：之所以快指针能遇见慢指针是因为快指针等待了慢指针，这是最终表现出来的结果，实际是因快指针比慢指针移动的快，因为环没有出口，所以快指针在环中循环的时候就相当于在等待，直到慢指针入环之后，快指针的等待结束；快指针和慢指针相遇的情况有两种：
>
> 1. 快指针和慢指针在环口（环的开始处）相遇：这种情况是一种特殊的情况，但是可以直观的看出规律，快指针在环中一直等待，直到慢指针入环，正好和慢指针指向同一个节点，那么这样就相当于快指针等待了慢指针n个环次；
> 2. 快指针和慢指针在环中相遇，这种情况和第一种情况是相同的。

代码随想录中的内容我没有贴过来，因为我没有感觉他说的有些经验所得的嫌疑，并没有说出其中包含的数学关系；这里我贴的是再leetcode中找到的一个解题思路：

> 双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；
>
> - 第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；
>
>   - TIPS: 若有环，两指针一定会相遇。因为每走 1轮，fast 与 slow 的间距 +1（在一个圆中，fast与slow之间的距离也就减少1，相当于fast一步步的靠近slow），fast 终会追上 slow；
>
>   
>
> - 第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：
>
>   - 设链表共有 a+b个节点，其中 链表头部到链表入口 有 a 个节点（不计链表入口节点）， 链表环 有 b 个节点（这里需要注意，a 和 b 是未知数，例如图解上链表 a=4 , b=5）；设两指针分别走了 f，s 步，则有：
>     - fast 走的步数是slow步数的 2 倍，即 f = 2s；（解析： fast 每轮走 2 步）
>     - fast 比 slow多走了 n 个环的长度，即 f = s + nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走 环的长度整数倍 ）；
>       以上两式相减得：f = 2nb，s=nb，即fast和slow 指针分别走了 2n，n 个 环的周长 （注意： n 是未知数，不同链表的情况不同）。
>
> 作者：jyd
> 链接：https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 2. 如果有环如何到这个换的入口

这里还是引用jyd的解释：

> - 如果让指针从链表头部一直向前走并统计步数k，那么所有走到链表中的环的入口节点时的步数是：k = a+nb（先走a步到环入口节点，之后每绕1圈（b步）都会再次到入口节点）
> - 当快指针和慢指针指向同一个节点的时候，slow指针走过的步数为nb步。因此只要想办法让slow再走a步停下来，就可以找到环的入口
> - 但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。
>   - 按照上面的分析，slow指针位置不变，将fast指针移动到链表头部；slow和fast同每轮流向前走1步（此时f = 0，s = nb）
>   - 当fast指针走到f = a步时，slow指针走到s = a+nb步，此时两指针再次重合，同时指向链表的环入口节点处。

整个过程如下图：

![1](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\BYYOE`[1BGXB_`CH@2Z2ZV7.png)

![2](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\0_F0A%WHSDJ@LL%2GW{XV47.png)
![3](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\`S7FE2{S`W12BW6%~D2_3OL.png)

![4](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\KUQ8Z`5B3C1K0QFFV_SLQ1.png)
![5](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\_UL_ZB_RLEBP}T7_@PVNMT.png)
![6](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\0$T}C[%7UW7NKALOE9483OB.png)
![7](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\P0Y4ZT5_XRM@UIL8TP%9VI3.png)
![8](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\H8_2~PY69IKDZZ%DW0QQGT.png)
![9](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\9.png)
![10](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\10.png)
![11](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\11.png)



```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            if (fast == null || fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
```



# 8、总结

链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。

**每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题**。

![链表总结.png (1269×845)](D:\Tyora\AssociatedPicturesInTheArticles\2-链表\链表总结.png)











