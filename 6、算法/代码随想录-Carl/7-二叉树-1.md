# 1、二叉树理论基础

《代码随想录》算法视频公开课：[关于二叉树，你该了解这些！ (opens new window)](https://www.bilibili.com/video/BV1Hy4y1t7ij)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

题目分类大纲如下：

![二叉树大纲](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20210219190809451.png)

说道二叉树，大家对于二叉树其实都很熟悉了，本文呢我也不想教科书式的把二叉树的基础内容在啰嗦一遍，所以一下我讲的都是一些比较重点的内容。

相信只要耐心看完，都会有所收获。

## 二叉树的种类

在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。

## 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

如图所示：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200806185805576.png)

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。

## 完全二叉树

什么是完全二叉树？

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

**大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。**

我来举一个典型的例子如题：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200920221638903.png)

相信不少同学最后一个二叉树是不是完全二叉树都中招了。

**之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。**

## 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

下面这两棵树都是搜索树 ![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200806190304693.png)

## 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如图：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200806190511967.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

**所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！**

## 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。

链式存储如图：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\2020092019554618.png)

链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？

其实就是用数组来存储二叉树，顺序存储的方式如图：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200920200429452.png)

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

**所以大家要了解，用数组依然可以表示二叉树。**

## 二叉树的遍历方式

关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。

一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。

我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。

**这里前中后，其实指的就是中间节点的遍历顺序**，只要大家记住 前中后序指的就是中间节点的位置就可以了。

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

大家可以对着如下图，看看自己理解的前后中序有没有问题。

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200806191109896.png)

最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

**之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

**这里其实我们又了解了栈与队列的一个应用场景了。**

具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。

## 二叉树的定义

刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。

C++代码如下：

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。

这里要提醒大家要注意二叉树节点定义的书写方式。

**在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。**

因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！

## 总结

二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。

本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。

**说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。**

# 2、二叉树的递归遍历

《代码随想录》算法视频公开课：[每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！ (opens new window)](https://www.bilibili.com/video/BV1Wh411S7xt)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

> 一看就会，一写就废！

这次我们要好好谈一谈递归，为什么很多同学看递归算法都是“一看就会，一写就废”。

主要是对递归不成体系，没有方法论，**每次写递归算法 ，都是靠玄学来写代码**，代码能不能编过都靠运气。

**本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。**

这里帮助大家确定下来递归算法的三个要素。**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

// 前序遍历·递归·LC144_二叉树的前序遍历
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        list.add(root.val);
        preorder(root.left, list);
        preorder(root.right, list);
    }
}
// 中序遍历·递归·LC94_二叉树的中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res;
    }

    void inorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        inorder(root.left, list);
        list.add(root.val);             // 注意这一句
        inorder(root.right, list);
    }
}
// 后序遍历·递归·LC145_二叉树的后序遍历
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root, res);
        return res;
    }

    void postorder(TreeNode root, List<Integer> list) {
        if (root == null) {
            return;
        }
        postorder(root.left, list);
        postorder(root.right, list);
        list.add(root.val);             // 注意这一句
    }
}
```

# 3、二叉树的迭代遍历

《代码随想录》算法视频公开课：

- [写出二叉树的非递归遍历很难么？（前序和后序）(opens new window)](https://www.bilibili.com/video/BV15f4y1W7i2)
- [写出二叉树的非递归遍历很难么？（中序）) (opens new window)](https://www.bilibili.com/video/BV1Zf4y1a77g)相信结合视频在看本篇题解，更有助于大家对本题的理解。

> 听说还可以用非递归的方式

看完本篇大家可以使用迭代法，再重新解决如下三道leetcode上的题目：

- [144.二叉树的前序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- [94.二叉树的中序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
- [145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

为什么可以用迭代法（非递归的方式）来实现二叉树的前后中序遍历呢？
因为我们可以手动用数据结构：栈；来实现递归的思路；

**<u>*<font color = "red">这个栈是一个辅助队列，这个栈的作用是：记录递归遍历的节点的顺序，弹出栈的节点就是当前应该操作的节点（该节点也就是在二叉树中的当前指针指向的节点），在遍历二叉树和翻转二叉树中都是使用的这种思路</font>*</u>**

我们在[栈与队列：匹配问题都是栈的强项 (opens new window)](https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html)中提到了，**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。

## 前序遍历（迭代法）

我们先看一下前序遍历。

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

动画如下：

![二叉树前序遍历（迭代法）](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\008eGmZEly1gnbmss7603g30eq0d4b2a.gif)

不难写出如下代码: （**注意代码中空节点不入栈**）

此时会发现貌似使用迭代法写出前序遍历并不难，确实不难。

**此时是不是想改一点前序遍历代码顺序就把中序遍历搞出来了？**

其实还真不行！

但接下来，**再用迭代法写中序遍历的时候，会发现套路又不一样了，目前的前序遍历的逻辑无法直接应用到中序遍历上。**



## 中序遍历（迭代法）

为了解释清楚，我说明一下 刚刚在迭代（前序遍历）的过程中，其实我们有两个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

动画如下：

![二叉树中序遍历（迭代法）](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\008eGmZEly1gnbmuj244bg30eq0d4kjm.gif)



## 后序遍历（迭代法）

再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![前序到后序](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20200808200338924.png)



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

// 前序遍历顺序：中-左-右，入栈顺序：中-右-左
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        //——————————中——————————
        Stack<TreeNode> stack = new Stack<>();
        //首先将根节点入栈
        stack.push(root);
        
        while (!stack.isEmpty()){
            //中节点出栈
            TreeNode node = stack.pop();
            //中节点存入结果集合
            result.add(node.val);
            
            //——————————右——————————
            //中间节点的左右孩子入栈（如果存在的话）
            if (node.right != null){
                stack.push(node.right);
            }
            
            //——————————左——————————
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
}

// 中序遍历顺序: 左-中-右 入栈顺序： (中===>>左) -> 右
//注意：在迭代方式的中序遍历中整棵树的根节点可以看作以某个虚拟节点的左孩子的身份入栈。
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        //cur指针在一次循环中始终是指向当前循环中正在遍历的元素
        TreeNode cur = root;
        
        //如果当前指针指向的节点是null，并且此时栈为空的时候才会退出循环，因为在循环一开始的时候栈就是空的，所以不能直接因为栈为空退出循环
        //根节点不会首先入栈
        while (cur != null || !stack.isEmpty()){
            //从根节点开始一直left，将遇到的节点都放入栈中（包括根节点自己），知道遇到的节点是null
            if (cur != null){	//使用指针来访问节点，访问到二叉树的最底层（非叶子节点）
                stack.push(cur);	//将访问到的节点放入栈中
                
                //——————————左——————————
                cur = cur.left;	//将当前指针指向当前节点的左孩子（可能为空也可能为一个节点）
            }else{	//如果当前节点空就从栈中弹出栈顶元素（该元素的左孩子是当前节点），并将该元素加入结果集中，将当前节点指针指向该元素的右孩子。这个分支的作用是转向。
                
                //——————————中——————————
                cur = stack.pop();
                result.add(cur.val);
                
                //——————————右——————————
                cur = cur.right;
            }
        }
        return result;
    }
}

// 后序遍历顺序 左-右-中 入栈顺序：中(整棵的根节点,入栈一次)-左-右 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        
        stack.push(root);
        
        while (!stack.isEmpty()){
            //——————————中——————————
            TreeNode node = stack.pop();
            result.add(node.val);
            
            //——————————左——————————
            if (node.left != null){
                stack.push(node.left);
            }
            //——————————右——————————
            if (node.right != null){
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```

## 总结

<font color = "red">非递归的前序遍历和后序遍历在辅助栈中存放的元素的数量不会超过3，非递归的中序遍历在辅助栈中存放的元素的数量是二叉树的深度。</font>

此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。

**这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！**

上面这句话，可能一些同学不太理解，建议自己亲手用迭代法，先写出来前序，再试试能不能写出中序，就能理解了。

**那么问题又来了，难道 二叉树前后中序遍历的迭代法实现，就不能风格统一么（即前序遍历 改变代码顺序就可以实现中序 和  后序）？**

当然可以，这种写法，还不是很好理解，我们将在下一篇文章里重点讲解，敬请期待！

# 4、二叉树的统一迭方法

此时我们在[二叉树：一入递归深似海，从此offer是路人 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)中用递归的方式，实现了二叉树前中后序的遍历。

在[二叉树：听说递归能做的，栈也能做！ (opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)中用栈实现了二叉树前后中序的迭代遍历（非递归）。

之后我们发现**迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。**

实践过的同学，也会发现使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。

其实**针对三种遍历方式，使用迭代法是可以写出统一风格的代码！**

**重头戏来了，接下来介绍一下统一写法。**

我们以中序遍历为例，在[二叉树：听说递归能做的，栈也能做！ (opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)中提到说使用栈的话，**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

**那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。

##  迭代法中序遍历



代码随想录中的遍历方式和我一开始想的中序遍历的思路有些类似，但是我一开始考虑的不全，没有处理好节点退栈的情况，导致进入死循环；我当时的代码如下：

```java
/**
static class TreeNode {
    TreeNode left;
    TreeNode right;
    int val;
}


public static List<Integer> inorderTraversal(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    ArrayList<Integer> result = new ArrayList<>();
    //首先将二叉数的根节点入栈
    stack.push(root);
    TreeNode node = stack.peek();
    while(!stack.isEmpty()){
        node = stack.pop();
        if(node.right != null) stack.push(node.right);
        stack.push(node);
        if(node.left != null) stack.push(node.left);
        
        //这里存在错的很离谱，我当时应该没怎么细考虑这里的处理逻辑。
        result.add(node.val);
    }
    return result;
}
*/
```



中序遍历代码如下：（详细注释）

中序遍历的代码中空节点不入栈，栈中的null节点是标志位，标志着：如果栈顶元素是null的话，那么null之前靠近栈底的节点就可以弹栈了。

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        //首先将二叉树根节点入栈
        if (root != null) st.push(root);
        
        while (!st.empty()) {
            //判断栈顶元素是否为null，如果为null意味着这个将这个null作为左孩子的节点没有左孩子，应该将null和该节点都弹栈，在结束循环的同时可以防止死循环
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将 右中null左 节点添加到栈中
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集，空节点是标志位，不是二叉树中空的叶子节点
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
}
```

看代码有点抽象我们来看一下动画(中序遍历)：

![中序遍历迭代（统一写法）](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\008eGmZEly1gnbmq3btubg30em09ue82.gif)

动画中，result数组就是最终结果集。

可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。

此时我们再来看前序遍历代码。

## 迭代法前序遍历

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        
        while (!st.empty()) {
            //判断栈顶元素是否为null，如果为null意味着这个将这个null作为左孩子的节点没有左孩子，应该将null和该节点都弹栈，在结束循环的同时可以防止死循环
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将 右左中null 节点添加到栈中
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
                st.push(node);	// 添加中节点
                st.push(null); 	// 中节点访问过，但是还没有处理，加入空节点做为标记。
                
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();	// 将空节点弹出
                node = st.peek();	// 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
}
```



## 迭代法后序遍历

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {

        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        //首先将根节点入栈
        if (root != null) st.push(root);
        
        while (!st.empty()) {
            //判断栈顶元素是否为null，如果为null意味着这个将这个null作为左孩子的节点没有左孩子，应该将null和该节点都弹栈，在结束循环的同时可以防止死循环
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将 中null右左 节点顺序添加到栈中
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         

            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
}
```



## 总结

**<u>*这三种迭代的方式本质上也是深度优先遍历。*</u>**

上面三种方式相同的递归遍历二叉树的方式只是在向栈中添加根节点、左孩子、右孩子的顺序不同，达到了像递归一样统一的方式。

这三种写法中最重要的一步是：
	<font color = "red"><u>***在将父节点从栈先加入栈之后再次弹出，在父节点第二次加入栈的时候，需要再向栈中加入一个null节点作为标志位***</u></font>；

这个标志位有两个作用：
	<font color = "blue">1. 标志栈这个标志位之前靠近栈底的节点的左右孩子已经都访问过；这样可以防止差生死循环。</font>
	<font color = "blue">2. 标志栈可以弹出栈顶元素了；这样可以逐渐减少栈中的元素，向结束循环的方向靠拢</font>

**<font color = "red" size = 4px>如果没有这个标志，而是使用二叉树中的空节点作为判断，会<u>*直接导致弹栈的标志会发生混乱，不知道栈中某个null元素是栈中哪个非空节点的孩子，使情况变得很复杂*</u>，同时也会<u>*间接导致无法判断某个节点是否已经访问过，从而产生死循环。*</u></font>**

# 5、二叉树的层序遍历

《代码随想录》算法视频公开课：[讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历 (opens new window)](https://www.bilibili.com/video/BV1GY4y1u7b2)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

学会二叉树的层序遍历，可以一口气打完以下十题：

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的层序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度

## 描述

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

![102.二叉树的层序遍历](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20210203144842988.png)

## 思路

我们之前讲过了三篇关于二叉树的深度优先遍历的文章：

- [二叉树：前中后序递归法(opens new window)](https://programmercarl.com/二叉树的递归遍历.html)
- [二叉树：前中后序迭代法(opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)
- [二叉树：前中后序迭代方式统一写法(opens new window)](https://programmercarl.com/二叉树的统一迭代法.html)

接下来我们再来介绍二叉树的另一种遍历方式：层序遍历。

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而使用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

使用队列实现二叉树广度优先遍历，动画如下：

![102二叉树的层序遍历](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

这样就实现了层序从左到右遍历二叉树。

代码如下：**这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了**。

```java
// 102.二叉树的层序遍历
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        //checkFun01(root,0);
        checkFun02(root);

        return resList;
    }

    /**DFS--递归方式（递归方式是以深度优先的方式层序打印，这种方式本质就是以递归方式前序遍历二叉树，只是在输出的时候不是结果按顺序输出，而是将结果放在不同层的位置上来模拟层序遍历）

	例如：这种方式的打印结果为：
		[[6]]
		[[6], [4]]
		[[6], [4], [1]]
		[[6], [4], [1, 3]]
		[[6], [4, 7], [1, 3]]
		[[6], [4, 7], [1, 3, 5]]
		[[6], [4, 7], [1, 3, 5, 8]]
		[[6], [4, 7], [1, 3, 5, 8]]
		
		这里的每一行数组都是在一次递归前打印出来的内容，如果将每次新加进来的元素按照顺序输出，那么结果就应该是：6,4,4,3,7,5,8，这个输出的结果和递归方式的前序遍历的结果是一样的。
	*/
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }

    //BFS--迭代方式--借助队列
    public void checkFun02(TreeNode node) {
        if (node == null) return;
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(node);

        while (!que.isEmpty()) {
            List<Integer> itemList = new ArrayList<Integer>();
            int len = que.size();

            while (len > 0) {
                TreeNode tmpNode = que.poll();
                itemList.add(tmpNode.val);

                if (tmpNode.left != null) que.offer(tmpNode.left);
                if (tmpNode.right != null) que.offer(tmpNode.right);
                len--;
            }

            resList.add(itemList);
        }

    }
}
```

# 6、翻转二叉树

## 描述

翻转一棵二叉树。

![226.翻转二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20210203192644329.png)

这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）

## 题外话

这道题目是非常经典的题目，也是比较简单的题目（至少一看就会）。

但正是因为这道题太简单，一看就会，一些同学都没有抓住起本质，稀里糊涂的就把这道题目过了。

如果做过这道题的同学也建议认真看完，相信一定有所收获！

## 思路

代码随想录》算法视频公开课：[听说一位巨佬面Google被拒了，因为没写出翻转二叉树 | LeetCode：226.翻转二叉树 (opens new window)](https://www.bilibili.com/video/BV1sP4y1f7q7)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

我们之前介绍的都是各种方式遍历二叉树，这次要翻转了，感觉还是有点懵逼。

这得怎么翻转呢？

如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：

![226.翻转二叉树1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\20210203192724351.png)

可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。

关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ （一些同学这道题都过了，但是不知道自己用的是什么顺序）

遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。

**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

## 方法一：递归法

对于二叉树的递归法的前中后序遍历，已经在[二叉树：前中后序递归遍历 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)详细讲解了。

我们下文以前序遍历为例，通过动画来看一下翻转的过程:

![翻转二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-1\008eGmZEly1gnakm26jtog30e409s4qp.gif)

我们来看一下递归三部曲：

1. 确定递归函数的参数和返回值

参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode`。

```java
TreeNode invertTree(TreeNode root)
```

2. 确定终止条件

当前节点为空的时候，就返回

```java
if (root == NULL) return root;
```

3. 确定单层递归的逻辑

因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。

```java
swap(root.left, root.right);
invertTree(root.left);
invertTree(root.right);
```

基于这递归三步法，代码基本写完，Java代码如下：

```java
//DFS递归
class Solution {
    /**
     * 前后序遍历都可以
     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）
     */
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        invertTree(root.left);
        invertTree(root.right);
        swapChildren(root);
        return root;
    }

    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}
```

我写的精简的递归反转代码：

```java
public TreeNode invertTree(TreeNode root) {
    if(root == null) return null;
    TreeNode temp = root.left;
    root.left = inorderTraversal(root.right);
    root.right = inorderTraversal(temp);
    return root;
}
```



## 方法二：迭代法

### 深度优先遍

用辅助数据结构：栈，来模拟递归的思路；<font color = "red">***这个栈中记录的节点的顺序就是递归过程中的节点的顺序，所以弹出栈的元素就是指向二叉树中当前应该操作的节点***</font>。

#### 前序遍历迭代法（普通版）

```c++
/**
c++写的，我没有改成Java版的
*/
class Solution {
    public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();  // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right); // 右
            if(node->left) st.push(node->left);   // 左
        }
        return root;
    }
};
```

#### 前序遍历迭代法（通用版）

```c++
/**
c++版的，我没有改成Java版的
*/
class Solution {
    public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
            }
        }
        return root;
    }
};
```

#### 对中序遍历的补充

虽然不能使用常规递归的中序遍历的递归版来反转二叉树，但是可以使用非常规递归的中序遍历的方式、或使用非递归的方式进行中序遍历的方式对二叉树进行翻转；原因以及代码如下：

因为在递归的方式下使用中序遍历翻转链表的时候，先翻转某节点G的左子树，之后交换G的左子树和右子树，接着翻转G的右子树，但是此时的G是已经翻转后的，所以此时G的右子树是原来的G的左子树，需要再次翻转G的左子树才可以对以G为根节点的树翻转成功；而在使用辅助栈之后，就可以在栈中记录递归操作的节点的顺序，根据栈中弹出来的节点对该节点进行翻转，而不是使用二叉树中此时的指针来翻转；代码如下：

```c++
/**
非常规递归的中序遍历方式
这里使用的是c++的代码，Java的我没有写，但是思路是一样的
*/
class Solution {
    public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        invertTree(root->left);         // 左
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 注意 这里依然要遍历左孩子，因为中间节点已经翻转了
        return root;
    }
};
```

```c++
class Solution {
    public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                st.push(node);                          // 中
                st.push(NULL);
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
            }
        }
        return root;
    }
};
```



###  广度优先遍历

```java
//BFS
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {return null;}
        ArrayDeque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                swap(node);
                if (node.left != null) {deque.offer(node.left);}
                if (node.right != null) {deque.offer(node.right);}
            }
        }
        return root;
    }

    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
```

# 8、小总结

在实现迭代法的过程中，有同学问了：递归与迭代究竟谁优谁劣呢？

从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。

递归更容易让程序员理解，但收敛不好，容易栈溢出。

这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。

**在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。**

