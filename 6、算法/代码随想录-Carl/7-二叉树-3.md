# 1、左叶子之和

## 描述

计算给定二叉树的所有左叶子之和。

示例：

![404.左叶子之和1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210204151927654.png)

## 思路

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。**

因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

大家思考一下如下图中二叉树，左叶子之和究竟是多少？

![404.左叶子之和](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210204151949672.png)

**其实是0，因为这棵树根本没有左叶子！**

但看这个图的左叶子之和是多少？

![图二](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20220902165805.png)

相信通过这两个图，大家可以最左叶子的定义有明确理解了。

那么**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。**

如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：

```java
if (node.left != NULL && node.left.left == NULL && node.left.right == NULL) {
    左叶子节点处理逻辑
}
```

### 方法一：递归

递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。

递归三部曲：

1. 确定递归函数的参数和返回值

判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int

使用题目中给出的函数就可以了。

2. 确定终止条件

如果遍历到空节点，那么左叶子值一定是0

```cpp
if (root == NULL) return 0;
```

注意，只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：

```cpp
if (root == NULL) return 0;

//其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。
//if (root.left == NULL && root.right== NULL) return 0; 
```

3. 确定单层递归的逻辑

当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。

代码如下：

```java
int leftValue = sumOfLeftLeaves(root.left);    // 左
if (root.left && !root.left.left && !root.left.right) {
    leftValue = root.left.val;
}
int rightValue = sumOfLeftLeaves(root.right);  // 右

int sum = leftValue + rightValue;               // 中
return sum;
```

整体递归代码如下：(代码随想录种的代码  C++版)

```c++
/**
这段代码的整体思路还是：每次迭代都是针对当前节点进行操作，只有在最后退出迭代、计算当前节点的leftCount的时候才会用到当前节点的孩子，判断当前节点的孩子是否是叶子节点。
*/
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL) return 0;
        //这步操作可以加快迭代的停止，但是破坏了整体代码的思路，因为这个算法中，每次迭代都是针对当前节点进行操作，只有在最后退出迭代、计算当前节点的leftCount的时候才会用到当前节点的孩子，判断当前节点的孩子是否是叶子节点。
        //if (root->left == NULL && root->right== NULL) return 0;

        //只有递归到以当前节点为根节点的整棵树的最左叶子节点处才会开始计算值
        int leftValue = sumOfLeftLeaves(root->left);    // 左
        if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = leftValue + rightValue;               // 中
        return sum;
    }
};
```

我的代码：

`我的思路是：每次递归中，不变的节点类型是——>父节点+父节点的孩子，每次根据这两种类型的节点判断是否继续递归，还是直接求值，还是直接返回值；与代码随想录中的递归的区别就在于每次迭代中操作的节点的类型。`

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        if(root.left == null && root.right == null) return 0;
        int leftCount = 0;
        int rightCount = 0;
        
        //判断以当前节点为父节点的左孩子是否为叶子节点，如果是就直接计算leftCount的值，否则继续递归调用
        if(root.left != null && root.left.left == null && root.left.right == null){
            leftCount = root.left.val;
        }else{
            //我的代码和它的代码的区别就在这里，它的代码种会直接调用这个递归，而在我的代码种会判断当前节点的左孩子是否是叶子节点
            leftCount = isSymmetric1(root.left);
        }
        
        //以为当前节点的右节点为根节点，继续递归调用。
        if(root.right != null) rightCount = isSymmetric1(root.right);

        return leftCount + rightCount;
    }
}
```

### 方法二：迭代

代码随想录种的迭代的方式和代码随想录种递归的思路是一致的，每次迭代的时候都迭代种操作的都是当前节点，只有在求leftCount的时候才会判断当前节点的孩子是否是叶子节点。

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        Stack<TreeNode> stack = new Stack<> ();
        stack.add(root);
        int result = 0;
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node.left != null && node.left.left == null && node.left.right == null) {
                result += node.left.val;
            }
            if (node.right != null) stack.add(node.right);
            if (node.left != null) stack.add(node.left);
        }
        return result;
    }
}
```



## 总结

这道题目要求左叶子之和，其实是比较绕的，因为不能判断本节点是不是左叶子节点。

此时就要通过节点的父节点来判断其左孩子是不是左叶子了。

**平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。**

希望通过这道题目，可以扩展大家对二叉树的解题思路。



# 2、找树左下角的值

## 描述



给定一个二叉树，在树的最后一行找到最左边的值。

示例 1:

![513.找树左下角的值](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210204152956836.png)

示例 2:

![513.找树左下角的值1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210204153017586.png)

## 思路

咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？

没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。

我们来分析一下题目：在树的**最后一行**找到**最左边的值**。

首先要是最后一行，然后是最左边的值。

如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。

如果对二叉树深度和高度还有点疑惑的话，请看：[110.平衡二叉树 (opens new window)](https://programmercarl.com/0110.平衡二叉树.html)。

所以要找深度最大的叶子节点。

那么如果找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。

递归三部曲：

1. 确定递归函数的参数和返回值

参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。

本题还需要类里的两个全局变量，maxDepth用来记录最大深度，maxNodeVal记录最大深度最左节点的数值。

代码如下：

```java
int maxDepth = INT_MIN;   // 全局变量 记录最大深度
int maxNodeVal;       // 全局变量 最大深度最左节点的数值
void traversal(TreeNode* root, int depth)
```

2. 确定终止条件

当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。

代码如下：

```java
//在确定终止条件的时候没有判断当前节点是否为空节点，所以在我确定单词递归的逻辑中调用递归的时候会判断当前节点的左右孩子是否是空节点。
if (root.left == NULL && root.right == NULL) {
    if (depth > maxDepth) {
        maxDepth = depth;           // 更新最大深度
        result = root.val;   // 最大深度最左面的数值
    }
    return;
}
```

3. 确定单层递归的逻辑

在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：

```java
//略				   // 中
if (root->left) {   // 左
    depth++; // 深度加一
    traversal(root->left, depth);
    depth--; // 回溯，深度减一
}
if (root->right) { // 右
    depth++; // 深度加一
    traversal(root->right, depth);
    depth--; // 回溯，深度减一
}
return;
```

### 方法一：递归

```c++
/**
代码随想录中递归的Java版代码的思路和我的思路是一致，没有作者思路的Java代码，所以只把c++的代码贴过来了。
*/
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            depth++;
            traversal(root->left, depth);
            depth--; // 回溯
        }
        if (root->right) {
            depth++;
            traversal(root->right, depth);
            depth--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```

我的代码：

```java
class Solution {

    int maxNodeVal = 0;
    int maxDepth = 0;

    public int findBottomLeftValue(TreeNode root) {
            traversal(root,1);
            return maxNodeVal;
    }
        
    public void traversal(TreeNode root,int depth) {
        if(root == null) return;
        //当在遍历二叉树的时候遇到叶子节点的时候就会判断该叶子节点所在层是不是比最大的深度还深，如果比最大的深度还大的话就改变maxNodeVal、maxDepth的值为当前节点的深度和当前节点的val。
        if(root.left == null && root.right == null)
        {
            if(depth > maxDepth){
                maxDepth = depth;
                maxNodeVal = root.val;
            }
        }
        
        //因为我在递归终止的条件处判断了当前节点是否为空节点，所以在这里递归调用的时候我就没有再判断了。
        //递归当前节点的左孩子，同时传入当前节点左孩子的深度
        depth++;
        traversal(root.left,depth);
        depth--; 	//回溯
        
        //递归当前节点的右孩子，同时传入当前节点右孩子的深度
        depth++;
        traversal(root.right,depth);
        depth--;	//回溯
    }
}
```



# 3、递归函数的返回值

> 递归函数什么时候需要返回值

相信很多同学都会疑惑，递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为bool类型。

那么接下来我通过详细讲解如下两道题，来回答这个问题：

- 112.路径总和
- 113.路径总和ii

## 1、 路径总和

### 描述

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 给定如下二叉树，以及目标和 sum = 22，

![112.路径总和1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210203160355234.png)

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

### 思路

这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。

#### 递归

可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树

1. 确定递归函数的参数和返回类型

参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。

<font color = "red">**再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：**</font>

- <font color = "red">**如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）**</font>
- <font color = "red">**如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）**</font>
- <font color = "red">**如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）**</font>

而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？

如图所示：

![112.路径总和](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\2021020316051216.png)

图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。

所以代码如下：

```c++
bool traversal(treenode* cur, int count)   // 注意函数的返回类型
```



2. 确定终止条件

首先计数器如何统计这一条路径的和呢？

不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。

如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。

如果遍历到了叶子节点，count不为0，就是没找到。

递归终止条件代码如下：

```c++
if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
if (!cur->left && !cur->right) return false; // 遇到叶子节点而没有找到合适的边，直接返回
```



3. 确定单层递归的逻辑

因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。

递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。

代码如下：

```cpp
if (cur->left) { // 左 （空节点不遍历）
    // 遇到叶子节点返回true，则直接返回true
    if (traversal(cur->left, count - cur->left->val)) 
        return true; // 注意这里有回溯的逻辑
}
if (cur->right) { // 右 （空节点不遍历）
    // 遇到叶子节点返回true，则直接返回true
    if (traversal(cur->right, count - cur->right->val)) 
        return true; // 注意这里有回溯的逻辑
}
return false;
```



以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢 ？

回溯隐藏在`traversal(cur->left, count - cur->left->val)`这里， 因为把`count - cur->left->val` 直接作为参数传进去，函数结束，count的数值没有改变。

为了把回溯的过程体现出来，可以改为如下代码：

```c++
if (cur->left) { // 左
    count -= cur->left->val; // 递归，处理节点;
    if (traversal(cur->left, count)) return true;
    count += cur->left->val; // 回溯，撤销处理结果
}
if (cur->right) { // 右
    count -= cur->right->val;
    if (traversal(cur->right, count)) return true;
    count += cur->right->val;
}
return false;
```



整体代码如下：

```cpp
class Solution {
private:
    bool traversal(TreeNode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
        if (!cur->left && !cur->right) return false; // 遇到叶子节点直接返回

        if (cur->left) { // 左
            count -= cur->left->val; // 递归，处理节点;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // 回溯，撤销处理结果
        }
        if (cur->right) { // 右
            count -= cur->right->val; // 递归，处理节点;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // 回溯，撤销处理结果
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```

#### 迭代

如果使用栈模拟递归的话，那么如果做回溯呢？

**此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。**

c++就我们用pair结构来存放这个栈里的元素。

定义为：`pair<TreeNode*, int>` pair<节点指针，路径数值>

这个为栈里的一个元素。

如下代码是使用栈模拟的前序遍历，如下：（详细注释）

```cpp
class solution {

public:
    bool haspathsum(TreeNode* root, int sum) {
        if (root == null) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<TreeNode*, int>> st;
        st.push(pair<TreeNode*, int>(root, root->val));
        while (!st.empty()) {
            pair<TreeNode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```

## 2、路径总和ii

### 描述

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例: 给定如下二叉树，以及目标和 sum = 22，

![113.路径总和ii1.png](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210203160854654.png)

### 思路

找到所有路径，**所以递归函数不要返回值！**

如图：

![113.路径总和ii](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210203160922745.png)

为了尽可能的把细节体现出来，我写出如下代码（**这份代码并不简洁，但是逻辑非常清晰**）

```cpp
class solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    // 递归函数不需要返回值，因为我们要遍历整个树
    void traversal(treenode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) { // 遇到了叶子节点且找到了和为sum的路径
            result.push_back(path);
            return;
        }

        if (!cur->left && !cur->right) return ; // 遇到叶子节点而没有找到合适的边，直接返回

        if (cur->left) { // 左 （空节点不遍历）
            path.push_back(cur->left->val);
            count -= cur->left->val;
            traversal(cur->left, count);    // 递归
            count += cur->left->val;        // 回溯
            path.pop_back();                // 回溯
        }
        if (cur->right) { // 右 （空节点不遍历）
            path.push_back(cur->right->val);
            count -= cur->right->val;
            traversal(cur->right, count);   // 递归
            count += cur->right->val;       // 回溯
            path.pop_back();                // 回溯
        }
        return ;
    }

public:
    vector<vector<int>> pathsum(treenode* root, int sum) {
        result.clear();
        path.clear();
        if (root == null) return result;
        path.push_back(root->val); // 把根节点放进路径
        traversal(root, sum - root->val);
        return result;
    }
};
```

至于113. 路径总和ii 的迭代法我并没有写，用迭代方式记录所有路径比较麻烦，也没有必要，如果大家感兴趣的话，可以再深入研究研究。

我使用迭代，按照作者的思路写的代码：

```java
List<List<Integer>> list = new ArrayList<>();
ArrayList<Integer> item = new ArrayList<>();

public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    if(root == null) return list;
    test(root,targetSum);
    return list;
}

/**
每次递归中都是对当前节点以及sum-当前节点.val的值进行判断；要注意循环这个说法在递归中的应用，可以通过  循环/递归  的边界来发现这个问题。
*/
public void test(TreeNode root,int sum) {
    if(root.left == null && root.right == null && sum-root.val == 0)
    {
        //在最后一次递归中复制一份item一次性保存入list中
        item.add(root.val);
        ArrayList<Integer> clone = (ArrayList<Integer>)item.clone();
        list.add(clone);
        //回溯，将最后一次递归中加入到item中的值去除
        item.remove(item.size()-1);
        return;
    }
    //如果递归到叶子节点sum的值还不是0（可能此时已经是负数了），就直接返回
    //（在代码中没有做对从根节点到叶子节点中部分元素和为0的判断）
    if(root.left == null && root.right == null) return ;

    item.add(root.val);
    if(root.left != null)
    {
        sum-=root.val;
        test(root.left, sum);
        sum+=root.val;
    }
    //回溯
    item.remove(item.size()-1);

    item.add(root.val);
    if(root.right != null)
    {
        sum-=root.val;
        test(root.right, sum);
        sum+=root.val;
    }
    item.remove(item.size()-1);
}
```

# 4、从中序和后续遍历序列构造二叉树

## 描述

根据一棵树的中序遍历与后序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

例如，给出中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：

![106. 从中序与后序遍历序列构造二叉树1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210203154316774.png)

## 思路

首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组中得到的左右子树的长度，反过来在切后序数组【因为二叉树中某个节点的左子树的个数无论在那种遍历方式中都是不变的，并且该节点的左右子在遍历结果中不会交叉，而是成块的分成三部分，例如：后序遍历的结果中分为——>(数根结点的左子树、树根节点的右子树、树根节点)】，所以可以根据在中序遍历中得到的左右子树的长度将后续遍历的结果分成三部分，并且无论在那种遍历顺序中左子树的部分一定在右子树部分之前。一层一层切下去，每次后序数组最后一个元素就是节点元素。

如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。

流程如图：

![106.从中序与后序遍历序列构造二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210203154249860.png)

那么代码应该怎么写呢？

说到一层一层切割，就应该想到了递归。

来看一下一共分几步：

- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：根据切割中序遍历得到的结果（左右子树的节点个数），去切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

不难写出如下代码：（先把框架写出来）

```cpp
TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {

    // 第一步
    if (postorder.size() == 0) return NULL;

    // 第二步：后序遍历数组最后一个元素，就是当前的中间节点
    int rootValue = postorder[postorder.size() - 1];
    TreeNode* root = new TreeNode(rootValue);

    // 叶子节点
    if (postorder.size() == 1) return root;

    // 第三步：找切割点
    int delimiterIndex;
    for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
        if (inorder[delimiterIndex] == rootValue) break;
    }

    // 第四步：切割中序数组，得到 中序左数组和中序右数组
    // 第五步：切割后序数组，得到 后序左数组和后序右数组

    // 第六步
    root->left = traversal(中序左数组, 后序左数组);
    root->right = traversal(中序右数组, 后序右数组);

    return root;
}
```

**难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。**

此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。

**在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！**

我在[数组：每次遇到二分法，都是一看就会，一写就废 (opens new window)](https://programmercarl.com/0035.搜索插入位置.html)和[数组：这个循环可以转懵很多人！ (opens new window)](https://programmercarl.com/0059.螺旋矩阵II.html)中都强调过循环不变量的重要性，在二分查找以及螺旋矩阵的求解中，坚持循环不变量非常重要，本题也是。

首先要切割中序数组，为什么先切割中序数组呢？

切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。

中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：

```cpp
// 找到中序遍历的切割点
int delimiterIndex;
for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
    if (inorder[delimiterIndex] == rootValue) break;
}

// 左闭右开区间：[0, delimiterIndex)
vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
// [delimiterIndex + 1, end)
vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );
```

接下来就要切割后序数组了。

首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。

后序数组的切割点怎么找？

后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。

**此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。**

中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。

代码如下：

```cpp
// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了
postorder.resize(postorder.size() - 1);

// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
// [leftInorder.size(), end)
vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());
```



此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。

接下来可以递归了，代码如下：

```cpp
root->left = traversal(leftInorder, leftPostorder);
root->right = traversal(rightInorder, rightPostorder);
```

完整代码如下：

```
c++版我省略了
```

我的代码：（时间复杂度较高，只领先了15%）

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {

    if(postorder.length == 0) return null;
    //用来保存本次递归中的子树的根节点
    TreeNode treeNode = new TreeNode();

    //当后序遍历的结果中只有一个元素的时候有两个时间点
    //  1.这个方法刚开始执行的时候
    //  2.参数中传递进来的postorder是完整的后序遍历结果的一部分，并且这一部分
    //  也要迭代结束了，这时inorder中一定也只有一个元素
    if(postorder.length == 1)
    {
        treeNode.val = postorder[0];
        return treeNode;
    }


    int rootVal = postorder[postorder.length-1];
    int rootIndex=0;
    //计算当前递归的节点作为根节点在中序遍历结果的数组中的位置
    //        for(int i = 0;i < inorder.length;i++){
    //            if(rootVal == inorder[i])
    //            {
    //                rootIndex = i;
    //                break;
    //            }
    //        }
    for(rootIndex = 0;rootIndex < inorder.length;rootIndex++){
        if(rootVal == inorder[rootIndex]) break;
    }
    
    //计算本次递归中的中序遍历结果中根节点左侧的数组,左闭右开
    int[] inleft = Arrays.copyOfRange(inorder,0,rootIndex);
    //计算本次递归中的中序遍历结果中根节点右侧的数组
    int[] inright = Arrays.copyOfRange(inorder,rootIndex+1 > inorder.length ? inorder.length : rootIndex+1 ,inorder.length);

    //计算本次递归中后的后序遍历结果中与left长度相等数组(也就是以postorder[postorder.length-1]为根的左子树)
    int[] postleft = Arrays.copyOfRange(postorder,0,rootIndex);
    //计算本次递归中的中序遍历结果中根节点右侧的数组
    int[] postright = Arrays.copyOfRange(postorder,rootIndex,postorder.length-1);

    treeNode.val = rootVal;
    treeNode.left = buildTree(inleft,postleft);
    treeNode.right = buildTree(inright,postright);
    return treeNode;
}
```

## 拓展：从前序与中序遍历序列构造二叉树

### 描述

根据一棵树的前序遍历与中序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：

![105. 从前序与中序遍历序列构造二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210203154626672.png)

### 思路

参考中序+后序构建二叉树

```java
/**
没有修改注释
*/
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if(preorder.length == 0) return null;
    //用来保存本次递归中的子树的根节点
    TreeNode treeNode = new TreeNode();

    //当后序遍历的结果中只有一个元素的时候有两个时间点
    //  1.这个方法刚开始执行的时候
    //  2.参数中传递进来的postorder是完整的后序遍历结果的一部分，并且这一部分
    //  也要迭代结束了，这时inorder中一定也只有一个元素
    if(preorder.length == 1)
    {
        treeNode.val = preorder[0];
        return treeNode;
    }

    int rootVal = preorder[0];
    int rootIndex=0;
    //计算当前递归的节点作为根节点在中序遍历结果的数组中的位置
    for(int i = 0;i < inorder.length;i++){
        if(rootVal == inorder[i])
        {
            rootIndex = i;
            break;
        }
    }
    //        for(rootIndex = 0;rootIndex < inorder.length;rootIndex++){
    //            if(rootVal == inorder[rootIndex]) break;
    //        }
    //计算本次递归中的中序遍历结果中根节点左侧的数组,左闭右开
    int[] inleft = Arrays.copyOfRange(inorder,0,rootIndex);
    //计算本次递归中的中序遍历结果中根节点右侧的数组
    int[] inright = Arrays.copyOfRange(inorder,rootIndex+1 > inorder.length ? inorder.length : rootIndex+1 ,inorder.length);

    //计算本次递归中后的后序遍历结果中与left长度相等数组(也就是以postorder[preorder.length-1]为根的左子树)
    int[] preleft = new int[0];
    preleft = Arrays.copyOfRange(preorder,1,1+rootIndex);
    //计算本次递归中的中序遍历结果中根节点右侧的数组
    int[] preright = Arrays.copyOfRange(preorder,rootIndex+1,preorder.length);

    treeNode.val = rootVal;
    treeNode.left = buildTree(preleft,inleft);
    treeNode.right = buildTree(preright,inright);
    return treeNode;
}
```



## 总结

前序和中序可以唯一确定一棵二叉树。

后序和中序可以唯一确定一棵二叉树。

那么前序和后序可不可以唯一确定一棵二叉树呢？

**前序和后序不能唯一确定一棵二叉树！**，因为没有中序遍历无法确定左右部分，也就是无法分割。

# 5、最大二叉树

## 描述

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

示例 ：

![654.最大二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\20210204154534796.png)

提示：

给定的数组的大小在 [1, 1000] 之间。

## 思路

思路中构建二叉树的过程中使用的是  左闭右开区  间，我试着用左闭右闭区间来做，但是写出来的代码有问题，因为是两侧都闭，那么会导致两个问题：1. 数组下标越界；2. 处理完越界问题之后会导致边界值在两次递归中重复被使用，例如：范围0~2区间上的数组最大的值是3，也就是索引0对应的值，但是这样存在的问题是——>以3为根节点的时候，3的左子树应该是我没有的，但是当我为了处理下表越界问题而做出修改之后，会导致3的左子树对应的数组是[3]，这样本来没有左子树的节点有了左子树；
想要更正我的思路中的这两个问题比较费事，主要原因在于：没有办法确定当数组的左右指针指向什么的时候返回空节点，什么时候返回一个节点；因为我是用的是左闭右闭区间，一定会导致左右指针指向数组中同一个元素，这个时候没有办法明确此时应该返回null还是一个空节点。

最大二叉树的构建过程如下：

![654.最大二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-3\008eGmZEly1gnbjuvioezg30dw0921ck.gif)

<font color = "red">**<u>*构造树一般采用的是前序遍历*</u>**</font>，因为先构造中间节点，然后递归构造左子树和右子树。

1. 确定递归函数的参数和返回值

参数就是传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。

代码如下：

```cpp
TreeNode* constructMaximumBinaryTree(vector<int>& nums)
```

2. 确定终止条件

题目中说了输入的数组大小一定是大于等于1的，所以我们不用考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。

那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。

代码如下：

```cpp
TreeNode* node = new TreeNode(0);
if (nums.size() == 1) {
    node->val = nums[0];
    return node;
```

3. 确定单层递归的逻辑

   这里有三步工作

   1. 先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。

      代码如下：

      ```C++
      int maxValue = 0;
      int maxValueIndex = 0;
      for (int i = 0; i < nums.size(); i++) {
          if (nums[i] > maxValue) {
              maxValue = nums[i];
              maxValueIndex = i;
          }
      }
      TreeNode* node = new TreeNode(0);
      node->val = maxValue;
      ```

   2. 最大值所在的下标左区间构造左子树这里要判断maxValueIndex > 0，因为要保证左区间至少有一个数值。

      代码如下：

      ```c++
      if (maxValueIndex > 0) {
          vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
          node->left = constructMaximumBinaryTree(newVec);
      }
      ```

   3. 最大值所在的下标右区间 构造右子树

      判断maxValueIndex < (nums.size() - 1)，确保右区间至少有一个数值。

      代码如下：

      ```c++
      if (maxValueIndex < (nums.size() - 1)) {
          vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
          node->right = constructMaximumBinaryTree(newVec);
      }
      ```

      这样我们就分析完了，整体代码如下：（详细注释）

      ```cpp
      class Solution {
      public:
          TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
              TreeNode* node = new TreeNode(0);
              if (nums.size() == 1) {
                  node->val = nums[0];
                  return node;
              }
              // 找到数组中最大的值和对应的下标
              int maxValue = 0;
              int maxValueIndex = 0;
              for (int i = 0; i < nums.size(); i++) {
                  if (nums[i] > maxValue) {
                      maxValue = nums[i];
                      maxValueIndex = i;
                  }
              }
              node->val = maxValue;
              // 最大值所在的下标左区间 构造左子树
              //注意这里传递的是数组，而不是索引，所以可以用索引0来判断
              if (maxValueIndex > 0) {
                  vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
                  node->left = constructMaximumBinaryTree(newVec);
              }
              // 最大值所在的下标右区间 构造右子树
              //注意这里传递的是数组，而不是索引，所以可以用最大索引来判断
              if (maxValueIndex < (nums.size() - 1)) {
                  vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
                  node->right = constructMaximumBinaryTree(newVec);
              }
              return node;
          }
      };
      ```

   以上代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的vector（也就是数组），但逻辑比较清晰。

   和文章[二叉树：构造二叉树登场！ (opens new window)](https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html)中一样的优化思路，就是每次分隔不用定义新的数组，而是通过下标索引直接在原数组上操作。

   优化后代码如下：

   ```cpp
   class Solution {
   private:
       // 在左闭右开区间[left, right)，构造二叉树
       TreeNode* traversal(vector<int>& nums, int left, int right) {
   		//因为是左闭右开，所以当left == right的时候代表
           //该数组为空，需要返回null。
           if (left >= right) return nullptr;
   
           // 分割点下标：maxValueIndex
           int maxValueIndex = left;
           for (int i = left + 1; i < right; ++i) {
               if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
           }
   
           TreeNode* root = new TreeNode(nums[maxValueIndex]);
   
           // 左闭右开：[left, maxValueIndex)
           root->left = traversal(nums, left, maxValueIndex);
   
           // 左闭右开：[maxValueIndex + 1, right)
           root->right = traversal(nums, maxValueIndex + 1, right);
   
           return root;
       }
   public:
       TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
           return traversal(nums, 0, nums.size());
       }
   };
   ```

可以发现上面的优化后的代码看上去简洁一些，**主要是因为第二版其实是允许空节点进入递归，所以不用在递归的时候加判断节点是否为空**

第一版递归过程：（加了if判断，为了不让空节点进入递归）

```cpp
if (maxValueIndex > 0) { // 这里加了判断是为了不让空节点进入递归
    vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);
    node->left = constructMaximumBinaryTree(newVec);
}

if (maxValueIndex < (nums.size() - 1)) { // 这里加了判断是为了不让空节点进入递归
    vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());
    node->right = constructMaximumBinaryTree(newVec);
}
```

第二版递归过程： （如下代码就没有加if判断）

```c++
root->left = traversal(nums, left, maxValueIndex);

root->right = traversal(nums, maxValueIndex + 1, right);
```

**注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。**

一些同学也会疑惑，什么时候递归函数前面加if，什么时候不加if，这个问题我在最后也给出了解释。

其实就是不同代码风格的实现，**一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。**

我的代码：

```java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    TreeNode test = test(nums,0, nums.length);
    return test;
}

public TreeNode test(int[] nums,int start,int end){
    //因是左闭右开，所以当start == end的时候代表空数组
    //所以会返回null。
    if(end - start <= 0) return null;

    TreeNode node = new TreeNode();
    //因为是左闭右开，所以当end-start=1的时候就代表数组中
    //只有一个元素，这个时候就可以构建一个TreeNode，val为该
    //元素的值。
    if(end - start == 1)
    {
        node.val = nums[start];
        return node;
    }
    
    //查找在nums中范围在 [start~end) 之间的元素的最大值。
    int maxVal = -1;
    int maxIndex = 0;
    for(int i = start;i < end;i++){
        if(nums[i] > maxVal)
        {
            maxIndex = i;
            maxVal = nums[i];
        }
    }

    node.val = maxVal;						//中
    node.left = test(nums,start,maxIndex);	//左
    node.right = test(nums,maxIndex+1,end);	//右
    return node;
}
```

# 6、总结

在[二叉树：以为使用了递归，其实还隐藏着回溯 (opens new window)](https://programmercarl.com/二叉树中递归带着回溯.html)中，通过leetcode [257.二叉树的所有路径这道题目 (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)，讲解了递归如何隐藏着回溯，一些代码会把回溯的过程都隐藏了起来了，甚至刷过这道题的同学可能都不知道自己用了回溯。

文章中第一版代码把每一个细节都展示了输出来了，大家可以清晰的看到回溯的过程。

然后给出了第二版优化后的代码，分析了其回溯隐藏在了哪里，如果要把这个回溯扣出来的话，在第二版的基础上应该怎么改。

主要需要理解：**回溯隐藏在traversal(cur->left, path + "->", result);中的 path + "->"。 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了。**





在文章[二叉树：做了这么多题目了，我的左叶子之和是多少？ (opens new window)](https://programmercarl.com/0404.左叶子之和.html)中提供了另一个判断节点属性的思路，平时我们习惯了使用通过节点的左右孩子判断本节点的属性，但发现使用这个思路无法判断左叶子。

此时需要相连的三层之间构成的约束条件，也就是要通过节点的父节点以及孩子节点来判断本节点的属性。

这道题目可以扩展大家对二叉树的解题思路。





在[二叉树：我的左下角的值是多少？ (opens new window)](https://programmercarl.com/0513.找树左下角的值.html)中的题目如果使用递归的写法还是有点难度的，层次遍历反而很简单。

题目其实就是要在树的**最后一行**找到**最左边的值**。

**如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。**

在这篇文章中，我们使用递归算法实实在在的求了一次深度，然后使用靠左的遍历，保证求得靠左的最大深度，而且又一次使用了回溯。

如果对二叉树的高度与深度又有点模糊了，在看这里[二叉树：我平衡么？ (opens new window)](https://programmercarl.com/0110.平衡二叉树.html)，回忆一下吧。

[二叉树：我的左下角的值是多少？ (opens new window)](https://programmercarl.com/0513.找树左下角的值.html)中把我们之前讲过的内容都过了一遍，此外，还用前序遍历的技巧求得了靠左的最大深度。

**求二叉树的各种最值，就想应该采用什么样的遍历顺序，确定了遍历循序，其实就和数组求最值一样容易了。**







在[二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ (opens new window)](https://programmercarl.com/0112.路径总和.html)中通过两道题目，彻底说清楚递归函数的返回值问题。

一般情况下：**如果需要搜索整棵二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。**

特别是有些时候 递归函数的返回值是bool类型，一些同学会疑惑为啥要加这个，其实就是为了找到一条边立刻返回。

其实还有一种就是后序遍历需要根据左右递归的返回值推出中间节点的状态，这种需要有返回值，例如[222.完全二叉树 (opens new window)](https://programmercarl.com/0222.完全二叉树的节点个数.html)，[110.平衡二叉树 (opens new window)](https://programmercarl.com/0110.平衡二叉树.html)，这几道我们之前也讲过。





------

之前都是讲解遍历二叉树，这次该构造二叉树了，在[二叉树：构造二叉树登场！ (opens new window)](https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html)中，我们通过前序和中序，后序和中序，构造了唯一的一棵二叉树。

**构造二叉树有三个注意的点：**

- 分割时候，坚持区间不变量原则，左闭右开，或者左闭右闭。
- 分割的时候，注意后序 或者 前序已经有一个节点作为中间节点了，不能继续使用了。
- 如何使用切割后的后序数组来切合中序数组？利用中序数组大小一定是和后序数组的大小相同这一特点来进行切割。

这道题目代码实现并不简单，大家啃下来之后，二叉树的构造应该不是问题了。

**最后我还给出了为什么前序和后序不能唯一构成一棵二叉树，因为没有中序遍历就无法确定左右部分，也就无法分割。**







知道了如何构造二叉树，那么使用一个套路就可以解决文章[二叉树：构造一棵最大的二叉树 (opens new window)](https://programmercarl.com/0654.最大二叉树.html)中的问题。

**注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。**

文章中我还给出了递归函数什么时候加if，什么时候不加if，其实就是控制空节点（空指针）是否进入递归，是不同的代码实现方式，都是可以的。

**一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。**



[^水平分割线中的内容介绍了怎么使用前序遍历的方式构建一颗二叉树]: 

------

