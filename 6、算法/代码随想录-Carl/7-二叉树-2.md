# 1、对称二叉树

## 描述

给定一个二叉树，检查它是否是镜像对称的。

![101. 对称二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203144607387.png)

## 思路

《代码随想录》算法视频公开课：[同时操作两个二叉树 | LeetCode：101. 对称二叉树 (opens new window)](https://www.bilibili.com/video/BV1ue4y1Y7Mf)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

**首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！**

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

那么如果比较呢？

比较的是两个子树的里侧和外侧的元素是否相等。如图所示：

![101. 对称二叉树1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203144624414.png)

那么遍历的顺序应该是什么样的呢？

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等【比如于阶乘的计算：7！，需要先计算出1！之后才能计算出2！以此类推才能计算出来7！】。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**

但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。

其实后序也可以理解为是一种回溯，当然这是题外话，讲回溯的时候会重点讲的。

说到这大家可能感觉我有点啰嗦，哪有这么多道理，上来就干就完事了。别急，我说的这些在下面的代码讲解中都有身影。

那么我们先来看看递归法的代码应该怎么写。

## 方法一：递归法

递归三部曲

1. 确定递归函数的参数和返回值

因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

返回值自然是bool类型。

代码如下：

```java
bool compare(TreeNode left, TreeNode right)
```

2. 确定终止条件

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

- 左节点为空，右节点不为空，不对称，return false
- 左不为空，右为空，不对称 return false
- 左右都为空，对称，返回true

此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

- 左右都不为空，比较节点数值，不相同就return false

此时左右节点不为空，且数值也不相同的情况我们也处理了。

代码如下：

```java
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left.val != right.val) return false; // 注意这里我没有使用else
```

注意上面最后一种情况，我没有使用else，而是elseif， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。

3. 确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较内测是否对称，传入左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

代码如下：

```java
bool outside = compare(left.left, right.right);   // 左子树：左、 右子树：右
bool inside = compare(left.right, right.left);    // 左子树：右、 右子树：左
bool isSame = outside && inside;                    // 左子树：中、 右子树：中（逻辑处理）
return isSame;
```

如上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。

最后的代码如下：

```java
public boolean isSymmetric1(TreeNode root) {
    return compare(root.left, root.right);
}

public boolean compare(TreeNode left,TreeNode right)
{
    /**
    if (left == null && right != null) {
        return false;
    }
    if (left != null && right == null) {
        return false;
    }

    if (left == null && right == null) {
        return true;
    }
    if (left.val != right.val) {
        return false;
    }
    */
    
    //上面注释代码的精简版
    if(left == null)
        //如果为null则证明这两个节点都是空节点，已经递归到二叉树最后一层
        if(right == null) return true;
	    else return false;
    else
        if(right == null) return false;
	    else if(left.val != right.val) return false;

    //上面哪个条件中如果没有返回的话意味着当前迭代中的两个节点都不是null
    //并且这两个节点的值相等，这个时候想要判断这两个接待你是否相等就需要
    //先根据这两个节点的左右子树是否对称，如果对称则返回true，否则返回false；
    boolean b1 = compare(left.left,right.right);
    boolean b2 = compare(left.right,right.left);
    return b1 && b2;
}
```

## 方法二：迭代法

这道题目我们也可以使用迭代法，但要注意，这里的迭代法可不是前中后序的迭代写法，因为本题的本质是判断两个树是否是相互翻转的，其实已经不是所谓二叉树遍历的前中后序的关系了。

这里我们可以使用队列来比较两个树（根节点的左右子树）是否相互翻转，（**注意这不是层序遍历**）

### 使用队列

通过队列来判断根节点的左子树和右子树的内侧和外侧是否相等，如动画所示：

![101.对称二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\008eGmZEly1gnwcimlj8lg30hm0bqnpd.gif)

如下的条件判断和递归的逻辑是一样的。

代码如下：

```java
//队尾部进节点，队列头部出节点
public boolean isSymmetric3(TreeNode root) {
    Queue<TreeNode> deque = new LinkedList<>();
    deque.offer(root.left);
    deque.offer(root.right);
    while (!deque.isEmpty()) {
        TreeNode leftNode = deque.poll();
        TreeNode rightNode = deque.poll();
        if (leftNode == null && rightNode == null) {
            continue;
        }
        //            if (leftNode == null && rightNode != null) {
        //                return false;
        //            }
        //            if (leftNode != null && rightNode == null) {
        //                return false;
        //            }
        //            if (leftNode.val != rightNode.val) {
        //                return false;
        //            }
        // 以上三个判断条件合并
        if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
            return false;
        }
        // 这里顺序与使用Deque不同
        deque.offer(leftNode.left);
        deque.offer(rightNode.right);
        deque.offer(leftNode.right);
        deque.offer(rightNode.left);
    }
    return true;
}
```



### 使用栈

细心的话，其实可以发现，这个迭代法，其实是把左右两个子树要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较，那么其实使用栈也是可以的。

只要把队列原封不动的改成栈就可以了，我下面也给出了代码。

```c++
/**
c++的代码，本质上和队列的方式是一样的
*/
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        stack<TreeNode*> st; // 这里改成了栈
        st.push(root->left);
        st.push(root->right);
        while (!st.empty()) {
            TreeNode* leftNode = st.top(); st.pop();
            TreeNode* rightNode = st.top(); st.pop();
            if (!leftNode && !rightNode) {
                continue;
            }
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            st.push(leftNode->left);
            st.push(rightNode->right);
            st.push(leftNode->right);
            st.push(rightNode->left);
        }
        return true;
    }
};
```

# 2、二叉树的最大深度

## 描述



给定一个二叉树，找出其最大深度。

二叉树的最大深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例： 给定二叉树 [3,9,20,null,null,15,7]，

![104. 二叉树的最大深度](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203153031914.png)

返回它的最大深度 3 。

## 思路

看完本篇可以一起做了如下两道题目：

- 104.二叉树的最大深度
- 559.n叉树的最大深度

《代码随想录》算法视频公开课：[二叉树的高度和深度有啥区别？究竟用什么遍历顺序？很多录友搞不懂 | 104.二叉树的最大深度 (opens new window)](https://www.bilibili.com/video/BV1Gd4y1V75u)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

## 名词简介：

- 二叉树节点的深度：指<font color = "red">***从该节点到根节点的最长简单路径边的条数或者节点数***</font>（取决于深度从0开始还是从1开始，也就是根节点的深度是0还是1，这个取值没有多大的关系）
  - 可以使用前序遍历的方式求深度
  - 当求二叉树中的最大深度的时候，由于在二叉树中所有节点到根节点的最大深度等价于从根节点到所有叶子节点的最大高度，所以可以使用后序遍历的方式求根节点的最大高度，也就求出了从二叉树中所有节点到根节点的最大深度。
- 二叉树节点的高度：指<font color = "red">***从该节点到叶子节点的最长简单路径边的条数后者节点数***</font>（取决于深度从0开始还是从1开始，也就是叶子节点的高度是0还是1，这个取值没有多大的关系）
  - 可以使用后序遍历的方式求高度
- 最大深度 == 最大高度：二叉树中从根节点到最远叶子节点的路径上的节点数
- 最小深度 == 最小高度：二叉树中从根节点到最近叶子节点的路径上的节点数



## 方法一：递归法

### 1、后序遍历

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。

**根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

这一点其实是很多同学没有想清楚的，很多题解同样没有讲清楚。

我先用后序遍历（左右中）来计算树的高度。

1. 确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。

代码如下：

```java
int getdepth(Treenode node)
```

2. 确定终止条件：如果为空节点的话，就返回0，表示高度为0。

代码如下：

```java
if (node == NULL) return 0;
```

3. 确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。

代码如下：

```java
int leftdepth = getdepth(node.left);       // 左
int rightdepth = getdepth(node.right);     // 右
int depth = 1 + max(leftdepth, rightdepth); // 中
return depth;
```

所以整体Java代码如下：

```java
class solution {
    public int getdepth(treenode* node) {
        if(root == null) return 0;

        int leftdepth = isSymmetric1(root.left);	//左
        int rightdepth = isSymmetric1(root.right);	 //右
        int depth = Math.max(leftdepth,rightdepth) + 1;	//中
        return depth;
    }
};
```

### 2、前序遍历

在前序遍历中会用到回溯的内容（**充分表现出求深度回溯的过程**）

```c++
class solution {
public:
    
    //这个变量中始终保存的是当前节点的最大深度
    int result;
    
    //这个方法的第一个参数是本次递归的节点，第二个参数是这个节点的深度
    void getdepth(treenode* node, int depth) {
        result = depth > result ? depth : result; // 中

        if (node->left == NULL && node->right == NULL) return ;

        if (node->left) { // 左
            //加1是为当前节点的左孩子
            depth++;    // 深度+1
            
            //递归调用getdepth方法的时候，传递的参数是本递归中
            //当前节点的左孩子，第二个参数是当前节点左孩子的深度
            getdepth(node->left, depth);
            
            //因为当前节点的深度不会随着递归的调用而增加
            depth--;    // 回溯，深度-1
        }
        if (node->right) { // 右
            //加1是为当前节点的右孩子
            depth++;    // 深度+1
            
            //递归调用getdepth方法的时候，传递的参数是本递归中
            //当前节点的右孩子，第二个参数是当前节点右孩子的深度
            getdepth(node->right, depth);
            depth--;    // 回溯，深度-1
        }
        return ;
    }
    int maxdepth(treenode* root) {
        result = 0;
        if (root == NULL) return result;
        
        getdepth(root, 1);
        return result;
    }
};
```

**可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！**

## 方法二：迭代法

使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。

在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：

![层序遍历](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20200810193056585.png)

所以这道题的迭代法就是一道模板题，可以使用二叉树层序遍历的模板来解决的。

如果对层序遍历还不清楚的话，可以看这篇：[二叉树：层序遍历登场！](https://programmercarl.com/0102.二叉树的层序遍历.html)

```java
class solution {
    /**
     * 迭代法，使用层序遍历
     */
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return depth;
    }
}
```



## 拓展 559.n叉树的最大深度

[力扣题目链接(opens new window)](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

给定一个 n 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

例如，给定一个 3叉树 :

![559.n叉树的最大深度](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\2021020315313214.png)

我们应返回其最大深度，3。

### 思路

依然可以提供递归法和迭代法，来解决这个问题，思路是和二叉树思路一样的，直接给出代码如下：

### 方法一：递归法

```java
class solution {
    /**
     * 递归法
     */
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

方法二：迭代法

```java
class solution {
    /**
     * 迭代法，使用层序遍历
     */
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return depth;
    }
}
```

# 3、二叉树的最小深度

## 描述

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

![111.二叉树的最小深度1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\2021020315582586.png)

返回它的最小深度 2.

## 思路

《代码随想录》算法视频公开课：[看起来好像做过，一写就错！ | LeetCode：111.二叉树的最小深度 (opens new window)](https://www.bilibili.com/video/BV1QD4y1B7e2)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

看完了这篇[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)，再来看看如何求最小深度。

直觉上好像和求最大深度差不多，其实还是差不少的（因为求最大深度的时候，如果直接比较某节点左右子树递归后返回的值，可以保证最大的高度一定是从该节点到叶子节点的最大深度；但是求最小深度的时候，不能保证最小的高度一定是该节点到叶子节点的最小深度，因为有可能该节点只有一左子树，如果那么该节点的最小高度就是左子树的最小高度，而不是高度为0的右子树；具体可以看哪个图片中写有“最小深度不是1”的内容）。

本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。

1. 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
2. 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）

那么使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，这不过这个最小距离 也同样是最小深度。

以下讲解中遍历顺序上依然采用后序遍历（因为要比较递归返回之后的结果，本文我也给出前序遍历的写法）。

本题还有一个误区，在处理节点的过程中，最大深度很容易理解，最小深度就不那么好理解，如图：

![111.二叉树的最小深度](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203155800503.png)

这就重新审题了，题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**，注意是**叶子节点**。

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

## 方法一：递归法

### 1、后序遍历

来来来，一起递归三部曲：

1. 确定递归函数的参数和返回值

参数为要传入的二叉树根节点，返回的是int类型的深度。

代码如下：

```java
int getDepth(TreeNode node)
```

2. 确定终止条件

终止条件也是遇到空节点返回0，表示当前节点的高度为0。

代码如下：

```java
if (node == NULL) return 0;
```

3. 确定单层递归的逻辑

这块和求最大深度可就不一样了，一些同学可能会写如下代码：

```java
int leftDepth = getDepth(node.left);
int rightDepth = getDepth(node.right);
int result = 1 + min(leftDepth, rightDepth);
return result;
```



这个代码就犯了此图中的误区：

![111.二叉树的最小深度](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203155800503.png)

如果这么求的话，没有左孩子的分支会算为最短深度。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

代码如下：

```java
int leftDepth = getDepth(node.left); // 左
int rightDepth = getDepth(node->right);// 右 

// 中
// 当一个左子树为空，右不为空，这时并不是最低点
if (node.left == NULL && node.right != NULL) { 
    return 1 + rightDepth;
}   
// 当一个右子树为空，左不为空，这时并不是最低点
if (node.left != NULL && node.right == NULL) { 
    return 1 + leftDepth;
}
int result = 1 + min(leftDepth, rightDepth);
return result;
```



遍历的顺序为后序（左右中），可以看出：**求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。**

整体递归代码如下：

```java
class Solution {
    /**
     * 递归法，相比求MaxDepth要复杂点
     * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
     */
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);
        if (root.left == null) {
            return rightDepth + 1;
        }
        if (root.right == null) {
            return leftDepth + 1;
        }
        // 左右结点都不为null
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```



### 2、前序遍历

代码随想录中只有c++版的前序遍历，在前序遍历的时候会用到回溯的内容

## 方法二、迭代法

相对于[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)，本题还可以使用层序遍历的方式来解决，思路是一样的。

如果对层序遍历还不清楚的话，可以看这篇：[二叉树：层序遍历登场！(opens new window)](https://programmercarl.com/0102.二叉树的层序遍历.html)

**需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

代码如下：（详细注释）

```java
class Solution {
    /**
     * 迭代法，层序遍历
     */
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            //记录深度，也就是当前循环的是二叉树的第几层
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                if (poll.left == null && poll.right == null) {
                    // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值
                    return depth;
                }
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```



# 4、完全二叉树的节点个数

## 描述

给出一个完全二叉树，求出该树的节点个数。

示例 1：

- 输入：root = [1,2,3,4,5,6]
- 输出：6

示例 2：

- 输入：root = []
- 输出：0

示例 3：

- 输入：root = [1]
- 输出：1

提示：

- 树中节点的数目范围是[0, 5 * 10^4]
- 0 <= Node.val <= 5 * 10^4
- 题目数据保证输入的树是 完全二叉树

## 思路

《代码随想录》算法视频公开课：[要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量 (opens new window)](https://www.bilibili.com/video/BV1eW4y1B7pD)，相信结合视频在看本篇题解，更有助于大家对本题的理解。

本篇给出按照普通二叉树的求法以及利用完全二叉树性质的求法。

## 普通二叉树

首先按照普通二叉树的逻辑来求。

这道题目的递归法和求二叉树的深度写法类似， 而迭代法，[二叉树：层序遍历登场！ (opens new window)](https://programmercarl.com/0102.二叉树的层序遍历.html)遍历模板稍稍修改一下，记录遍历的节点数量就可以了。

递归遍历的顺序依然是后序（左右中）。

### 递归

如果对求二叉树深度还不熟悉的话，看这篇：[二叉树：看看这些树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)。

1. 确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。

代码如下：

```java
int getNodesNum(TreeNode cur) {
```

2. 确定终止条件：如果为空节点的话，就返回0，表示节点数为0。

代码如下：

```java
if (cur == NULL) return 0;
```

3. 确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。

代码如下：

```java
int leftNum = getNodesNum(cur.left);      // 左
int rightNum = getNodesNum(cur.right);    // 右
int treeNum = leftNum + rightNum + 1;      // 中
return treeNum;
```



所以整体Java代码如下：

```java
// 版本一
class Solution {
private:
    int getNodesNum(TreeNode cur) {
        if (cur == NULL) return 0;
        int leftNum = getNodesNum(cur.left);      // 左
        int rightNum = getNodesNum(cur.right);    // 右
        int treeNum = leftNum + rightNum + 1;      // 中
        return treeNum;
    }
public:
    int countNodes(TreeNode root) {
        return getNodesNum(root);
    }
};
```

```Java
//精简代码如下：
// 版本二
class Solution {
public:
    int countNodes(TreeNode root) {
        if (root == NULL) return 0;
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
};
```



- 时间复杂度：O(n)
- 空间复杂度：O(log n)，算上了递归系统栈占用的空间

### 迭代法

```java
class Solution {
    // 迭代法
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int result = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size -- > 0) {
                TreeNode cur = queue.poll();
                result++;
                if (cur.left != null) queue.offer(cur.left);
                if (cur.right != null) queue.offer(cur.right);
            }
        }
        return result;
    }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

## 完全二叉树

以上方法都是按照普通二叉树来做的，对于完全二叉树特性不了解的同学可以看这篇 [关于二叉树，你该了解这些！ (opens new window)](https://programmercarl.com/二叉树理论基础.html)，这篇详细介绍了各种二叉树的特性。

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

**大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。**

我来举一个典型的例子如题：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20200920221638903.png)

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

完全二叉树（一）如图： ![222.完全二叉树的节点个数](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20201124092543662.png)

完全二叉树（二）如图： ![222.完全二叉树的节点个数1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20201124092634138.png)

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

这里关键在于如何去判断一个左子树或者右子树是不是满二叉树呢？

在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。如图：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20220829163554.png)

在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树，如图：

![img](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20220829163709.png)

判断其子树是不是满二叉树，如果是则利用用公式计算这个子树（满二叉树）的节点数量，如果不是则继续递归，那么在递归三部曲中，第二部：终止条件的写法应该是这样的：

```java
if (root == null) return 0; 
// 开始根据左深度和右深度是否相同来判断该子树是不是满二叉树
TreeNode left = root.left;
TreeNode right = root.right;
int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
while (left) {  // 求左子树深度
    left = left.left;
    leftDepth++;
}
while (right) { // 求右子树深度
    right = right.right;
    rightDepth++;
}
if (leftDepth == rightDepth) {
    return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，返回满足满二叉树的子树节点数量
}
```



递归三部曲，第三部，单层递归的逻辑：（可以看出使用后序遍历）

```java
int leftTreeNum = countNodes(root.left);       // 左
int rightTreeNum = countNodes(root.right);     // 右
int result = leftTreeNum + rightTreeNum + 1;    // 中
return result;
```



该部分精简之后代码为：

```java
return countNodes(root.left) + countNodes(root.right) + 1; 
```



最后整体Java代码如下：

```java
class Solution {
    /**
     * 针对完全二叉树的解法
     *
     * 满二叉树的结点数为：2^depth - 1
     */
    public int countNodes(TreeNode root) {
        if (root == nullptr) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left.left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right.right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        //如果以root为根节点的树不是满二叉树，那么就以递归的方式分别求root节点的左右子树的节点树
        int leftCount = countNodes(root.left);
        int rightCount = countNodes(root.right);
        return rightCount + leftCount + 1;
    }
}
```

- 时间复杂度：O(log n × log n)
- 空间复杂度：O(log n)

# 5、平衡二叉树

## 描述

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度（指的是最大高度）差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

![110.平衡二叉树](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\2021020315542230.png)

返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

![110.平衡二叉树1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203155447919.png)

返回 false 。

**《代码随想录》算法视频公开课：[后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树 (opens new window)](https://www.bilibili.com/video/BV1Ug411S7my)，相信结合视频在看本篇题解，更有助于大家对本题的理解**。

## 题外话

咋眼一看这道题目和[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)很像，其实有很大区别。

这里强调一波概念：

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：

![110.平衡二叉树2](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210203155515650.png)

关于根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，leetcode的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0，我们暂时以leetcode为准（毕竟要在这上面刷题）。

因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）

有的同学一定疑惑，为什么[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)中求的是二叉树的最大深度，也用的是后序遍历。

**那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。**

在[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)中，如果真正求取二叉树的最大深度，C++代码应该写成如下：（前序遍历）

```c++
class Solution {
    public:
    int result;
    void getDepth(TreeNode* node, int depth) {
        result = depth > result ? depth : result; // 中

        if (node->left == NULL && node->right == NULL) return ;

        if (node->left) { // 左
            //这个条件中的三句话可以直接合成一句话，不知道为什么要这样写，并且他在精简代码中也是合并的形式
            depth++;    // 深度+1
            getDepth(node->left, depth);
            depth--;    // 回溯，深度-1
        }
        if (node->right) { // 右
            //这个条件中的三句话可以直接合成一句话，不知道为什么要这样写，并且他在精简代码中也是合并的形式
            depth++;    // 深度+1
            getDepth(node->right, depth);
            depth--;    // 回溯，深度-1
        }
        return ;
    }
    int maxDepth(TreeNode* root) {
        result = 0;
        if (root == NULL) return result;
        getDepth(root, 1);
        return result;
    }
};
```

## 思路

### 方法一：递归

此时大家应该明白了既然要求比较高度，必然是要后序遍历。

递归三步曲分析：

1. 明确递归函数的参数和返回值

参数：当前传入节点。
返回值：以当前传入节点为根节点的树的高度。

那么如何标记左右子树是否差值大于1呢？

如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。

所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

代码如下：

```java
// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
int getHeight(TreeNode node)
```

2. 明确终止条件

递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0

代码如下：

```java
if (node == NULL) {
    return 0;
}
```

3. 明确单层递归的逻辑

如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则则返回-1，表示已经不是二叉平衡树了。

伪代码如下：

```java
int leftHeight = getHeight(node.left); // 左
if (leftHeight == -1) return -1;
int rightHeight = getHeight(node.right); // 右
if (rightHeight == -1) return -1;

int result;
if (abs(leftHeight - rightHeight) > 1) {  // 中
    result = -1;
} else {
    result = 1 + Math.max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度
}
return result;
```



代码精简之后如下：

```java
int leftHeight = getHeight(node.left);
if (leftHeight == -1) return -1;
int rightHeight = getHeight(node.right);
if (rightHeight == -1) return -1;
return Math.abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
```

此时递归的函数就已经写出来了，这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，则返回-1。

getHeight整体代码如下：

```java
int getHeight(TreeNode node) {
    if (node == NULL) {
        return 0;
    }
    int leftHeight = getHeight(node.left);
    if (leftHeight == -1) return -1;
    int rightHeight = getHeight(node.right);
    if (rightHeight == -1) return -1;
    return Math.abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
}
```

最后本题整体递归代码如下：

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }

    private int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        // 左右子树高度差大于1，return -1表示已经不是平衡树了
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

### 方法二：迭代

在[104.二叉树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)中我们可以使用层序遍历来求深度，但是就不能直接用层序遍历来求高度了，这就体现出求高度和求深度的不同。

本题的迭代方式可以先定义一个函数，专门用来求高度。

这个函数通过栈模拟的后序遍历找每一个节点的高度（其实是通过求传入节点为根节点的最大深度来求的高度），然后用栈来模拟递归遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合。代码略，代码的时间复杂度为O(n^2)。

## 总结

当然此题用迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。

虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。

**例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！**

因为对于回溯算法已经是非常复杂的递归了，如果在用迭代的话，就是自己给自己找麻烦，效率也并不一定高。

通过本题可以了解求二叉树深度 和 二叉树高度的差异，求深度适合用前序遍历，而求高度适合用后序遍历。

# 6、二叉树的所有路径

## 描述

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例: ![257.二叉树的所有路径1](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\2021020415161576.png)

## 思路

**《代码随想录》算法视频公开课：[递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径 (opens new window)](https://www.bilibili.com/video/BV1ZG411G7Dh)，相信结合视频在看本篇题解，更有助于大家对本题的理解**。

这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。

在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。

前序遍历以及回溯的过程如图：

![257.二叉树的所有路径](D:\Tyora\AssociatedPicturesInTheArticles\7-二叉树-2\20210204151702443.png)

我们先使用递归的方式，来做前序遍历。**要知道递归和回溯就是一家的，本题也需要回溯。**

### 方法一：递归

1. 递归函数函数参数以及返回值

要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：

```java
void traversal(TreeNode root, LinkedList path, List result)
```

2. 确定递归终止条件

再写递归的时候都习惯了这么写：

```java
if (cur == NULL) {
    终止处理逻辑
}
```

但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。

**那么什么时候算是找到了叶子节点？** 是当 root不为空，其左右孩子都为空的时候，就找到叶子节点。

所以本题的终止条件是：

```java
if (cur.left == NULL && cur.right == NULL) {
    终止处理逻辑
}
```

为什么没有判断root是否为空呢，因为下面的逻辑可以控制空节点不入循环。

再来看一下终止处理的逻辑。

这里使用LinkedList 结构path来记录路径，所以要把LinkedList结构的path转为string格式，在把这个string 放进 result里。

**那么为什么使用了LinkedList 结构来记录路径呢？** 因为在下面处理单层递归逻辑的时候，要做回溯（弹栈）使用栈结构来做回溯。

可能有的同学问了，我看有些人的代码也没有回溯啊。

**其实是有回溯的，只不过隐藏在函数调用时的参数赋值里**，下文我还会提到。

这里我们先使用LinkedList结构的path容器来记录路径，那么终止处理逻辑如下：

```java
//判断当前元素是否是叶子节点，如果是的话，将栈中所有的元素放入
//结果数组中
if(root.left == null && root.right == null){
    StringBuilder item = new StringBuilder();
    for(int i = path.size()-1;i >= 0;i--){
        if(i != 0){
            item.append(path.get(i).val + "->");
        }else{
            item.append(path.get(i).val);
        }
    }
    result.add(item);
    return ;
}
```

3. 确定单层递归逻辑

因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中；也就是当前递归中的树的根节点入栈。

```java
path.push(root);
```

然后是递归和回溯的过程，上面说过没有判断root是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。

所以递归前要加上判断语句，下面要递归的节点是否为空，如下

```java
if (root->left) {
    traversal(cur.left, path, result);
}
if (root->right) {
    traversal(cur.right, path, result);
}
```

此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。

那么回溯要怎么回溯呢，一些同学会这么写，如下：

```cpp
if (root.left) {
    traversal(root.left, path, result);
}
if (root.right) {
    traversal(root.right, path, result);
}
path.pop();
```



这个回溯就要很大的问题，我们知道，**回溯和递归是一一对应的，有一个递归，就要有一个回溯**，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。

**所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！**

那么代码应该这么写：

```java
if (root.left) {
    traversal(root.left, path, result);
    path.pop();		//回溯
}
if (root.right) {
    traversal(root.right, path, result);
    path.pop();		//回溯
}
```

整体如下：

```java
public List<String> isSymmetric1(TreeNode root) {
    //用一个辅助数据结构 栈（用双链表来模拟） 来记录二叉树中
    //当前遍历所在的位置
    LinkedList<TreeNode> path = new LinkedList<TreeNode>();
    List<String> result = new ArrayList<>();
    if(root == null) return result;
    test(root,path,result);
    return result;
}

public void test(TreeNode root,LinkedList<TreeNode> path,List result){
    //在每次递归的时候都需要递归的当前元素入栈
    path.push(root);
    //判断当前元素是否是叶子节点，如果是的话，将栈中所有的元素放入
    //结果数组中
    if(root.left == null && root.right == null){
        StringBuilder item = new StringBuilder();
        for(int i = path.size()-1;i >= 0;i--){
            if(i != 0){
                item.append(path.get(i).val + "->");
            }else{
                item.append(path.get(i).val);
            }
        }
        result.add(item);
        return ;
    }
    if(root.left != null)
    {
        test(root.left,path,result);
        //回溯，因为当前节点的左孩子进入栈中，这个时候需要将左孩子弹栈，将右孩子入栈
        path.pop();

    }
    if(root.right != null)
    {
        test(root.right,path,result);
        //回溯，因为当前节点的左孩子进入栈中，这个时候需要将右孩子入栈，
        //并且将右孩子对应的路径存入数组中
        path.pop();
    }
}
```

代码随想录中精简版的我没有写，精简版主要也是为了体现出回溯的过程，但是我已经理解了，所以直接跳过了。

### 方法二：迭代

至于非递归的方式，我们可以依然可以使用前序遍历的迭代方式来模拟遍历路径的过程，对该迭代方式不了解的同学，可以看文章[二叉树：听说递归能做的，栈也能做！ (opens new window)](https://programmercarl.com/二叉树的迭代遍历.html)和[二叉树：前中后序迭代方式统一写法 (opens new window)](https://programmercarl.com/二叉树的统一迭代法.html)。

这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径。

```java
// 解法2
class Solution {
    /**
     * 迭代法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null)
            return result;
        Stack<Object> stack = new Stack<>();
        // 节点和路径同时入栈
        stack.push(root);
        stack.push(root.val + "");
        while (!stack.isEmpty()) {
            // 节点和路径同时出栈
            String path = (String) stack.pop();
            TreeNode node = (TreeNode) stack.pop();
            // 若找到叶子节点
            if (node.left == null && node.right == null) {
                result.add(path);
            }
            //右子节点不为空
            if (node.right != null) {
                stack.push(node.right);
                stack.push(path + "->" + node.right.val);
            }
            //左子节点不为空
            if (node.left != null) {
                stack.push(node.left);
                stack.push(path + "->" + node.left.val);
            }
        }
        return result;
    }
}
```

# 7、小总结

 [二叉树：我对称么？ (opens new window)](https://programmercarl.com/0101.对称二叉树.html)。

这道题目的本质是要比较两个树（这两个树是根节点的左右子树），遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。

而本题的迭代法中我们使用了队列，需要注意的是这不是层序遍历，而且仅仅通过一个容器来成对的存放我们要比较的元素，认识到这一点之后就发现：用队列，用栈，甚至用数组，都是可以的。

那么做完本题之后，在看如下两个题目。

- 100.相同的树
- 572.另一个树的子树

**[二叉树：我对称么？ (opens new window)](https://programmercarl.com/0101.对称二叉树.html)中的递归法和迭代法只需要稍作修改其中一个树的遍历顺序，便可刷了100.相同的树。**



------

在[二叉树：看看这些树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)中，我们讲解了如何求二叉树的最大深度。

本题可以使用前序，也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序呢求的是高度。

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度，所以[二叉树：看看这些树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)中使用的是后序遍历。









在[二叉树：看看这些树的最小深度 (opens new window)](https://programmercarl.com/0111.二叉树的最小深度.html)中，我们讲解如何求二叉树的最小深度， 这道题目要是稍不留心很容易犯错。

**注意这里最小深度是从根节点到最近叶子节点的最短路径上的节点数量。注意是叶子节点。**

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

**求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。**

注意到这一点之后 递归法和迭代法 都可以参照[二叉树：看看这些树的最大深度 (opens new window)](https://programmercarl.com/0104.二叉树的最大深度.html)写出来。







在[二叉树：我平衡么？ (opens new window)](https://programmercarl.com/0110.平衡二叉树.html)中讲解了如何判断二叉树是否是平衡二叉树

今天讲解一道判断平衡二叉树的题目，其实 方法上我们之前讲解深度的时候都讲过了，但是这次我们通过这道题目彻底搞清楚二叉树高度与深度的问题，以及对应的遍历方式。

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

**但leetcode中强调的深度和高度很明显是按照节点来计算的**。

关于根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，leetcode的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0，我们暂时以leetcode为准（毕竟要在这上面刷题）。

当然此题用迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。

虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。

**例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！**

讲了这么多二叉树题目的迭代法，有的同学会疑惑，迭代法中究竟什么时候用队列，什么时候用栈？

**如果是模拟前中后序遍历就用栈，如果是适合层序遍历就用队列，当然还是其他情况，那么就是 先用队列试试行不行，不行就用栈。**



<font color = "red">关于在分割线内的内容（二叉树的最大深度、最小深度、是否是平衡二叉树）中涉及到的某个节点的深度和高度，我有自己的理解；理解如下：</font>

1. <font color = "red">深度：从直观上来看深度的计算是从上到下的每递归一次深度就会加一（当然其中也伴随着回溯，但是我这里主要不是为了说清楚回溯）；所以使前序遍历，从根节点开始每递归一次深度就会加一，直到满足题目条件。</font>
2. <font color = "red">高度：从直观上来看高度的计算是从下到上的每递归一次高度就会加一（不考虑回溯）；所以使用后序遍历，从叶子节点开始每递归一次高度就会加一，直到满足题目条件。</font>

------





在[二叉树：找我的所有路径？ (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)中正式涉及到了回溯，很多同学过了这道题目，可能都不知道自己使用了回溯，其实回溯和递归都是相伴相生的。最后我依然给出了迭代法的版本。

我在题解中第一个版本的代码会把回溯的过程充分体现出来，如果大家直接看简洁的代码版本，很可能就会忽略的回溯的存在。

