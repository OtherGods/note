# 1、二分法详解与扩展

配套视频P3中1:32:07时间点开始介绍二分法

## 1、关键代码：

```java
/**
param：指定要查找的有序数组和要查找的指定值
*/
public static boolean exist(int[] sortedArr, int num) {
    if (sortedArr == null || sortedArr.length == 0) {
        return false;
    }
    int L = 0;
    int R = sortedArr.length - 1;
    int mid = 0;
    while (L < R) {
        //计算左右边界的中值
        mid = L + ((R - L) >> 1);

        //当中值指向的元素是指定要查找的元素的时候，就直接退出二分查找方法
        if (sortedArr[mid] == num) {
            return true;
        }
        //接下来的两个操作是在缩小查找的范围
        else if (sortedArr[mid] > num) {
            //当中值大于指定元素的时候，右边界就应该向左移动，将右边界指向中值指向的位置之前的位置
            R = mid - 1;
        } else {
            //当中值小于指定元素的时候，左边界就应该向右移动，将左边界指向中值指向的位置之后的位置
            L = mid + 1;
        }
    }
    return sortedArr[L] == num;
}
```



## 2、复杂度

时间复杂度O(log n)，额外空间复杂度O(1)



## 3、拓展



### 1、找指定位置

#### 1、问题描述

在一个有序数组中，找>=某个数最左侧的位置。

#### 2、分析

这个位置在下文中我统一称之为指定位置，例如：有数组{1,1,5,5,5,6,6,9,9,9,13,13,14}，有指定元素7，在这个数组中找到的指定位置是第一个9。示例数组如下图所示：

![image-20220915111913178](D:\Tyora\AssociatedPicturesInTheArticles\查找算法\image-20220915111913178.png)

1. 二分法扩展，还是找某个元素，但是这个元素是和一个范围挂钩的，也就是指定的这个元素是有相应位置的

2. 在有序数组中中值的位置符合条件指定的位置的时候不应该直接退出二分法，而是应该记录下这个找到的位置，继续下一次二分查找，因为可能符合条件的位置的左侧也有符合指定条件的位置，所以需要再次缩小范围继续查找，直到左右指针相遇

3. 因为题目中的条件是找>=指定数的最左侧位置，所以缩小范围的条件和操作应该是：当中值和指定值的关系为>=的时候，移动右指针到中值的位置；

   如果题目中的条件是找<=指定数的最右侧位置，那么缩小范围的条件和操作就应该是：当中值和指定值的关系为<=的时候，移动左指针到中值的位置。

4. 这种方式进行二分查找和普通的二分查找的区别是：

   1. 指定的元素不一定在数组中，因为这种二分查找找的是符合条件的位置，而不是用户传递进来的元素
   2. 当中值的位置符合条件的指定位置的时候不返回，而是标记该位置，继续下一次缩小范围的查找；如果之后所有的缩小范围查找都没有找到就返回标记的位置，但凡在之后的范围查找中有一个符合条件的指定位置，就重新标记并继续查找或者返回
   3. 这种情况下二分法结束的标志是：左指针和右指针指向同一个元素；而普通二分法结束的标志是找到指定的元素

#### 3、关键代码

```java
/**
背景：在arr上，找满足>=value的最左位置
*/
public static int nearestIndex(int[] arr, int value) {
    int L = 0;
    int R = arr.length - 1;
    int index = -1;
    while (L < R) {
        int mid = L + ((R - L) >> 1);
        //当中值的位置符合指定条件的位置的时候，记录该位置，并且移动右侧指针到中值的前一个位置
        if (arr[mid] >= value) {
            index = mid;
            R = mid - 1;
        } else {
            L = mid + 1;
        }
    }
    return index;
}
```

#### 4、复杂度

时间复杂度O(log n)，额外空间复杂度O(1)

### 2、找局部最小值

> 局部最小概念：arr长度为1时，arr[0]是局部最小。arr的长度为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]是局部最小；如果arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；如果0<i<N-1，既有arr[i]<arr[i-1]又有arr[i]<arr[i+1]，那么arr[i]是局部最小。

#### 1、问题描述

给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。

#### 2、分析

该示例介绍了不是只有在有序的情况下才可以进行二分，需要根据数据的具体状态的问题的描述去判断；

这个分析看视频讲解把，我不好描述，在视频《一周刷爆LeetCode，算法大神左神（左程云）耗时100天打造算法与数据结构基础到高级全家桶教程，直击BTAJ等一线大厂必问算法面试题真题详解_P3_1.认识复杂度和简单排序算法》的1:47:55处介绍了这个算法

#### 3、关键代码

```java
/**
求给定的无序的数组中的局部最小值
*/
public static int getLessIndex(int[] arr) {
    if(arr == null || arr.length == 0){
        return -1; // no exist
    }
    if(arr.length == 1 || arr[0] < arr[1]){
        return 0;
    }
    if(arr[arr.length - 1] < arr[arr.length - 2]){
        return arr.length - 1;
    }
    int left = 1;
    int right = arr.length - 2;
    int mid = 0;
    while (left < right) {
        mid = (left + right) / 2;
        if (arr[mid] > arr[mid - 1]) {
            right = mid - 1;
        } else if (arr[mid] > arr[mid + 1]) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return left;
}
```







