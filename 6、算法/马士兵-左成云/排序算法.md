# 0、公用内容

## 0.0、引子（比较器）

关于比较器的内容可以去看思维导图《Java核心技术卷Ⅰ 第六章 接口、lambda表达式与内部类.xmind》中对Comparable、Comparator接口的描述。

## 0.1、swap方法

```java
public static void swap(int[] arr, int i, int j) {
    if(i == j){
        return ;
    }
	arr[i] = arr[i]^arr[j];   
	arr[j] = arr[i]^arr[j];    //相当于arr[i]^arr[j]^arr[j]
	arr[i] = arr[i]^arr[j];    //相当于arr[i]^arr[j]  ^  arr[i]^arr[j]^arr[j]
}
```

原理图：

![image-20220915093327196](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220915093327196.png)

## 0.2、对数器

对数器的概念和使用 

1. 有一个你想要测的方法a
2. 实现复杂度不好但是容易实现的方法b 
3. 实现一个随机样本产生器
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5. 如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
6. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

代码：

```java
/**
下面的代码中的内容是排序算法对数器的核心操作
*/
class logarithmic{
    // for test
    public static void comparator(int[] arr) {
        Arrays.sort(arr);
    }

    // for test
    public static int[] generateRandomArray(int maxSize, int maxValue) {
        int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
        }
        return arr;
    }

    // for test
    public static int[] copyArray(int[] arr) {
        if (arr == null) {
            return null;
        }
        int[] res = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            res[i] = arr[i];
        }
        return res;
    }

    // for test
    public static boolean isEqual(int[] arr1, int[] arr2) {
        if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
            return false;
        }
        if (arr1 == null && arr2 == null) {
            return true;
        }
        if (arr1.length != arr2.length) {
            return false;
        }
        for (int i = 0; i < arr1.length; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }

    // for test
    public static void printArray(int[] arr) {
        if (arr == null) {
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    /**
    在main方法中使用对数器进行测试，需要根据具体的
    */
    public static void main(String[] args) {
        int testTime = 500000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;
        for (int i = 0; i < testTime; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = copyArray(arr1);
            insertionSort(arr1);
            comparator(arr2);
            if (!isEqual(arr1, arr2)) {
                succeed = false;
                break;
            }
        }
        System.out.println(succeed ? "Nice!" : "Fucking fucked!");

        int[] arr = generateRandomArray(maxSize, maxValue);
        printArray(arr);
        insertionSort(arr);
        printArray(arr);
    }
}
```

# 1、基于比较的排序算法

## 1.1、选择排序

### 1.1.1、关键代码

```java
/**
背景：将数组从左到右，从小到大的顺序进行排序

每完成一次内循环就会比较出未排序的元素中的某个元素和minIndex标记的元素的大小，并将minIndex指向最小的元素；

每完成一次外循环中的内循环就会将minIndex指向未排序的元素中最小的哪个元素；

每完成一次外循环就会将完成一次外循环中的内循环得到的minIndex指向的元素和外循环中当前遍历的元素进行交换位置，所以可能会导致外循环当前被遍历的元素自己和自己进行交换（因为minIndex标记在某次外循环的内循环中没有被改变）；
*/
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    //外循环的作用是：得到内循环中最小的元素与外循环遍历的索引i对应的元素进行交换
    for (int i = 0; i < arr.length - 1; i++) {
        //每次外循环的开始都会将最小元素的标记打在当前外部循环中正在被遍历的索引i上。
        int minIndex = i;
        //内循环的作用是：从外循环索引i之后的元素（它们对应的索引用j标记）中取出一个最小的元素，这个最小元素的确定方式是比较这些j索引对应的元素和被minIndex标记的元素的大小（有可能会导致外循环索引i对应的值自己和自己交换，因为在内循环中没有找到比i小的元素），找出最小的元素用minIndex标记（外循环的开始，就会将这个标记放在外循环对应遍历的索引i上，也就是所有内循环遍历的元素之前的元素）
        for (int j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i, minIndex);
    }
}
```

### 1.1.2、复杂度

1. 算法流程和数据状况没有关系，也就是算法的时间复杂度是不会因为待排序的数组的乱序状态变化而发生变化的
2. 时间复杂度O(N^2)，额外空间复杂度O(1)

## 1.2、冒泡排序

### 1.2.1、关键代码

```java
/**
背景：将数组从左到右，从小到大的顺序进行排序

每完成一次内循环就会比较出两个元素中最大的元素，并将最大的元素放在第二个元素的位置上；

每完成一次外循环中的内循环，就会比较出未排序的元素的大小，将最大的元素放在未排序的元素的最后的位置

每完成一次外循环和完成一次外循环中的内循环的结果是一样的，外循环中仅仅是起到计数的作用
*/
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    } 
    //外循环的作用是：计数
    //在这个算法实现中，一次外循环就会将未排序的元素中最大的元素放在未排序的元素的最右侧
    for(int i = 0; i < arr.length; i++){
        //内循环作用是：每次内循环中都会将未排序的元素进行两两比较，将比较结果中最大的元素放在正在比较的第二个元素的位置上；
        for(int j = 0; j < arr.length -1 -i; j++){
            if(arr[j] > arr[j+1]){
                swap(arr,j,j+1);
            }
        }
    }
    
}
```

冒泡排序的简单优化：

```java
public void bubble(int[] arr) {
  for (int i = 0; i < arr.length - 1; i++) {
    boolean swapped = false; //是否发生了交换
    for (int j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j+1]) {
        int temp = arr[j];
        arr[j] =arr[j+1];
        arr[j+1] = temp;
        swapped = true;
      }
    } 
    if (!swapped){
      break;
    }
  }
}
```



### 1.2.2、复杂度

1. 算法流程和数据状况没有关系，也就是算法的时间复杂度是不会因为待排序的数组的乱序状态变化而发生变化的
2. 时间复杂度O(N^2)，额外空间复杂度O(1)

## 1.3、插入排序

### 1.3.1、关键代码

```java
/**
背景：将数组从左到右，从小到大的顺序进行排序

每完成一次内循环就会比较新插入的元素和已经排好序的元素中的某一个元素的大小，如果新插入的元素小，就会将他和与他比较的元素进行交换

每完成一次外循环中的内循环就会让外循环中当前被遍历的元素以及该元素之前的元素有序；将新插入的元素和已排好序的元素进行依次比较，直到新插入的元素小于已排好序的元素并且已好序元素已遍历完时停止循环

每完成一次外循环和完成一次外循环中的内循环的结果是一样的，外循环中仅仅是起到计数的作用
*/
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    //外循环的作用是：计数；
    //一次外循环会将外循环遍历到的元素以及之前的元素进行排序
    for (int i = 1; i < arr.length; i++) {
    	//内循环的作用是：依次比较外循环遍历到的元素和该元素之前的元素的大小，并将小的元素向前移动
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}
```



### 1.3.2、复杂度

1. 算法流程和数据状况没有关系，也就是算法的时间复杂度是不会因为待排序的数组的乱序状态变化而发生变化的
2. 最坏<font color = "red">时间复杂度O(N^2)</font>——>待排序数组为：{5,4,3,2,1}
   最好时间复杂度O(N)——>待排序数组为：{1,2,3,4,5}
   额外空间复杂度O(1)

## 1.4、归并排序

1）整体就是一个简单递归，左边排好序、右边排好序、让其整体有序
2）让其整体有序的过程里用了外排序方法
3）利用master公式来求解时间复杂度
4）归并排序的实质

1. 有效的避免了选择排序、冒泡排序、插入排序中浪费了大量比较行为的情况，例如：在冒泡排序中每一次外循环需要比较n-1次才能确定数组中一个元素的顺序，而归并排序没有浪费比较行为

> 补充：
>
> 符合master公的递归算法的时间复杂度的计算方式：
> T(N) = a*T(N/b) + O(N^d)
>
> > 公式的解释：
> >
> > T(N)指的是母问题的规模是N级别的，T(N/b)指所有的子问题规模都是N/b级别的，a是子问题被调用次数，+号后面的内容我除去子问题的调用剩下的过程的时间复杂度。
>
> 时间复杂度的计算方式：
>
> 1. log~b~a > d -> 复杂度为O(N^log~b~a)
> 2. log~b~a = d -> 复杂度为O(N^d * logN)
> 3. log~b~a) < d -> 复杂度为O(N^d)

例如：下面示例（求数组中最大的元素）中的代码中的时间复杂度是2*T(N/2)+O(1)

```java
/**
求数组中的最大值
*/
public static int process(int[] arr, int L, int R) {
    if (L == R) {
        return arr[L];
    }
    int mid = L + ((R - L) >> 1);
    int leftMax = process(arr, L, mid);
    int rightMax = process(arr, mid + 1, R);
    return Math.max(leftMax, rightMax);
}
```

### 1.4.1、关键代码

```java
public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    mergeSort(arr, 0, arr.length - 1);
}

public static void mergeSort(int[] arr, int l, int r) {
    if (l == r) {
        return;
    }
    int mid = l + ((r - l) >> 1);
    mergeSort(arr, l, mid);
    mergeSort(arr, mid + 1, r);
    merge(arr, l, mid, r);
}

/**
这个方法的作用是将l~m（已经有序）与m+1~r（已经有序）范围上的数组整体有序
*/
public static void merge(int[] arr, int l, int m, int r) {
    int[] help = new int[r - l + 1];
    int i = 0;
    int p1 = l;
    int p2 = m + 1;
    while (p1 <= m && p2 <= r) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= m) {
        help[i++] = arr[p1++];
    }
    while (p2 <= r) {
        help[i++] = arr[p2++];
    }
    for (i = 0; i < help.length; i++) {
        arr[l + i] = help[i];
    }
}
```

### 1.4.2、复杂度

时间复杂度O(N*logN)，额外空间复杂度O(N)

### 1.4.3、拓展

#### 1.4.3.1、小和问题

在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组 
的小和。求一个数组 的小和。
例子:[1,3,4,2,5] 1左边比1小的数，没有; 3左边比3小的数，1; 4左 
边比4小的数，1、3; 2左边比2小的数，1; 5左边比5小的数，1、3、4、 2; 所以小和为1+1+3+1+1+3+4+2=16

##### 1.4.3.1.1、分析

可以转换一下求出4小和的思路，例如：在上面的数组[1,3,4,2,5]中，比1大的元素的个数有4个，比3大的元素有2个，比4大的元素有1个，比2大的元素有1个，所以总的小和为4+3+3+4+2；这种思路将原来的求有多少个数比当前元素小，改成 了求有多少个元素比当前元素大的问题，问题的本质没有变化，只是思考的角度不同了；在这种思路下可以使用归并排序的方式来解决，**<font color = "red">在求有多少个元素比当前元素大时可以在归并排序算法中合并数组的时候计算</font>**。

##### 1.4.3.1.2、关键代码

```java
public static int smallSum(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    return mergeSort(arr, 0, arr.length - 1);
}

public static int mergeSort(int[] arr, int l, int r) {
    if (l == r) {
        return 0;
    }
    int mid = l + ((r - l) >> 1);
    return mergeSort(arr, l, mid) 
        + mergeSort(arr, mid + 1, r) 
        + merge(arr, l, mid, r);
}

public static int merge(int[] arr, int l, int m, int r) {
    int[] help = new int[r - l + 1];
    int i = 0;
    int p1 = l;
    int p2 = m + 1;
    int res = 0;
    while (p1 <= m && p2 <= r) {
        res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= m) {
        help[i++] = arr[p1++];
    }
    while (p2 <= r) {
        help[i++] = arr[p2++];
    }
    for (i = 0; i < help.length; i++) {
        arr[l + i] = help[i];
    }
    return res;
}
```



## 1.5、快排序

### 1.5.0、引子（例子）

问题一
给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)
![image-20220915155248270](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220915155248270.png)

问题二(荷兰国旗问题)
给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度O(N)。
![image-20220915155113308](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220915155113308.png)

### 1.5.1、关键代码

```java
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    quickSort(arr, 0, arr.length - 1);
}

public static void quickSort(int[] arr, int l, int r) {
    if (l < r) {
        //随机选择数组中的一个数，确保在完成一次快排之后，选择的数在快排后数组各个位置的概率是一致的。避免了O(n^2)时间复杂度
        //随机选好数据之后，将这个数和数组最后一个位置上的数做交换，因为快排序的思想是：每次将数组最后位置的元素最为标准进行划分。
        swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
        //得到的返回值是等于区域的左右边界
        int[] p = partition(arr, l, r);
        //p[0]是等于区域的左边界，减1是小于区域的右边界
        quickSort(arr, l, p[0] - 1);
        //p[1]是等于区域的右边界，加1是大于区域的左边界
        quickSort(arr, p[1] + 1, r);
    }
}

/**
返回的数组的长度一定是2，返回的值是划分之后等于区域的范围（左边界和右边界）；
以数组中最后一个位置的元素作为标准对数组进行划分。
*/
public static int[] partition(int[] arr, int l, int r) {
    int less = l - 1;
    int more = r;
    while (l < more) {
        if (arr[l] < arr[r]) {
            //先将less+=1位置的元素与l位置的元素交换之后向后移动l的位置
            swap(arr, ++less, l++);
        } else if (arr[l] > arr[r]) {
            //将less-=1位置的元素与l位置的元素交换，l位置的不移动，因为此时l位置上的元素是新的元素，还需要继续比较
            swap(arr, --more, l);
        } else {
            //当l指针指向的元素和arr[r]的元素是相同的时候，移动l指针的位置
            l++;
        }
    }
    swap(arr, more, r);
    return new int[] { less + 1, more };
}
```



### 1.5.2、复杂度

快速排序最差情况的时间复杂度为O(N^2)，例如：要排序的数组是{1,2,3,4,5,6,7,8,9}，如果每次都选择数组最后一个元素和其他元素进行比较的，那么就最后划分成的两部分的数组中，元素的分布是不平均的，可能一个数组有8个元素，另一个数组只有一个元素，那么会导致处理有8个元素的数组的时候时间复杂度很高，最终导致时间复杂度为O(n*n); 

只有每次选择的数组的最后一个元素，在完成一次快排时可以将整个数组平均分成两部分的时候时间复杂度才是最低的；

解决O(n^2)的问题是，让选择的元素在完成一次快排的时候尽量在数组中间的位置，但是这样不现实，因为只有数组完成一次快排的时候才能确定选择的元素是不是在数组中间的位置，所以这个时候只能取平均值，也就是让选择的位置是随机的，这样就可以让随机选择的元素在一次快排之后出现在各个位置的概率是几乎一致的，这种优化后的快排的时间复杂度是O(n log n)

额外空间复杂度是O(log n)，最差的空间复杂度为O(n)

## 1.6、堆排序

### 1.6.1、关键代码

这里的代码是对大顶堆进行操作的。

这里只是给出代码，具体的内容可以去看思维导图《Java核心技术卷Ⅰ第九章 死磕补充 集合 List+Map——JDK8&JDK17.xmind》中介绍的优先级队列PriorityQueue中的关于堆的介绍。

步骤：

1. 先让整个数组都变成大根堆结构，建立堆的过程:
   1. 自底向上堆化（但是是从堆的顶部开始自底部向上堆化）的方法，时间复杂度为O(N*logN)
   2. 自顶向下堆化（但是是从堆的底部开始自顶向下堆化）的方法，时间复杂度为O(N)
2. 把堆的最大值和堆末尾的值交换，然后减少堆的大小之后（这样之后再继续堆化的时候就不需要对不在堆大小范围内的元素进行堆化了），再去调整堆，一直周而复始，时间复杂度为O(N*logN)
3. 堆的大小减小成0之后，排序完成

```java
public static void heapSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    //使用自底向上的方式建堆，这种方法的时间复杂度为O(n*log n)
    for (int i = 0; i < arr.length; i++) {
        heapInsert(arr, i);
    }
    //使用自顶向下的方式建堆，这种方法的时间复杂度为O(n)
    //for循环中的arr是一个乱序的数组，这个for循环的目的是将一个乱序数组排序为可以存储堆的
    //数组，从数组最后一个元素开始自上而下的堆化
	//for (int i = arr.length-1; i >= 0; i--) {
	//	heapify(arr, i , arr.length);
	//}
    
    //调用自顶向下的方法对堆进行排序
    int size = arr.length;
    swap(arr, 0, --size);
    while (size > 0) {
        heapify(arr, 0, size);
        swap(arr, 0, --size);
    }
}

//对堆中的一个节点自底向上堆化，将该节点向上移动到一个合适的位置。
public static void heapInsert(int[] arr, int index) {
    while (arr[index] > arr[(index - 1) / 2]) {
        swap(arr, index, (index - 1) /2);
        index = (index - 1)/2 ;
    }
}

/**对堆中的一个节点自从顶向下堆化，将该节点向下移动到一个合适的位置。
因为是从上向下堆化，所以在这里需要给方法传递一个代表堆大小的参数，防止下标越界（底部采用的是数组）
*/
public static void heapify(int[] arr, int index, int size) {
    int left = index * 2 + 1;
    while (left < size) {
        int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            break;
        }
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

### 1.6.2、复杂度

时间复杂度O(N*logN)，额外空间复杂度O(1)



### 1.6.3、拓展

#### 1.6.3.1、堆的使用

已知一个几乎有序的数组arr，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

##### 1.6.3.1.1、分析

创建一个只能存放k个元素的堆，首先从这个arr数组中取出k个元素放在这个堆中，之后每次从堆的顶部取出一个元素依次放在原数组中从索引0开始的位置上，每次从堆中弹出一个元素，就要从arr数组中取出一个新的元素加入到堆中，直到数组arr被取完，将堆中剩余的元素依次弹出，并放入到arr数组中；这里描述的不是很清晰，因为这中间涉及到一些细节问题不好描述，具体看代码。

##### 1.6.3.1.2、关键代码

```java
public void sortedArrDistanceLessK(int[] arr, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    //这个index的值保存的是arr数组中的索引
    int index = 0;
    //当这个方法开始的时候，首先从arr数组中取出k个元素（如果k小于数组长度的话）放在堆中，并用index记录arr数组中还未取出的第一个元素的位置
    for (; index < Math.min(arr.length, k); index++) {
        heap.add(arr[index]);
    }

    //这个i的作用和index的作用是类似的，都是用来记录arr数组中的位置，不过index是记录还未从arr数组中取出的第一个元素的而为之，而i记录的是堆中弹出的元素应该在数组中的位置
    int i = 0;
    //在这个for循环中开始从堆顶取出元素放在arr数组中，从arr数组索为0的位置开始存放，每次从堆中弹出一个元素之后，就需要从arr数组索引为index的位置开始取一个元素并放到堆中，同时index的位置加一，确保index始终指向的是arr数组中还未取出的元素的第一个位置
    for (; index < arr.length; i++, index++) {
        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    //当index等于arr.length的时候意味着arr数组中的元素已经全部被取出一次了，这个手就只需要将堆中现存的元素逐个弹出并放到arr数组中i索引指向的位置就可以了
    while (!heap.isEmpty()) {
        arr[i++] = heap.poll();
    }
}
```



# 2、不基于比较的排序算法

不基于比较的排序算法都是根据数据状况做的排序，需要根据数据的状况进行定制；有基于比较的排序应用的范围广。

## 2.1、桶排序

未讲

桶排序思想下的排序
1）计数排序
2）基数排序
分析：
1)桶排序思想下的排序都是不基于比较的排序
2)时间复杂度为O(N)，额外空间负载度O(M)
3)应用范围有限，需要样本的数据状况满足桶的划分

### 2.1.1、关键代码

### 2.1.2、复杂度



## 2.2、计数排序

视频中讲解的这个算法就像  Map/数组  一样，举了个例子：对员工的年龄进行排序，首先因为员工的年龄一定不会小于16，不会大于100，所以可以构建一个Map其中key为员工年龄，value为该年龄下对应的人数。

### 2.2.1、关键代码

### 2.2.2、复杂度



## 2.3、基数排序

根据待排序的数组中的元素是十进制、八进制、二进制……分别使用10、8、2个桶（先进先出队列），这些桶的编号从0到n-1，在排序的时候首先按照个位进行排序，将待排序的数组顺序进入桶中（某元素的个位是什么就将该元素放入对应的桶中），之后按照桶的顺序将桶中的元素按照先进先出的顺序取出再放入数组中；再按照数组中元素的十位上的元素进行排序，将待排序的数组顺序进入桶中（某元素的十位是什么就将该元素放入对应的桶中），之后按照桶的顺序将桶中的元素按照先进先出的顺序取出再放入数组中，……，直到数组中的元素的最高位也派完，将桶中的元素按照先进先出的顺序取出来放进数组中；数组中最大值有多少位就会出桶入桶多少位。

比计数排序要好一些，因为计数排序是在一个范围上的数字都要做词频的对应，key（也就是基数排序中的桶）。

### 2.3.1、关键代码

### 2.3.2、复杂度



## 2.4、哈希排序

未讲

### 2.4.1、关键代码

### 2.4.2、复杂度





# 3、排序算法稳定性汇总

同样值的个体之间，如果不因为排序而改变相对次序，就是这个排序是有稳定性的；否则就没有；算法中如果可以通过少量的代码控制相同元素的相对次序，那该算法就有稳定型。



不具备稳定性的排序： 

1. 选择排序
   示例：第一个3和1交换之后，会导致相同元素3的相对次序就变化了

   ![image-20220916173315995](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220916173315995.png)

   1. 时间复杂度：O(N^2)
   2. 空间复杂度：O(1)

2. 快速排序
   示例：当数组中第一个6和3进行交换之后，就会导致相同元素6的相对次序发生了变化
   ![image-20220916174616428](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220916174616428.png)

   1. 时间复杂度：O(N^2)/O(NlogN)
   2. 空间复杂度：O(n)/O(log n)

3. 堆排序
   示例：很轻易就会破坏稳定性
   ![image-20220916174933451](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220916174933451.png)

   1. 时间复杂度：O(N*logN)
   2. 空间复杂度：O(1)

具备稳定性的排序：

1. 冒泡排序
   1. 时间复杂度：O(N^2)
   2. 空间复杂度：O(1)
2. 插入排序
   1. 时间复杂度：O(N^2)/O(N)
   2. 空间复杂度：O(1)
3. 归并排序
   1. 时间复杂度：O(N*logN)
   2. 空间复杂度：O(N)
4. 一切桶排序思想下的排序
   先入桶的元素先出桶，所以数组中相同元素的相对次序是稳定的

目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。



简图：

![image-20220916175508373](D:\Tyora\AssociatedPicturesInTheArticles\排序算法\image-20220916175508373.png)



# 4、总结

1. 常用的排序算法是快速排序，因为它常数项低（这也是优势），劣势是空间复杂度无法做到O(1)；
2. 当有空间的限制的时候就需要用到堆排序（这也是优势），劣势是稳定性低；
3. 当用到稳定性的时候就需要用到归并排序（这也是优势），劣势是空间复杂度高。
   
4. 基于比较的排序不能做到时间复杂度为O(N logN)以下，O(N logN)已经是极限。
5. 基于比较的排序在时间复杂度为O(N logN)时空间复杂度不能做到O(N)y以下，O(N)已经是极限了。

常见坑

1. 归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法”；但是当使用这种方式之后归并排序不再稳定，这种情况下性能等价于堆排序。
2. “原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成O(N^2) ，这种情况下性能等价于冒泡、插入排序
3. 快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜“01stable sort”；但是会让快排的空间复杂度为O(N)，这种情况下性能等价于归并
4. 所有的改进都不重要，因为目前没有找到时间复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序。
5. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。





# -

# -

# -

# -

# -

# -

# -

# -

# -

# -

# -

# -

# -

# -

# -