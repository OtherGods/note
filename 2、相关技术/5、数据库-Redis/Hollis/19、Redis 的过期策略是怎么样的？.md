#redis的过期策略 #key过期后定期删除或者惰性删除 

# 典型回答

Redis 通过设置过期时间来控制键值对的生命周期。过期时间可以通过EXPIRE、EXPIREAT、PERSIST等命令设置，也可以在插入数据时直接设置过期时间。

**Redis 的过期策略采用的是定期删除和惰性删除相结合的方式。**
- **定期删除**：Redis 默认每隔 100ms 就随机抽取一些设置了过期时间的 key，并检查其是否过期，如果过期才删除。定期删除是 Redis 的主动删除策略，它可以确保过期的 key 能够及时被删除，但是会占用 CPU 资源去扫描 key，可能会影响 Redis 的性能。
  - 优点：均衡 CPU 与内存消耗。
  - 缺点：抽样机制可能导致过期 key 清理不够及时。
  [39、Redis中key过期了一定会立即删除吗](2、相关技术/5、数据库-Redis/Hollis/39、Redis中key过期了一定会立即删除吗.md)
- **惰性删除**：当一个 key 过期时，不会立即从内存中删除，而是在访问这个 key 的时候才会触发删除操作。惰性删除是 Redis 的被动删除策略，它可以节省 CPU 资源，但是会导致过期的 key 始终保存在内存中，占用内存空间。
  - 优点：CPU 开销小。
  - 缺点：如果某些过期 key 一直不访问，就会长期占内存。
除了这两种以外，还有一种：
- **定时删除**
  在设置 key 的同时创建一个定时器，到期立即删除
  - 优点：内存释放及时
  - 缺点：定时器太多会严重占用 CPU（所以 *==Redis不采用单独定时删除==*）

**==Redis默认同时开启*定期删除*和*惰性删除*两种过期策略==**

<font size=5 color="red">定期删除键时，其实并不会立即释放内存，而是把这些键标记为“已过期”，并放入一个专门的链表中。然后，<font size=5 color="blue">在Redis的内存使用率达到一定阈值时，Redis会对这些“已过期”的键进行一次内存回收操作</font>，释放被这些键占用的内存空间。</font>

<font color="red" size=5>而惰性删除则是在键被访问时进行过期检查，如果过期了则<font color="blue" size=5>删除键并释放内存</font>。</font>

需要注意的是，即使Redis进行了内存回收操作，也不能完全保证被删除的内存空间会立即被系统回收。

一般来说，这些被删除的内存空间会被操作系统标记为“可重用的内存”，等待被重新分配。因此，即使Redis进行了内存回收操作，也并不能保证Redis所占用的内存空间会立即释放给操作系统。

# 扩展

## 内存淘汰策略

[20、Redis的内存淘汰策略是怎么样的？](2、相关技术/5、数据库-Redis/Hollis/20、Redis的内存淘汰策略是怎么样的？.md)

## 内存过期和内存淘汰的对比

过期策略：解决了某个 key 设置了过期时间，Redis 怎么知道什么时候删除它？
内存淘汰策略：解决了当 Redis 内存达到 maxmemory 限制时，该怎么办？
 - 如果没有设置 `maxmemory`，Redis 内存会无限长大（直到操作系统 OOM 杀死进程）
 - 如果设置了 `maxmemory`，Redis 会按照配置的 **淘汰策略**删除一些 key

| 对比点      | 过期策略               | 内存淘汰策略                                |
| -------- | ------------------ | ------------------------------------- |
| **触发条件** | **==key 到了过期时间==** | **==Redis 内存使用超过 maxmemory==**        |
| **作用对象** | 单个*设置了 TTL 的 key*  | *整个实例所有 key*（可能限制到有 TTL 的 key）        |
| **目的**   | **释放无效数据的内存**      | **保证内存不超过限制**，维持可用性                   |
| **机制**   | 惰性删除 + 定期删除        | noeviction / lru / lfu / random / ttl |
| **能否控制** | 用户*只能控制 TTL*，不能选策略 | 用户*可选具体的淘汰策略*（通过配置）                   |
