#I/O多路复用 #同步非阻塞 
Redis的性能很好，除了因为他基于内存、有高效的数据结构等等原因以外，还有一个重要的原因那就是他在单线程中使用多路复用 I/O技术也能提升Redis的I/O利用率。
[5、Redis为什么这么快？](2、相关技术/5、数据库-Redis/Hollis/5、Redis为什么这么快？.md)

# 1、Redis的多路复用

多路复用这个词，相信很多人都不陌生。那么，Redis的多路复用技术有什么特别的呢？

这里先讲讲Linux多路复用技术，就是多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。![2.jpg](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404182230794.jpg)

多看一遍上面这张图和上面那句话，后面可能还会用得到。

也就是说，通过一个线程来处理多个IO流。

IO多路复用在Linux下包括了三种，select、poll、epoll，抽象来看，他们功能是类似的，但具体细节各有不同。

其实，Redis的IO多路复用程序的所有功能都是通过包装操作系统的IO多路复用函数库来实现的。每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件。
![2.jpg](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404182232981.jpg)

在Redis 中，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。
![2.jpg](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404182236208.jpg)

一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

所以，Redis选择使用多路复用IO技术来提升I/O利用率。

而之所以Redis能够有这么高的性能，不仅仅和采用多路复用技术和单线程有关，此外还有以下几个原因：
- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
- 数据结构简单，对数据操作也简单，如哈希表、跳表都有很高的性能。
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU
- 使用多路I/O复用模型

#同步 #异步 #阻塞 #非阻塞

> **ChatGPT解释：**
> > 同步和阻塞**不是同一个概念**，异步和非阻塞也**不是同一个概念**
> > 同步和阻塞的区别在于，同步是相对于进程或线程间的
> > 协调机制来说的，它要求发出调用的进程或者线程在没
> > 有得到结果之前必须等待；而阻塞关注的是进程或线程
> > 在等待调用结果（如消息、返回值）时的状态，即在等
> > 待期间该进程或线程是否会被挂起。简单来说，同步是
> > 一种按顺序执行的过程，而阻塞则描述了执行过程中的
> > 一种特定状态。
> > 
> > 异步和非阻塞通常用于描述I/O操作的不同方面。非阻塞
> > 着眼于I/O操作的第一个阶段，即当数据还未读取完毕
> > 时，是否可以进行其他操作；而异步则是强调在整个I/O
> > 操作完成后，是由系统内核主动通知应用层数据已经准
> > 备好，还是应用层需要不断询问系统内核数据是否准备
> > 好。
> > 
> > 综上所述，同步、异步、阻塞和非阻塞都是计算机科学
> > 中用以描述程序行为特点的概念，它们各自关注不同的
> > 场景和细节，不能简单地等同起来。
> 
> 我的总结：
> 1. 同步与阻塞的区别：同步关注任务执行的过程，如任务按那种顺序执行（比如线程从1加到100）；异步关注任务执行过程的状态，如线程执行任务过程中是否会被阻塞（比如线程读取文件）；
>    
> 2. 异步与非阻塞的区别：异步强调任务在执行完毕后是主动回调返回结果还是被动等待获取结果（主动：异步，被动：同步）；非阻塞：强调在等待另一个任务执行的过程中是否可以进行其他操作（是：非阻塞，否：阻塞）
> 

