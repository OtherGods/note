#滑动窗口 #RRateLimiter 

redisson就不多做介绍了，它提供的分布式锁非常强大，一般公司都会选择它在生产环境中使用。但其提供的其他分布式工具就不是那么有名了，比如其提供的分布式限流器`RRateLimiter`网上几乎没有分析它的文章，本文也基于此目的记录一下学习`RRateLimiter`的心得。如有不对，请多指正。

## 简单使用

很简单，相信大家都看得懂。

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        RRateLimiter rateLimiter = createLimiter();


        int allThreadNum = 20;

        CountDownLatch latch = new CountDownLatch(allThreadNum);

        long startTime = System.currentTimeMillis();
        for (int i = 0; i < allThreadNum; i++) {
            new Thread(() -> {
                rateLimiter.acquire(1);
                System.out.println(Thread.currentThread().getName());
                latch.countDown();
            }).start();
        }
        latch.await();
        System.out.println("Elapsed " + (System.currentTimeMillis() - startTime));
    }

    public static RRateLimiter createLimiter() {
        Config config = new Config();
        config.useSingleServer()
                .setTimeout(1000000)
                .setAddress("redis://127.0.0.1:6379");

        RedissonClient redisson = Redisson.create(config);
        RRateLimiter rateLimiter = redisson.getRateLimiter("myRateLimiter");
        // 初始化
        // 最大流速 = 每1秒钟产生1个令牌
        rateLimiter.trySetRate(RateType.OVERALL, 1, 1, RateIntervalUnit.SECONDS);
        return rateLimiter;
    }
}
```

## 源码分析

### Redis命令、Lua脚本

1. **==创建限流器==** 源码
    ```lua
    redis.call('hsetnx', KEYS[1], 'rate', ARGV[1]);
    redis.call('hsetnx', KEYS[1], 'interval', ARGV[2]);
    return redis.call('hsetnx', KEYS[1], 'type', ARGV[3]);
    ```
    就是把 **速率** 和 **模式(单机or集群)** 放到hash中就结束了。
2. ~~获取令牌~~ **==根据`Lua`脚本判断滑动窗口内 *是否允许新请求通过*==** 源码
   <font color="blue" size=5>判断依据</font>：
   - 获取到`{name}:permits`过期的记录，判断是否过期的方式：`score`的值小于`当前时间-interval`的记录为过期记录；
     累计这些过期记录中`{name}:permits`的`value`中保存的请求数也就是 **==过期请求数==**，同时 **==删除过期记录==** 
   - 根据`过期请求数` **==重新计算`{name}:value`==**，计算方式为：`{name}:value = {name}:value + 过期请求数`，同时比较新的`{name}:value`与请求数量的大小；如果`{name}:value`大于请求数量则允许新请求通过，否则需要等待一段时间，这段时间的计算方式看[Java代码](41.1、Redisson分布式限流器RRateLimiter原理解析#Java代码)

通过Demo的代码示例点进去，最后可以看到执行`Lua`脚本判断新请求是否允许通过代码在`org.redisson.RedissonRateLimiter#tryAcquireAsync(org.redisson.client.protocol.RedisCommand<T>, java.lang.Long)`这个方法里，这段方法中的`Lua`脚本及注释的代码如下：
```lua
    -- 速率
    local rate = redis.call("hget", KEYS[1], "rate")
    -- 时间区间(ms)
    local interval = redis.call("hget", KEYS[1], "interval")
    local type = redis.call("hget", KEYS[1], "type")
    assert(rate ~= false and interval ~= false and type ~= false, "RateLimiter is not initialized")
    
    -- {name}:value 分析后面的代码，这个key存储的数据是
    -- 滑动窗口中可以通过的请求数（类似于令牌桶中剩余的令牌数）
    local valueName = KEYS[2]
    
    -- {name}:permits 这个key是一个zset，value中记录了处理过的
    -- 请求数（类似于令牌桶算法中已获取过的令牌数），score则为请求的时间戳
    local permitsName = KEYS[4]
    
    -- 单机限流才会用到，集群模式不用关注
    if type == "1" then
        valueName = KEYS[3]
        permitsName = KEYS[5]
    end
    
    -- 原版本有bug(https://github.com/redisson/redisson/issues/3197)，最新版将这行代码提前了
    -- rate为1 arg1这里是 请求的令牌数量(默认是1)。rate必须比请求的令牌数大,否则抛出异常
    assert(tonumber(rate) >= tonumber(ARGV[1]), "Requested permits amount could not exceed defined rate")
    
    -- 第一次执行这里应该是null，会进到else分支
    -- 第二次执行到这里由于else分支中已经放了valueName的值进去，所以第二次会进if分支
    local currentValue = redis.call("get", valueName)
    if currentValue ~= false then
        -- 从第一次设的zset中取数据，范围是0 ~ (第二次请求时间戳 也就是当前时间 - 时间窗口间隔)
        -- ，也就是取出过期数据（不在以当前时间为滑动窗口的结束时间的窗口范围内的数据）
        -- ，创建时间小于 当前时间-时间窗口间隔 的数据
        -- ；这里作者将这个取出来的数据命名为expiredValues，可认为指的是过期的数据
        local expiredValues = redis.call("zrangebyscore", permitsName, 0, tonumber(ARGV[2]) - interval)
        local released = 0
        -- lua迭代器，遍历过期的数据expiredValues，如果有值，那么released最终等于过期数据曾获取到的
        -- 令牌数之和，表示应该释放多少令牌
        for i, v in ipairs(expiredValues) do
            local random, permits = struct.unpack("fI", v)
            released = released + permits
        end
    
        -- 没有过期请求的话，released还是0，这个if不会进，有过期请求才会进
        if released > 0 then
            -- 移除zset中所有元素，重置周期
            redis.call("zrem", permitsName, unpack(expiredValues))
            currentValue = tonumber(currentValue) + released
            redis.call("set", valueName, currentValue)
        end
    
        -- 这里简单分析下上面这段代码:
        -- 1. 只有超过了1个令牌生产周期后的请求，expiredValues才会有值。
        -- 2. 以rate为3举例，如果之前发生了两个请求那么现在released为2，currentValue为1 + 2 = 3
        -- 以此可以看到，redisson的令牌桶放令牌操作是通过请求时间窗来做的，如果距离上一个请求的时间已经超过了一个令牌生产周期时间，那么令牌桶中的令牌应该得到重置，表示生产rate数量的令牌。
    
        -- 如果当前令牌数 ＜ 请求的令牌数
        if tonumber(currentValue) < tonumber(ARGV[1]) then
            -- 从zset中找到当前时间窗口中距离当前时间最近的那个请求，也就是当前时间窗口中上一次放进去的请求信息
            local nearest = redis.call('zrangebyscore', permitsName, '(' .. (tonumber(ARGV[2]) - interval), tonumber(ARGV[2]), 'withscores', 'limit', 0, 1); 
            local random, permits = struct.unpack("fI", nearest[1])
            -- 返回 上一次请求的时间戳 - (当前时间戳 - 令牌生成的时间间隔) 这个值表示还需要多久才能生产出足够的令牌
            return tonumber(nearest[2]) - (tonumber(ARGV[2]) - interval)
        else
            -- 如果当前令牌数 ≥ 请求的令牌数，表示令牌够多，更新zset
            redis.call("zadd", permitsName, ARGV[2], struct.pack("fI", ARGV[3], ARGV[1]))
            -- valueName存的是当前总令牌数，-1表示取走一个
            redis.call("decrby", valueName, ARGV[1])
            return nil
        end
    else
        -- set一个key-value数据 记录当前限流器的令牌数
        redis.call("set", valueName, rate)
        -- 建了一个以当前限流器名称相关的zset，并存入 以score为当前时间戳，以lua格式化字符串{当前时间戳为种子的随机数、请求的令牌数}为value的值。
        -- struct.pack第一个参数表示格式字符串，f是浮点数、I是长整数。所以这个格式字符串表示的是把一个浮点数和长整数拼起来的结构体。我的理解就是往zset里记录了最后一次请求的时间戳和请求的令牌数
        redis.call("zadd", permitsName, ARGV[2], struct.pack("fI", ARGV[3], ARGV[1]))
        -- 从总共的令牌数 减去 请求的令牌数。
        redis.call("decrby", valueName, ARGV[1])
        return nil
    end    
```

#### 部分命令解释

`redis.call('zrangebyscore', permitsName, '(' .. (tonumber(ARGV[2]) - interval), tonumber(ARGV[2]), 'withscores', 'limit', 0, 1);` 解释：
1. 基本命令：`redis.call('zrangebyscore', ...)`：在Lua脚本中调用Redis的`ZRANGEBYSCORE`命令
2. 参数说明
	- `permitsName`：有序集合(`ZSET`)的键名
	- `'(' .. (tonumber(ARGV[2]) - interval)`：分数范围的最小值
	    - `(`：表示开区间（不包含此值）
	    - `tonumber(ARGV[2])`：将`ARGV[2]`参数转换为数字
	    - `interval`：一个时间间隔值（假设以秒为单位）
	    - 整体表示：从`ARGV[2] - interval`开始（但不包含此值）
	- `tonumber(ARGV[2])`：分数范围的最大值（闭区间，包含此值）
	- `'withscores'`：返回结果包含成员及其分数
	- `'limit'`：限制返回结果的数量
	- `0, 1`：从第0个元素开始，返回1个元素

这个命令的作用是从名为`permitsName`的有序集合中：**选择分数范围**：选择分数在`(ARGV[2] - interval, ARGV[2]]`区间内的成员，**返回结果**：返回这个区间内的第一个成员（及其分数）。

#### 参数解释

`Lua`脚本中参数的值如下：
- `key[1]`对应的键是`myRateLimiter`
- `key[2]`对应的键是`{myRateLimiter}:value`
- `key[4]`对应的键是`{myRateLimiter}:permits`
- `ARGV[1]`对应的值是本次要通过的请求数（或者理解为要去桶里获取多少令牌）
- `ARGV[2]`对应当前时间戳
- `ARGV[3]`随机数
![QQ_1748788872628.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506012241393.png)

#### Lua比较运算符

关于这个lua脚本中用到的redis知识及数据结构：
1. lua脚本中符号`~=`是【不等于】![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506012257890.png)
   在Redis Lua环境中如果GET获取到的值不存在则返回nil（在Lua中表现为false）
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506012258601.png)
#### Lua中用到的数据结构

1. **==`Hash`结构==**：`myRateLimiter`，用于 *==保存的限流器的配置==*；
   由Java代码创建的限流器数据结构
```java
	RRateLimiter rateLimiter = redisson.getRateLimiter("myRateLimiter");
	// 初始化
	// 最大流速 = 每1秒钟产生1个令牌，第一个参数是标识是单机（1）还是集群（0【代码中枚举RateType定义的顺序】）
	rateLimiter.trySetRate(RateType.OVERALL, 1, 1, RateIntervalUnit.SECONDS);
```
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506012225264.png)

2. **==`ZSET`结构==**：`{myRateLimiter}:permits`，
   **==`String`结构==**：`{myRateLimiter}:value`，用于保存时间窗口内还允许通过多少个请求，该结构中的数据在每次执行`Lua`脚本时重新计算更新

   `{myRateLimiter}:permits`的value中包含每次请求需要的令牌数![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506012244403.png)
   
   `{myRateLimiter}:value`中包含存放当前令牌桶剩余令牌数量![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506012244829.png)

总结一下，redisson用了`zset`来记录请求的信息，这样可以非常巧妙的通过比较score，也就是请求的时间戳，来判断当前请求距离上一个请求有没有超过一个令牌生产周期。如果超过了，则说明令牌桶中的令牌需要生产，之前用掉了多少个就生产多少个，而之前用掉了多少个令牌的信息也在zset中保存了。

然后比较当前令牌桶中令牌的数量，如果足够多就返回了，如果不够多则返回到下一个令牌生产还需要多少时间。这个返回值特别重要。

### Java代码

接下来就是回到java代码，各个API入口点进去，最后都会调到`org.redisson.RedissonRateLimiter#tryAcquireAsync(long, org.redisson.misc.RPromise<java.lang.Boolean>, long)`这个方法。我也拷出来做了简单的注释。
 
```java
    private void tryAcquireAsync(long permits, RPromise<Boolean> promise, long timeoutInMillis) {
        long s = System.currentTimeMillis();
        RFuture<Long> future = tryAcquireAsync(RedisCommands.EVAL_LONG, permits);
        future.onComplete((delay, e) -> {
            if (e != null) {
                promise.tryFailure(e);
                return;
            }
            
            if (delay == null) {
                //delay就是lua返回的 还需要多久才会有令牌
                promise.trySuccess(true);
                return;
            }
            
            //没有手动设置超时时间的逻辑，timeoutInMillis是超时时间
            if (timeoutInMillis == -1) {
                //延迟delay时间后重新执行一次拿令牌的动作
                commandExecutor.getConnectionManager().getGroup().schedule(() -> {
                    tryAcquireAsync(permits, promise, timeoutInMillis);
                }, delay, TimeUnit.MILLISECONDS);
                return;
            }
            
            //el 请求redis拿令牌的耗时
            long el = System.currentTimeMillis() - s;
            //如果设置了超时时间，那么应该用超时时间减去拿令牌的耗时
            //计算出新的超时时间remains，如果新超时时间小于0说明在获
            //取新令牌时就已经超时了，直接返回false
            long remains = timeoutInMillis - el;
            if (remains <= 0) {
                //如果拿令牌的时间比设置的超时时间还要大的话直接就false了
                promise.trySuccess(false);
                return;
            }
            //如果新超时时间为1s，delay为1500ms，那么1s后告知失败
            if (remains < delay) {
                commandExecutor.getConnectionManager().getGroup().schedule(() -> {
                    promise.trySuccess(false);
                }, remains, TimeUnit.MILLISECONDS);
            } else {
                long start = System.currentTimeMillis();
                commandExecutor.getConnectionManager().getGroup().schedule(() -> {
                    //因为这里是异步的，所以真正再次拿令牌之前再检查一下过去了多久时间。如果过去的时间比设置的超时时间大的话，直接false
                    long elapsed = System.currentTimeMillis() - start;
                    if (remains <= elapsed) {
                        promise.trySuccess(false);
                        return;
                    }
                    //再次拿令牌
                    tryAcquireAsync(permits, promise, remains - elapsed);
                }, delay, TimeUnit.MILLISECONDS);
            }
        });
    }
```

再次总结一下，Java客户端拿到`Lua`脚本返回的 **==下一个令牌生产完成还需要多少时间==**，也就是`delay`字段：
- 如果这个`delay`为`null`，则表示成功获得令牌
- 如果没拿到，`delay`为时间，则过`delay`时间后通过异步线程再次发起拿令牌的动作
这里也可以看到，`redisson`的`RateLimiter`是非公平的，多个线程同时拿不到令牌的话并不保证先请求的会先拿到令牌。

## 总结

因为公司的开放网关的限流模块就是基于Redisson开发的，之前看的版本源码与最新的已经有很大的不同，趁着整理知识点的机会下了最新版的源码看了一遍。限流这个说简单也简单，说复杂也复杂。不知道是不是我看的东西太少，我觉得redisson的限流器设计非常精巧，感觉把redis玩穿了。

[Redisson分布式限流器RRateLimiter原理解析](https://github.com/oneone1995/blog/issues/13)

