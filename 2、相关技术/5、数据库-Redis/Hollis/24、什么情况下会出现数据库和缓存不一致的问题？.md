#缓存和数据库不一致的情况 #不一致的根因是：多线程并发操作数据库和缓存，数据库操作和缓存操作不是原子的 #并发读写、写写

# 典型回答

Redis和数据库不一致的<font color="red" size=5>本质是对Redis和数据库的操作<font color="blue" size=5>不是原子的</font>，可中断、可拆分</font>。

首先，在非并发的场景中，出现不一致的问题大家都能比较容易的理解，因为缓存的操作和数据库的操作是存在一定的时间差的。而且这两个操作是没办法保证原子性的，也就是说，是有可能一个操作成功，一个操作失败的。所以，这就必然会存在不一致的情况。

如果在并发场景中，如果两个线程，同时进行先写数据库，后更新缓存的操作，就可能会出现不一致：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506301631164.png)

如果在并发场景中，如果两个线程，同时进行先更新缓存，后写数据库的操作，同理，也可能会出现不一致：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506301632844.png)

在并发场景中，还有一种容易忽略的并发场景，那就是读写并发。

我们知道，当我们使用了缓存之后，一个读的线程在查询数据的过程是这样的：
- 1、查询缓存，如果缓存中有值，则直接返回 
- 2、查询数据库 
- 3、把数据库的查询结果更新到缓存中

所以，对于一个读线程来说，虽然不会写数据库，但是是会更新缓存的，所以，在一些特殊的并发场景中，就会导致数据不一致的情况。

读写并发的时序如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506301633303.png)

也就是说，假如一个读线程，在读缓存的时候没查到值，他就会去数据库中查询，但是如果自查询到结果之后，更新缓存之前，数据库被更新了，但是这个读线程是完全不知道的，那么就导致最终缓存会被重新用一个”旧值”覆盖掉。

这也就导致了缓存和数据库的不一致的现象。

但是这种现象其实发生的概率比较低，因为一般一个读操作是很快的，数据库+缓存的读操作基本在十几毫秒左右就可以完成了。

而在这期间，刚好另一个线程执行了一个比较耗时的写操作的概率确实比较低。
当然，根据墨菲定律，只要有可能发生的事情，就一定会发生。所以我们也要引起重视。


# 扩展知识

## 如何解决

[25、如何解决Redis和数据库的一致性问题](2、相关技术/5、数据库-Redis/Hollis/25、如何解决Redis和数据库的一致性问题.md)
