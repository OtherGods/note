# 1、秒杀示例代码

秒杀过程中用到的库存和清单的数据结构
用set类型来存储秒杀成功的人，防止重复秒杀

![image-20220909165839054](D:\Tyora\AssociatedPicturesInTheArticles\秒杀代码及注释\image-20220909165839054.png)

## 1、简单的秒杀代码

```java
//1、用户id（uid）和商品id（prodid）的非空判断
if(uid == null ||prodid == null){
    return false;
}
//2、连接redis
Jedis jedis = new Jedis("192.168.44.168",6379);

//3、拼接key
//	3.1、库存key
String kcKey = "sk:"+prodid+":qt";
//	3.2、秒杀成功用户key
String userKey = "sk:"+prodid+":user";

//4、获取库存，如果库存为null，则秒杀还没开始
String kc = jedis.get(kcKey);
if(kc == null) {
    System.out.println("秒杀还没有开始，请等待");
    jedis.close();
    return false;
}

//5、判断用户是否重复做秒杀操作
if(jedis.sismember(userKey, uid)) {
    System.out.println("已经秒杀成功了，不能重复秒杀");
    jedis.close();
    return false;
}

//6、判断如果库存数量<=0表示秒杀结束
if(Integer.parseInt(kc)<=0) {
    System.out.println("秒杀已经结束了");
    jedis.close();
    return false;
}

//7、秒杀过程
//	7.1、库存减1
jedis.decr(kcKey);
//	7.2、把秒杀成功的用户添加到清单中
jedis.sadd(userKey,uid);
System.out.println("秒杀成功了..");
jedis.close();
return true;
```

## 2、在1的基础上解决超卖问题

使用事务对库存的数量进行控制，首先监视库存的数量，如果在执行库存数量-1，成功秒杀人+1操作之前库存数量发生了改变，事务的执行会被打断，从而解决超卖问题。

```java
//1、用户id（uid）和商品id（prodid）的非空判断
if(uid == null ||prodid == null){
    return false;
}
//2、连接redis
Jedis jedis = new Jedis("192.168.44.168",6379);

//3、拼接key
//	3.1、库存key
String kcKey = "sk:"+prodid+":qt";
//	3.2、秒杀成功用户key
String userKey = "sk:"+prodid+":user";

//增加乐观锁，对库存数量进行监视——slove-1
jedis.watch(qtkey);

//4、获取库存，如果库存为null，则秒杀还没开始
String kc = jedis.get(qtkey);
if(kc==null || "".equals(kc.trim())) {
    System.out.println("未初始化库存");
    jedis.close();
    return false ;
}

//5、如果库存数量<=0，表示已经秒杀结束
int qt = Integer.parseInt(kc);
if(qt<=0) {
    System.err.println("已经秒光");
    jedis.close();
    return false;
}

//6、判断用户是否重复做秒杀操作
if(jedis.sismember(userKey, uid)) {
    System.out.println("已经秒杀成功了，不能重复秒杀");
    jedis.close();
    return false;
}

//增加事务——slove-2
Transaction multi = jedis.multi();

//7、秒杀过程
//	7.1、库存减1——slove-3
//jedis.decr(qtkey);
multi.decr(qtkey);

//	7.2、把秒杀成功的用户添加到清单中——slove-4
//jedis.sadd(usrkey, uid);
multi.sadd(usrkey, uid);

//执行事务——slove-5
List<Object> list = multi.exec();

//判断事务提交是否失败——slove-6
//判断秒杀失败的地方
if(list==null || list.size()==0) {
    System.out.println("秒杀失败");
    jedis.close();
    return false;
}
System.err.println("秒杀成功");
jedis.close();
```

## 3、在2的基础上解决连接超时的问题

假设同时有200个请求在请求redis，但是redis不能同时处理，那么在这2000个请求重不能被redis处理的请求就会等待，如果等待时间过长，该请求还没有连上redis，那么就会报这个问题。

连接池参数：
	MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。
	maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；
	MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；
	testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；

连接池代码：

```java
package com.atguigu;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;

public class JedisPoolUtil {
    private static volatile JedisPool jedisPool = null;

    private JedisPoolUtil() {
    }

    public static JedisPool getJedisPoolInstance() {
        if (null == jedisPool) {
            synchronized (JedisPoolUtil.class) {
                if (null == jedisPool) {
                    JedisPoolConfig poolConfig = new JedisPoolConfig();
                    poolConfig.setMaxTotal(200);
                    poolConfig.setMaxIdle(32);
                    poolConfig.setMaxWaitMillis(100*1000);
                    poolConfig.setBlockWhenExhausted(true);
                    poolConfig.setTestOnBorrow(true);  // ping  PONG
					//指定连接池的poolConfig，redis的IP地址，端口号，已经超时时间。
                    jedisPool = new JedisPool(poolConfig, "192.168.44.168", 6379, 60000 );
                }
            }
        }
        return jedisPool;
    }
	//释放jedis连接
    public static void release(JedisPool jedisPool, Jedis jedis) {
        if (null != jedis) {
            jedisPool.returnResource(jedis);
        }
    }
}
```

秒杀代码：

```java
//1 uid和prodid非空判断
if(uid == null || prodid == null) {
    return false;
}

//2 连接redis
//Jedis jedis = new Jedis("192.168.44.168",6379);
//通过连接池得到jedis对象
JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();
Jedis jedis = jedisPoolInstance.getResource();

//3 拼接key
// 3.1 库存key
String kcKey = "sk:"+prodid+":qt";
// 3.2 秒杀成功用户key
String userKey = "sk:"+prodid+":user";

//监视库存
jedis.watch(kcKey);

//4 获取库存，如果库存null，秒杀还没有开始
String kc = jedis.get(kcKey);
if(kc == null) {
    System.out.println("秒杀还没有开始，请等待");
    jedis.close();
    return false;
}

// 5 判断用户是否重复秒杀操作
if(jedis.sismember(userKey, uid)) {
    System.out.println("已经秒杀成功了，不能重复秒杀");
    jedis.close();
    return false;
}

//6 判断如果商品数量，库存数量小于1，秒杀结束
if(Integer.parseInt(kc)<=0) {
    System.out.println("秒杀已经结束了");
    jedis.close();
    return false;
}

//7 秒杀过程
//使用事务
Transaction multi = jedis.multi();

//组队操作
multi.decr(kcKey);
multi.sadd(userKey,uid);

//执行
List<Object> results = multi.exec();

if(results == null || results.size()==0) {
    System.out.println("秒杀失败了....");
    jedis.close();
    return false;
}

//7.1 库存-1
//jedis.decr(kcKey);
//7.2 把秒杀成功用户添加清单里面
//jedis.sadd(userKey,uid);

System.out.println("秒杀成功了..");
jedis.close();
return true;
```

## 4、在2的基础上带来的库存遗留

已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。
乐观锁的使用本来是为了解决超卖问题的，但是解决问题的同时也会带来库存遗留问题。

使用LUA脚本解决

```LUA
//这里的注释我是用Java中的注释方式，不知道LUA中的注释方式是什么，先这样写着
//返回0、1、2，分别代表的是秒杀结束、秒杀成功、秒杀成功后不可重复秒杀
local userid=KEYS[1]; 
local prodid=KEYS[2];
local qtkey="sk:"..prodid..":qt";         //拼接库存key和用户key
local usersKey="sk:"..prodid.":usr'; 
local userExists=redis.call("sismember",usersKey,userid);   //判断用户是否已经秒杀过
if tonumber(userExists)==1 then 
  return 2;      //如果该用户秒杀成功过商品则不能再次秒杀
end
local num= redis.call("get" ,qtkey);     //判断库存数量
if tonumber(num)<=0 then 
  return 0;        //秒杀结束
else 
  redis.call("decr",qtkey);              //执行库存数量-1
  redis.call("sadd",usersKey,userid);     //执行秒杀成功用户+1
end
return 1;      //秒杀成功
```



```java
package com.atguigu;

import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.slf4j.LoggerFactory;

import ch.qos.logback.core.joran.conditional.ElseAction;
import redis.clients.jedis.HostAndPort;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisCluster;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.ShardedJedisPool;
import redis.clients.jedis.Transaction;

public class SecKill_redisByScript {
	
	private static final  org.slf4j.Logger logger =LoggerFactory.getLogger(SecKill_redisByScript.class) ;

	public static void main(String[] args) {
		JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();
 
		Jedis jedis=jedispool.getResource();
		System.out.println(jedis.ping());
		
		Set<HostAndPort> set=new HashSet<HostAndPort>();

	//	doSecKill("201","sk:0101");
	}
	
	//LUA脚本
	static String secKillScript ="local userid=KEYS[1];\r\n" + 
			"local prodid=KEYS[2];\r\n" + 
			"local qtkey='sk:'..prodid..\":qt\";\r\n" + 
			"local usersKey='sk:'..prodid..\":usr\";\r\n" + 
			"local userExists=redis.call(\"sismember\",usersKey,userid);\r\n" + 
			"if tonumber(userExists)==1 then \r\n" + 
			"   return 2;\r\n" + 
			"end\r\n" + 
			"local num= redis.call(\"get\" ,qtkey);\r\n" + 
			"if tonumber(num)<=0 then \r\n" + 
			"   return 0;\r\n" + 
			"else \r\n" + 
			"   redis.call(\"decr\",qtkey);\r\n" + 
			"   redis.call(\"sadd\",usersKey,userid);\r\n" + 
			"end\r\n" + 
			"return 1" ;
			 
	static String secKillScript2 = 
			"local userExists=redis.call(\"sismember\",\"{sk}:0101:usr\",userid);\r\n" +
			" return 1";

	public static boolean doSecKill(String uid,String prodid) throws IOException {

		JedisPool jedispool =  JedisPoolUtil.getJedisPoolInstance();
		Jedis jedis=jedispool.getResource();

		 //String sha1=  .secKillScript;
		String sha1=  jedis.scriptLoad(secKillScript);
		Object result= jedis.evalsha(sha1, 2, uid,prodid);

		  String reString=String.valueOf(result);
		if ("0".equals( reString )  ) {
			System.err.println("已抢空！！");
		}else if("1".equals( reString )  )  {
			System.out.println("抢购成功！！！！");
		}else if("2".equals( reString )  )  {
			System.err.println("该用户已抢过！！");
		}else{
			System.err.println("抢购异常！！");
		}
		jedis.close();
		return true;
	}
}
```

