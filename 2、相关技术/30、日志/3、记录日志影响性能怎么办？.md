# 典型回答

很多时候，日志的记录都经常被大家忽略，因为对于性能要求不高的场景中，记录日志确实是可以忽略的。

但是在很多核心业务链路中，1-2ms的影响都很大，所以就会考虑对写日志环节进行性能优化。希望这个技术大家都能用的上，哈哈哈哈。

解决日志慢的问题，主要有两种方案，一个是 **==异步==**，一个是 **==降级==**。

因为日志写入操作通常是一个相对耗时的IO操作，如果每次日志记录都同步写入磁盘，可能会导致主线程阻塞，影响应用程序的性能。通过使用异步日志，主线程可以继续执行其他任务，而日志写入操作则由后台线程负责处理，提高了应用程序的响应性和吞吐量。

目前常用的日志框架，如`Log4j2`、`Logback`等都是支持异步日志的。都提供了`AsyncAppender`来实现 **==异步日志==** 写入。

<font color="blue" size=5>异步日志</font>：**让执行业务逻辑的线程尽快将日志事件扔到一个内存队列中后就返回，而==真正耗时的I/O操作（写入文件、网络发送等）则由另一个专门的线程去完成==。** 这样做可以**极大地减少日志记录对主业务线程的性能影响**，尤其在高并发、高吞吐量的应用场景下，优势非常明显。

如`logback`中做如下配置即可实现异步日志：
```xml
<configuration>
   <appender name="FILE" class="ch.qos.logback.core.FileAppender">
		<file>application.log</file>
		<encoder>
			<pattern>%logger{35} - %m%n</pattern>
		</encoder>
   </appender>
   <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
		<appender-ref ref="FILE" />
		<queueSize>2048</queueSize>
		<discardingThreshold>20</discardingThreshold> 
		<neverBlock>true</neverBlock>
		<includeCallerData>false</includeCallerData>
   </appender>
   <root level="DEBUG">
     <appender-ref ref="ASYNC" />
   </root>
 </configuration>
```

- `queueSize`：**==内存阻塞队列`BlockingQueue`的最大容量==**；
	- 默认大小为`256`，它决定了在来不及处理的情况下，最多可以积压多少条日志事件；如果请求量大的话，可以适当调大这个`queue`的`size`。
- `discardingThreshold`：**==日志丢弃阈值==**；
	- 默认情况下，当队列还有`20%`容量，他将丢弃`trace`、`debug`和`info`级别的日志，只保留`warn`和`error`级别的日志。
- `neverBlock`：在 **==队列放满的情况下是否阻塞业务线程==**；
	- 默认是`false`
	- 如果配置为`true`，当队列满了之后，后面阻塞的线程想要输出的消息就直接被丢弃，从而线程不会阻塞。适合在一些性能要求高，并且日志可降级的场景。
- `includeCallerData`：**==是否包含调用方数据==**（如类名、方法名、行号）；
	- 获取调用方数据（通过 `%class`, `%method`, `%line` 等转换符）是一个非常耗时的操作，因为需要提取堆栈信息。在同步日志中，每次记录日志都要计算一次。在 `AsyncAppender` 中，这个操作可以延迟到**后台线程**中去做。
	- 设置为 `false` (本例) 意味着，只有在日志事件**确实需要**输出调用数据（即其 `Appender` 的布局模式中包含了 `%class` 等符号）时，才会在入队前提取一次，然后缓存起来。如果布局模式里根本没有这些符号，就完全不会提取。这是**性能最优**的设置

说到降级，日志降级一般用的也不多，但是在大促场景中，也是会用到的，一般是配合预案一起做，就是在极端情况下，通过开关来调节， 让日志直接不输出。或者只打印`ERROR`级别的日志。

或者做的更加精细一点，就是采样打印日志，比如采样`1%`进行日志输出，但是其实用的比较少，很多时候，采样和直接不打差别也不大。

关于日志降级，我之前做过一个工具，可以动态调整日志级别，后面我把主要思想简单说一下。

# 扩展知识

## 异步日志的限制

在很多时候，我们会在日志中打印一个链路追踪的信息，如`trace_id`，但是因为这里是异步打印的，`ThreadLocal`中存储的`trace_id`就无法获取了，就会导致日志中无法记录`trace_id`了。
[23、如何实现应用中的链路追踪？](2、相关技术/21、分布式/Hollis/23、如何实现应用中的链路追踪？.md)

所以需要特殊解决一下，方法也比较简单，就是自己定义一个`Appender`的实现类，在这个类里面进行设置这个trace_id：
```java
MDC.put("traceId",  threadPoolTaskData.toString());
```

或者使用 https://github.com/ofpay/logback-mdc-ttl 来解决。

[38、有了InheritableThreadLocal为啥还需要TransmittableThreadLocal？](2、相关技术/2、JUC/Hollis/Java并发/38、有了InheritableThreadLocal为啥还需要TransmittableThreadLocal？.md)
