
# 1、@Primary

位置： `org.springframework.context.annotation.Primary`

`@Primary` 是 Spring 框架中的一个注解，用于解决当存在多个符合条件的 Bean 时，优先选择一个 Bean 进行注入的问题。它通过标记一个默认的 Bean，使其在自动装配时被优先考虑。

**使用 `@Primary` 的场景**
当应用程序中有多个相同类型的 Bean 需要自动装配时，Spring 无法确定应该选择哪个 Bean。如果其中一个 Bean 使用了 `@Primary` 注解，那么这个 Bean 会被优先注入。

**示例代码**
假设我们有一个接口 `GreetingService`，以及两个实现类 `EnglishGreetingService` 和 `SpanishGreetingService`。
```java
public interface GreetingService {
    String greet();
}

@Service
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}
```

**使用 `@Primary` 注解**
假设我们希望在自动装配 `GreetingService` 时，优先使用 `EnglishGreetingService`。我们可以在其类上添加 `@Primary` 注解。
```java
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Service
@Primary
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}
```

**自动装配** `GreetingService`
现在我们可以在一个组件中自动装配 `GreetingService`，并且 `EnglishGreetingService` 会被优先注入。
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class GreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public GreetingComponent(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，由于 `EnglishGreetingService` 被标记为 `@Primary`，所以 `GreetingComponent` 中注入的 `GreetingService` 将会是 `EnglishGreetingService` 的实例。

**使用** `@Qualifier` 注解
如果在某些情况下你需要特定的 Bean 而不是 `@Primary` 标记的 Bean，可以使用 `@Qualifier` 注解指定特定的 Bean。
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class SpecificGreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public SpecificGreetingComponent(@Qualifier("spanishGreetingService") GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，通过使用 `@Qualifier("spanishGreetingService")`，`SpecificGreetingComponent` 会注入 `SpanishGreetingService`，即使 `EnglishGreetingService` 被标记为 `@Primary`。

**总结**
- **`@Primary` 注解** 用于在存在多个相同类型的 Bean 时，指定一个默认的 Bean。
- **应用场景**：解决多个候选 Bean 的自动装配冲突问题。
- **结合 `@Qualifier` 使用**：在需要时可以使用 `@Qualifier` 注解来指定特定的 Bean，从而覆盖 `@Primary` 的默认行为。

通过合理使用 `@Primary` 和 `@Qualifier`，开发者可以在 Spring 应用程序中灵活地管理和注入 Bean，满足不同场景下的需求。


# 2、@Qualifier

#Qualifier

`@Qualifier` 是 Spring 框架中的一个注解，用于解决自动装配冲突的问题。当有多个同类型的 Bean 需要注入时，通过使用 `@Qualifier` 注解，可以明确指定要注入的 Bean，从而避免歧义。

**`@Qualifier` 注解介绍**
- **包路径**：`org.springframework.beans.factory.annotation.Qualifier`
- **功能**：在存在多个相同类型的 Bean 时，指定要注入的具体 Bean。

## 2.1、使用 `@Qualifier` 的场景

当应用程序中有多个同类型的 Bean 时，Spring 无法自动确定应该注入哪个 Bean。使用 `@Qualifier` 注解可以明确指明要注入的 Bean，解决冲突。

## 2.2、示例代码

### 2.2.1、定义接口和实现类

假设我们有一个接口 `GreetingService`，以及两个实现类 `EnglishGreetingService` 和 `SpanishGreetingService`。

```java
public interface GreetingService {
    String greet();
}

@Service
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}
```

### 2.2.2、使用 `@Qualifier` 注解

在需要注入 `GreetingService` 的地方，可以使用 `@Qualifier` 注解来指定要注入的 Bean。

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class GreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public GreetingComponent(@Qualifier("englishGreetingService") GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，通过使用 `@Qualifier("englishGreetingService")`，Spring 会将 `EnglishGreetingService` 注入到 `GreetingComponent` 中。

### 2.2.3、结合 `@Primary` 使用

当有多个同类型的 Bean 时，可以结合使用 `@Primary` 和 `@Qualifier` 注解。`@Primary` 指定默认的 Bean，而 `@Qualifier` 可以覆盖默认行为，指定具体的 Bean。

```java
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Service
@Primary
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class SpecificGreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public SpecificGreetingComponent(@Qualifier("spanishGreetingService") GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，`EnglishGreetingService` 被标记为 `@Primary`，默认会被注入。但是在 `SpecificGreetingComponent` 中，通过 `@Qualifier("spanishGreetingService")`，我们指定注入 `SpanishGreetingService`。

## 2.3、总结

- **`@Qualifier` 注解** 用于在存在多个同类型的 Bean 时，指定要注入的具体 Bean。
- **解决自动装配冲突**：通过明确指定要注入的 Bean，避免因存在多个同类型的 Bean 而产生的歧义。
- **结合 `@Primary` 使用**：`@Primary` 指定默认的 Bean，而 `@Qualifier` 可以覆盖默认行为，指定具体的 Bean。
  
通过合理使用 `@Qualifier` 注解，开发者可以精确控制 Bean 的注入，确保应用程序按照预期工作。


# 3、@Valid

ChatGPT介绍 #Valid

`@jakarta.validation.Valid` 是 Java Bean Validation（JSR 380 / JSR 303）规范的一部分，在 Spring Boot 项目中非常常见，常用于 **请求参数校验、嵌套对象校验、集合元素校验** 等场景。

## 3.1、基本作用

`@Valid` 注解的作用是 **触发被注解对象上定义的校验注解的执行**，例如：`@NotNull`、`@Size`、`@Min` 等。

## 3.2、使用注意事项总结（重要）

### 1. **必须配合 `@Validated` 或 `@Valid` 的作用范围使用**

- 方法参数校验常用于 `@Controller` 层：
```java
@PostMapping("/save")
public ResponseEntity<?> save(@Valid @RequestBody UserDTO user) {
    // 如果 UserDTO 不合法，会抛出 MethodArgumentNotValidException
    return ResponseEntity.ok("ok");
}
```

- 如果是在 `@Service` 中使用校验，必须类上加 `@Validated`：
```java
@Service
@Validated
public class UserService {
    public void update(@Valid UserDTO user) {
        // 不加 @Validated，这里的 @Valid 不生效
    }
}
```

---

### 2. **嵌套对象必须使用 `@Valid` 才能递归校验**

```java
public class Order {
    @Valid
    private Address address;
}
```

> 如果不加 `@Valid`，`Address` 中的字段不会校验。

### 3. **集合/数组中的元素想要被校验，必须结合 `@Valid` 一起用**

```java
public class Order {
    @Valid
    private List<@NotNull Item> items;
}
```

- `@Valid` 作用于集合字段
- `@NotNull` 作用于集合的元素

### 4. `BindingResult` 参数必须紧跟在 `@Valid` 后，否则异常不能被捕获

```java
@PostMapping("/save")
public ResponseEntity<?> save(@Valid @RequestBody UserDTO user, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        return ResponseEntity.badRequest().body(bindingResult.getAllErrors());
    }
    return ResponseEntity.ok("ok");
}
```

> `BindingResult` 只对方法参数级校验生效，不适用于 service 层或嵌套属性。

### 5. 默认只支持基本注解，要使用自定义注解需注册 `ConstraintValidator`

```java
@Documented
@Constraint(validatedBy = MyCustomValidator.class)
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCheck {
    String message() default "invalid";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

### 6. Spring Boot 3.x 使用的是 `jakarta.validation.*`，非 `javax.validation.*`

迁移到 Spring Boot 3 后，包名从 `javax.validation.Valid` 改成了 `jakarta.validation.Valid`。

### 7. 需要依赖 `spring-boot-starter-validation`

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

## 3.3、总结表

|场景|是否生效|条件|
|---|---|---|
|Controller 参数校验|✅|使用 `@Valid @RequestBody`|
|嵌套字段校验|✅|嵌套字段加 `@Valid`|
|集合内元素校验|✅|集合本身加 `@Valid`，元素加约束注解|
|Service 层校验|✅|类上加 `@Validated`|
|BindingResult 捕获校验异常|✅|必须紧跟 `@Valid` 参数|
|自定义校验|✅|需自定义注解 + 实现 `ConstraintValidator`|

如果你想看一个 [完整示例代码](https://chatgpt.com/c/f)、[嵌套对象校验演示](https://chatgpt.com/c/f)，或 [常见校验注解速查表](https://chatgpt.com/c/f)，我可以立刻补充。你需要哪个？


# 4、@Validated

ChatGPT介绍 #Validated 

`@org.springframework.validation.annotation.Validated` 是 Spring 提供的注解，用于支持 **方法级别的参数校验** 和 **分组校验**，它通常和 JSR-303 标准注解（如 `@NotNull`、`@Min` 等）配合使用。

下面是它在使用中你**必须注意的关键点**。

## 1. 必须加在类上（或接口上），才能启用方法参数校验

```java
@Service
@Validated  // ✅ 关键点：必须加在类或接口上，方法参数校验才生效
public class UserService {

    public void updateUser(@NotBlank String userId) {
        // userId 为空时会自动抛出 ConstraintViolationException
    }
}
```

> ⚠️ 若你省略 `@Validated`，方法参数上的约束注解将 **不会生效**！

## 2. 方法参数校验依赖 Spring AOP，不能是 private/static/final 方法

- Spring AOP 只能拦截 **public 方法**
- 如果你写的是 `private` 或 `final`，校验不生效

```java
public final void deleteUser(...) { } // ❌ 不会触发校验
```

## 3. 与 `@Valid` 的区别：支持分组校验（@Valid 不支持）

你可以为不同业务场景定义不同校验分组：
```java
public class UserDTO {
    @NotNull(groups = Create.class)
    private String username;

    @NotNull(groups = Update.class)
    private String id;
}
```

然后这样使用：
```java
@PostMapping("/add")
public void add(@Validated(Create.class) @RequestBody UserDTO user) {
    // 只校验 Create 分组相关的字段
}
```

## 4. 用在 Controller 方法参数时，也可以支持分组

```java
@GetMapping("/check")
public void check(@Validated(Update.class) @RequestBody UserDTO user) {
    // 与上面用法类似
}
```

## 5. `@Validated` 与 `@Valid` 可以一起使用，但不能互相替代

| 位置                 | 用哪个            |
| ------------------ | -------------- |
| DTO 内部嵌套对象         | `@Valid` ✅     |
| Service 方法参数       | `@Validated` ✅ |
| 分组校验               | `@Validated` ✅ |
| 简单 Controller 参数校验 | `@Valid` 就够了 ✅ |

## 6. 校验异常默认是 `ConstraintViolationException`

当方法参数不满足约束条件时，Spring 会抛出：
```plaintext
javax.validation.ConstraintViolationException
```

你可以用 `@ControllerAdvice` 捕获：
```java
@ExceptionHandler(ConstraintViolationException.class)
public ResponseEntity<?> handle(ConstraintViolationException ex) {
    return ResponseEntity.badRequest().body(ex.getMessage());
}
```

## 常见踩坑总结

|问题|原因|
|---|---|
|方法参数加了 `@NotBlank` 但校验不生效|类上没加 `@Validated`|
|嵌套字段没被校验|缺少 `@Valid`|
|分组校验无效|用的是 `@Valid` 而不是 `@Validated`|
|方法是 private/static|AOP 拦截不到，校验不执行|

## 7、结论

- `@Validated` 是 **Spring 用于方法参数校验和分组校验的关键注解**
- 在 **类或接口** 上使用，启用方法参数校验
- 支持 `groups`，是 `@Valid` 所不具备的能力
- 一般与 `@NotNull`、`@Size` 等一起用

需要的话，我可以补充一个 [方法级参数校验示例](https://chatgpt.com/c/f)、[分组校验实战代码](https://chatgpt.com/c/f)，或 [@Validated vs @Valid 图表对比](https://chatgpt.com/c/f)。你想看哪个？


# 5、@MockBean

`@MockBean` 注解。这是一个在 Spring Boot 测试中极其重要和常用的注解。

### 1. 它是什么？

`@MockBean` 是一个由 Spring Boot Test 提供的注解，它用于在 **Spring 的 `ApplicationContext`** 中为一个 Bean 定义一个 **Mockito  mock** 对象。

它的核心作用是：**在==集成测试中==，用 Mock 对象==临时替换==掉 Spring ==容器中的某个真正的 Bean==**。

### 2. 为什么要使用它？

想象一下你在测试一个 `UserService`，它又依赖了一个 `EmailService`。
```java
@Service
public class UserService {
    @Autowired
    private EmailService emailService;

    public void registerUser(String email) {
        // ... 一些注册逻辑 ...
        emailService.sendWelcomeEmail(email); // 需要被模拟的调用
    }
}
```

在测试 `UserService` 时，你并不关心 `EmailService` 是否真的发出了邮件（这可能很慢，而且需要复杂的配置）。你只关心 `UserService` 的**逻辑**是否正确，即它是否**调用了** `emailService.sendWelcomeEmail(email)` 方法。

`@MockBean` 允许你将真实的 `EmailService` Bean 替换成一个“假”的 Mock 对象，这样你就可以：
1.  **隔离测试**：专注于当前组件的测试，排除其他依赖组件的影响。
2.  **定义行为**：指定这个 Mock 对象在被调用时应该返回什么值或抛出什么异常。
3.  **验证交互**：验证测试过程中，你的代码是否按预期调用了这个依赖的方法。

### 3. 如何使用它？

`@MockBean` 通常用在测试类上。

#### 基本用法：字段注入

```java
@SpringBootTest // 启动完整的Spring应用上下文
class UserServiceTest {

    @Autowired
    private UserService userService; // 要测试的真实Bean

    @MockBean // 在容器中创建一个EmailService的Mock，并替换掉原有的真实Bean
    private EmailService emailService;

    @Test
    void shouldSendEmailWhenUserRegisters() {
        // 1. 准备：给定一个邮箱地址
        String userEmail = "test@example.com";

        // 2. 执行：调用真实的服务方法
        userService.registerUser(userEmail);

        // 3. 断言：验证Mock的emailService的sendWelcomeEmail方法被调用了一次，且参数是userEmail
        verify(emailService, times(1)).sendWelcomeEmail(userEmail);
    }

    @Test
    void shouldHandleEmailFailure() {
        String userEmail = "test@example.com";

        // 定义Mock对象的行为：当方法被调用时，模拟抛出异常
        doThrow(new RuntimeException("SMTP failure"))
                .when(emailService)
                .sendWelcomeEmail(userEmail);

        // 验证你的服务是否能妥善处理异常
        assertThrows(RuntimeException.class, () -> {
            userService.registerUser(userEmail);
        });

        verify(emailService).sendWelcomeEmail(userEmail);
    }
}
```

#### 用法：方法参数注入（在 `@BeforeEach` 中很常用）

你也可以将 `@MockBean` 作为测试方法参数，Spring 会自动将其注入。

```java
@SpringBootTest
class UserServiceTest {

    @Autowired
    private UserService userService;

    @Test
    void shouldSendEmailWhenUserRegisters(@MockBean EmailService emailService) {
        // ... 测试逻辑与上面相同
        userService.registerUser("test@example.com");
        verify(emailService).sendWelcomeEmail("test@example.com");
    }
}
```

#### 用法：在 `@TestConfiguration` 中声明

如果你想在多个测试类中重用一组特定的 Mock 配置，可以这样做：

```java
@TestConfiguration
public class TestConfig {
    @MockBean
    public EmailService emailService;
}

@SpringBootTest
@Import(TestConfig.class) // 导入包含Mock配置的类
class UserServiceTest {
    // ...
}
```

### 4. `@MockBean` 与 `@Mock` 的区别

这是一个非常重要的区别：

| 特性 | `@Mock` (来自 Mockito) | `@MockBean` (来自 Spring Boot Test) |
| :--- | :--- | :--- |
| **框架** | 纯 Mockito | Spring Boot Test（内部集成了 Mockito） |
| **用途** | 标准的单元测试 | **Spring 的集成测试** |
| **Spring 上下文** | **不需要** | **需要**。它会与 Spring 的 `ApplicationContext` 交互。 |
| **核心作用** | 创建一个简单的 Mock 对象 | 在 Spring 容器中**注册或替换**一个 Bean 为 Mock 对象 |
| **依赖注入** | 需要手动注入到被测试对象中 | **自动**被 Spring 注入到需要它的 Bean 中 |

**简单总结：**
*   如果你的测试**不启动 Spring 上下文**（例如使用 `MockitoJUnitRunner`），用 `@Mock`。
*   如果你的测试**启动了 Spring 上下文**（例如使用 `@SpringBootTest`），并且你想模拟容器中的一个 Bean，用 `@MockBean`。

### 5. 注意事项

1.  **性能**：使用 `@SpringBootTest` 会加载整个应用上下文，比纯单元测试慢。只在需要测试容器集成（如 Bean 注入、JDBC、Web MVC 等）时使用。
2.  **作用域**：在测试类上定义的 `@MockBean` 会在该类的**每一个测试方法执行后被自动重置**。这意味着在一个测试中设定的行为（如 `when(...).thenReturn(...)`）不会泄漏到下一个测试中。
3.  **特定 Bean**：你可以通过 `@MockBean(name = "mySpecificBean")` 来指定要替换的 Bean 的名称，这在有多个同类型 Bean 时非常有用。

### 总结

`@MockBean` 是 Spring Boot 测试工具包中一把强大的“瑞士军刀”，它让你能够轻松地编写**聚焦的、快速的、可靠的集成测试**，通过将棘手的或不相关的依赖项模拟掉，从而只测试你真正关心的逻辑。
