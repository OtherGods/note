
# 1、@Primary

位置： `org.springframework.context.annotation.Primary`

`@Primary` 是 Spring 框架中的一个注解，用于解决当存在多个符合条件的 Bean 时，优先选择一个 Bean 进行注入的问题。它通过标记一个默认的 Bean，使其在自动装配时被优先考虑。

**使用 `@Primary` 的场景**
当应用程序中有多个相同类型的 Bean 需要自动装配时，Spring 无法确定应该选择哪个 Bean。如果其中一个 Bean 使用了 `@Primary` 注解，那么这个 Bean 会被优先注入。

**示例代码**
假设我们有一个接口 `GreetingService`，以及两个实现类 `EnglishGreetingService` 和 `SpanishGreetingService`。
```java
public interface GreetingService {
    String greet();
}

@Service
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}
```

**使用 `@Primary` 注解**
假设我们希望在自动装配 `GreetingService` 时，优先使用 `EnglishGreetingService`。我们可以在其类上添加 `@Primary` 注解。
```java
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Service
@Primary
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}
```

**自动装配** `GreetingService`
现在我们可以在一个组件中自动装配 `GreetingService`，并且 `EnglishGreetingService` 会被优先注入。
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class GreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public GreetingComponent(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，由于 `EnglishGreetingService` 被标记为 `@Primary`，所以 `GreetingComponent` 中注入的 `GreetingService` 将会是 `EnglishGreetingService` 的实例。

**使用** `@Qualifier` 注解
如果在某些情况下你需要特定的 Bean 而不是 `@Primary` 标记的 Bean，可以使用 `@Qualifier` 注解指定特定的 Bean。
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class SpecificGreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public SpecificGreetingComponent(@Qualifier("spanishGreetingService") GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，通过使用 `@Qualifier("spanishGreetingService")`，`SpecificGreetingComponent` 会注入 `SpanishGreetingService`，即使 `EnglishGreetingService` 被标记为 `@Primary`。

**总结**
- **`@Primary` 注解** 用于在存在多个相同类型的 Bean 时，指定一个默认的 Bean。
- **应用场景**：解决多个候选 Bean 的自动装配冲突问题。
- **结合 `@Qualifier` 使用**：在需要时可以使用 `@Qualifier` 注解来指定特定的 Bean，从而覆盖 `@Primary` 的默认行为。

通过合理使用 `@Primary` 和 `@Qualifier`，开发者可以在 Spring 应用程序中灵活地管理和注入 Bean，满足不同场景下的需求。

# 2、@Qualifier

#Qualifier

`@Qualifier` 是 Spring 框架中的一个注解，用于解决自动装配冲突的问题。当有多个同类型的 Bean 需要注入时，通过使用 `@Qualifier` 注解，可以明确指定要注入的 Bean，从而避免歧义。

**`@Qualifier` 注解介绍**
- **包路径**：`org.springframework.beans.factory.annotation.Qualifier`
- **功能**：在存在多个相同类型的 Bean 时，指定要注入的具体 Bean。

## 2.1、使用 `@Qualifier` 的场景

当应用程序中有多个同类型的 Bean 时，Spring 无法自动确定应该注入哪个 Bean。使用 `@Qualifier` 注解可以明确指明要注入的 Bean，解决冲突。

## 2.2、示例代码

### 2.2.1、定义接口和实现类

假设我们有一个接口 `GreetingService`，以及两个实现类 `EnglishGreetingService` 和 `SpanishGreetingService`。

```java
public interface GreetingService {
    String greet();
}

@Service
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}
```

### 2.2.2、使用 `@Qualifier` 注解

在需要注入 `GreetingService` 的地方，可以使用 `@Qualifier` 注解来指定要注入的 Bean。

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class GreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public GreetingComponent(@Qualifier("englishGreetingService") GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，通过使用 `@Qualifier("englishGreetingService")`，Spring 会将 `EnglishGreetingService` 注入到 `GreetingComponent` 中。

### 2.2.3、结合 `@Primary` 使用

当有多个同类型的 Bean 时，可以结合使用 `@Primary` 和 `@Qualifier` 注解。`@Primary` 指定默认的 Bean，而 `@Qualifier` 可以覆盖默认行为，指定具体的 Bean。

```java
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

@Service
@Primary
public class EnglishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "Hello!";
    }
}

@Service
public class SpanishGreetingService implements GreetingService {
    @Override
    public String greet() {
        return "¡Hola!";
    }
}

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class SpecificGreetingComponent {

    private final GreetingService greetingService;

    @Autowired
    public SpecificGreetingComponent(@Qualifier("spanishGreetingService") GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    public void printGreeting() {
        System.out.println(greetingService.greet());
    }
}
```

在这个例子中，`EnglishGreetingService` 被标记为 `@Primary`，默认会被注入。但是在 `SpecificGreetingComponent` 中，通过 `@Qualifier("spanishGreetingService")`，我们指定注入 `SpanishGreetingService`。

## 2.3、总结

- **`@Qualifier` 注解** 用于在存在多个同类型的 Bean 时，指定要注入的具体 Bean。
- **解决自动装配冲突**：通过明确指定要注入的 Bean，避免因存在多个同类型的 Bean 而产生的歧义。
- **结合 `@Primary` 使用**：`@Primary` 指定默认的 Bean，而 `@Qualifier` 可以覆盖默认行为，指定具体的 Bean。
  
通过合理使用 `@Qualifier` 注解，开发者可以精确控制 Bean 的注入，确保应用程序按照预期工作。


# 3、@Valid

ChatGPT介绍 #Valid

`@jakarta.validation.Valid` 是 Java Bean Validation（JSR 380 / JSR 303）规范的一部分，在 Spring Boot 项目中非常常见，常用于 **请求参数校验、嵌套对象校验、集合元素校验** 等场景。

## 3.1、基本作用

`@Valid` 注解的作用是 **触发被注解对象上定义的校验注解的执行**，例如：`@NotNull`、`@Size`、`@Min` 等。

## 3.2、使用注意事项总结（重要）

### 1. **必须配合 `@Validated` 或 `@Valid` 的作用范围使用**

- 方法参数校验常用于 `@Controller` 层：
```java
@PostMapping("/save")
public ResponseEntity<?> save(@Valid @RequestBody UserDTO user) {
    // 如果 UserDTO 不合法，会抛出 MethodArgumentNotValidException
    return ResponseEntity.ok("ok");
}
```

- 如果是在 `@Service` 中使用校验，必须类上加 `@Validated`：
```java
@Service
@Validated
public class UserService {
    public void update(@Valid UserDTO user) {
        // 不加 @Validated，这里的 @Valid 不生效
    }
}
```

---

### 2. **嵌套对象必须使用 `@Valid` 才能递归校验**

```java
public class Order {
    @Valid
    private Address address;
}
```

> 如果不加 `@Valid`，`Address` 中的字段不会校验。

### 3. **集合/数组中的元素想要被校验，必须结合 `@Valid` 一起用**

```java
public class Order {
    @Valid
    private List<@NotNull Item> items;
}
```

- `@Valid` 作用于集合字段
- `@NotNull` 作用于集合的元素

### 4. `BindingResult` 参数必须紧跟在 `@Valid` 后，否则异常不能被捕获

```java
@PostMapping("/save")
public ResponseEntity<?> save(@Valid @RequestBody UserDTO user, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        return ResponseEntity.badRequest().body(bindingResult.getAllErrors());
    }
    return ResponseEntity.ok("ok");
}
```

> `BindingResult` 只对方法参数级校验生效，不适用于 service 层或嵌套属性。

### 5. 默认只支持基本注解，要使用自定义注解需注册 `ConstraintValidator`

```java
@Documented
@Constraint(validatedBy = MyCustomValidator.class)
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCheck {
    String message() default "invalid";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

### 6. Spring Boot 3.x 使用的是 `jakarta.validation.*`，非 `javax.validation.*`

迁移到 Spring Boot 3 后，包名从 `javax.validation.Valid` 改成了 `jakarta.validation.Valid`。

### 7. 需要依赖 `spring-boot-starter-validation`

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

## 3.3、总结表

|场景|是否生效|条件|
|---|---|---|
|Controller 参数校验|✅|使用 `@Valid @RequestBody`|
|嵌套字段校验|✅|嵌套字段加 `@Valid`|
|集合内元素校验|✅|集合本身加 `@Valid`，元素加约束注解|
|Service 层校验|✅|类上加 `@Validated`|
|BindingResult 捕获校验异常|✅|必须紧跟 `@Valid` 参数|
|自定义校验|✅|需自定义注解 + 实现 `ConstraintValidator`|

如果你想看一个 [完整示例代码](https://chatgpt.com/c/f)、[嵌套对象校验演示](https://chatgpt.com/c/f)，或 [常见校验注解速查表](https://chatgpt.com/c/f)，我可以立刻补充。你需要哪个？


# 4、@Validated

ChatGPT介绍 #Validated 

`@org.springframework.validation.annotation.Validated` 是 Spring 提供的注解，用于支持 **方法级别的参数校验** 和 **分组校验**，它通常和 JSR-303 标准注解（如 `@NotNull`、`@Min` 等）配合使用。

下面是它在使用中你**必须注意的关键点**。

## 1. 必须加在类上（或接口上），才能启用方法参数校验

```java
@Service
@Validated  // ✅ 关键点：必须加在类或接口上，方法参数校验才生效
public class UserService {

    public void updateUser(@NotBlank String userId) {
        // userId 为空时会自动抛出 ConstraintViolationException
    }
}
```

> ⚠️ 若你省略 `@Validated`，方法参数上的约束注解将 **不会生效**！

## 2. 方法参数校验依赖 Spring AOP，不能是 private/static/final 方法

- Spring AOP 只能拦截 **public 方法**
- 如果你写的是 `private` 或 `final`，校验不生效

```java
public final void deleteUser(...) { } // ❌ 不会触发校验
```

## 3. 与 `@Valid` 的区别：支持分组校验（@Valid 不支持）

你可以为不同业务场景定义不同校验分组：
```java
public class UserDTO {
    @NotNull(groups = Create.class)
    private String username;

    @NotNull(groups = Update.class)
    private String id;
}
```

然后这样使用：
```java
@PostMapping("/add")
public void add(@Validated(Create.class) @RequestBody UserDTO user) {
    // 只校验 Create 分组相关的字段
}
```

## 4. 用在 Controller 方法参数时，也可以支持分组

```java
@GetMapping("/check")
public void check(@Validated(Update.class) @RequestBody UserDTO user) {
    // 与上面用法类似
}
```

## 5. `@Validated` 与 `@Valid` 可以一起使用，但不能互相替代

| 位置                 | 用哪个            |
| ------------------ | -------------- |
| DTO 内部嵌套对象         | `@Valid` ✅     |
| Service 方法参数       | `@Validated` ✅ |
| 分组校验               | `@Validated` ✅ |
| 简单 Controller 参数校验 | `@Valid` 就够了 ✅ |

## 6. 校验异常默认是 `ConstraintViolationException`

当方法参数不满足约束条件时，Spring 会抛出：
```plaintext
javax.validation.ConstraintViolationException
```

你可以用 `@ControllerAdvice` 捕获：
```java
@ExceptionHandler(ConstraintViolationException.class)
public ResponseEntity<?> handle(ConstraintViolationException ex) {
    return ResponseEntity.badRequest().body(ex.getMessage());
}
```

## 常见踩坑总结

|问题|原因|
|---|---|
|方法参数加了 `@NotBlank` 但校验不生效|类上没加 `@Validated`|
|嵌套字段没被校验|缺少 `@Valid`|
|分组校验无效|用的是 `@Valid` 而不是 `@Validated`|
|方法是 private/static|AOP 拦截不到，校验不执行|

## 7、结论

- `@Validated` 是 **Spring 用于方法参数校验和分组校验的关键注解**
- 在 **类或接口** 上使用，启用方法参数校验
- 支持 `groups`，是 `@Valid` 所不具备的能力
- 一般与 `@NotNull`、`@Size` 等一起用

需要的话，我可以补充一个 [方法级参数校验示例](https://chatgpt.com/c/f)、[分组校验实战代码](https://chatgpt.com/c/f)，或 [@Validated vs @Valid 图表对比](https://chatgpt.com/c/f)。你想看哪个？


# 5、@MockBean

`@MockBean` 注解。这是一个在 Spring Boot 测试中极其重要和常用的注解。

### 1. 它是什么？

`@MockBean` 是一个由 Spring Boot Test 提供的注解，它用于在 **Spring 的 `ApplicationContext`** 中为一个 Bean 定义一个 **Mockito  mock** 对象。

它的核心作用是：**在==集成测试中==，用 Mock 对象==临时替换==掉 Spring ==容器中的某个真正的 Bean==**。

### 2. 为什么要使用它？

想象一下你在测试一个 `UserService`，它又依赖了一个 `EmailService`。
```java
@Service
public class UserService {
    @Autowired
    private EmailService emailService;

    public void registerUser(String email) {
        // ... 一些注册逻辑 ...
        emailService.sendWelcomeEmail(email); // 需要被模拟的调用
    }
}
```

在测试 `UserService` 时，你并不关心 `EmailService` 是否真的发出了邮件（这可能很慢，而且需要复杂的配置）。你只关心 `UserService` 的**逻辑**是否正确，即它是否**调用了** `emailService.sendWelcomeEmail(email)` 方法。

`@MockBean` 允许你将真实的 `EmailService` Bean 替换成一个“假”的 Mock 对象，这样你就可以：
1.  **隔离测试**：专注于当前组件的测试，排除其他依赖组件的影响。
2.  **定义行为**：指定这个 Mock 对象在被调用时应该返回什么值或抛出什么异常。
3.  **验证交互**：验证测试过程中，你的代码是否按预期调用了这个依赖的方法。

### 3. 如何使用它？

`@MockBean` 通常用在测试类上。

#### 基本用法：字段注入

```java
@SpringBootTest // 启动完整的Spring应用上下文
class UserServiceTest {

    @Autowired
    private UserService userService; // 要测试的真实Bean

    @MockBean // 在容器中创建一个EmailService的Mock，并替换掉原有的真实Bean
    private EmailService emailService;

    @Test
    void shouldSendEmailWhenUserRegisters() {
        // 1. 准备：给定一个邮箱地址
        String userEmail = "test@example.com";

        // 2. 执行：调用真实的服务方法
        userService.registerUser(userEmail);

        // 3. 断言：验证Mock的emailService的sendWelcomeEmail方法被调用了一次，且参数是userEmail
        verify(emailService, times(1)).sendWelcomeEmail(userEmail);
    }

    @Test
    void shouldHandleEmailFailure() {
        String userEmail = "test@example.com";

        // 定义Mock对象的行为：当方法被调用时，模拟抛出异常
        doThrow(new RuntimeException("SMTP failure"))
                .when(emailService)
                .sendWelcomeEmail(userEmail);

        // 验证你的服务是否能妥善处理异常
        assertThrows(RuntimeException.class, () -> {
            userService.registerUser(userEmail);
        });

        verify(emailService).sendWelcomeEmail(userEmail);
    }
}
```

#### 用法：方法参数注入（在 `@BeforeEach` 中很常用）

你也可以将 `@MockBean` 作为测试方法参数，Spring 会自动将其注入。

```java
@SpringBootTest
class UserServiceTest {

    @Autowired
    private UserService userService;

    @Test
    void shouldSendEmailWhenUserRegisters(@MockBean EmailService emailService) {
        // ... 测试逻辑与上面相同
        userService.registerUser("test@example.com");
        verify(emailService).sendWelcomeEmail("test@example.com");
    }
}
```

#### 用法：在 `@TestConfiguration` 中声明

如果你想在多个测试类中重用一组特定的 Mock 配置，可以这样做：

```java
@TestConfiguration
public class TestConfig {
    @MockBean
    public EmailService emailService;
}

@SpringBootTest
@Import(TestConfig.class) // 导入包含Mock配置的类
class UserServiceTest {
    // ...
}
```

### 4. `@MockBean` 与 `@Mock` 的区别

这是一个非常重要的区别：

| 特性 | `@Mock` (来自 Mockito) | `@MockBean` (来自 Spring Boot Test) |
| :--- | :--- | :--- |
| **框架** | 纯 Mockito | Spring Boot Test（内部集成了 Mockito） |
| **用途** | 标准的单元测试 | **Spring 的集成测试** |
| **Spring 上下文** | **不需要** | **需要**。它会与 Spring 的 `ApplicationContext` 交互。 |
| **核心作用** | 创建一个简单的 Mock 对象 | 在 Spring 容器中**注册或替换**一个 Bean 为 Mock 对象 |
| **依赖注入** | 需要手动注入到被测试对象中 | **自动**被 Spring 注入到需要它的 Bean 中 |

**简单总结：**
*   如果你的测试**不启动 Spring 上下文**（例如使用 `MockitoJUnitRunner`），用 `@Mock`。
*   如果你的测试**启动了 Spring 上下文**（例如使用 `@SpringBootTest`），并且你想模拟容器中的一个 Bean，用 `@MockBean`。

### 5. 注意事项

1.  **性能**：使用 `@SpringBootTest` 会加载整个应用上下文，比纯单元测试慢。只在需要测试容器集成（如 Bean 注入、JDBC、Web MVC 等）时使用。
2.  **作用域**：在测试类上定义的 `@MockBean` 会在该类的**每一个测试方法执行后被自动重置**。这意味着在一个测试中设定的行为（如 `when(...).thenReturn(...)`）不会泄漏到下一个测试中。
3.  **特定 Bean**：你可以通过 `@MockBean(name = "mySpecificBean")` 来指定要替换的 Bean 的名称，这在有多个同类型 Bean 时非常有用。

### 总结

`@MockBean` 是 Spring Boot 测试工具包中一把强大的“瑞士军刀”，它让你能够轻松地编写**聚焦的、快速的、可靠的集成测试**，通过将棘手的或不相关的依赖项模拟掉，从而只测试你真正关心的逻辑。

# 6、@Import注解

基于 **Spring Boot 3.1.5** 和 **Spring Framework 6.0.13** 的源码，来分析 **@Import 注解的原理及作用**。

## 6.1、`@Import` 的作用

- 允许在 `@Configuration` 或 `@Component` 类上通过注解导入其他类，让 Spring 将这些类注册为 Bean。
- 可导入的类型：
    1. 普通 `@Configuration` 或组件类（注册为 BeanDefinition）
    2. 实现 `ImportSelector` 的类（动态选择要导入的配置类）
    3. 实现 `ImportBeanDefinitionRegistrar` 的类（手动注册 BeanDefinition）
**==注解 `@Import` 是 Spring 配置类解析机制 的重要扩展点，也是 Spring Boot <font color="blue" size=5>自动装配的核心</font>。==**

## 6.2、入口：`ConfigurationClassPostProcessor`

- `@Import` 的解析发生在 **BeanDefinition 解析阶段**，即 `AbstractApplicationContext.invokeBeanFactoryPostProcessors()`。
- `ConfigurationClassPostProcessor` 是关键处理器。

源码（Spring 6.0.13）：
```java
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    processConfigBeanDefinitions(registry);
}
```

`processConfigBeanDefinitions()` 内部使用 `ConfigurationClassParser` 解析所有配置类。

## 6.3、源码调用链（Spring Boot 3.1.5）

```java
SpringApplication.run()
   └─ AbstractApplicationContext.refresh()
       └─ invokeBeanFactoryPostProcessors()
           └─ ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()
               └─ ConfigurationClassParser.parse()
                   └─ ConfigurationClassParser.processImports()
                       ├─ 处理普通类
                       ├─ 处理 ImportSelector
                       └─ 处理 ImportBeanDefinitionRegistrar
```

### 关键方法：`ConfigurationClassParser.processImports()`

源码逻辑（精简）：
```java
private void processImports(ConfigurationClass configClass, 
        SourceClass currentSourceClass, 
        Collection<SourceClass> importCandidates, ...) {

    for (SourceClass candidate : importCandidates) {
        Class<?> importedClass = candidate.loadClass();
        if (ImportSelector.class.isAssignableFrom(importedClass)) {
            // 处理 ImportSelector
        }
        else if (ImportBeanDefinitionRegistrar.class.isAssignableFrom(importedClass)) {
            // 处理 ImportBeanDefinitionRegistrar
        }
        else {
            // 普通配置类，直接注册 BeanDefinition
            this.configurationClasses.add(new ConfigurationClass(candidate));
        }
    }
}
```

## 6.4、@Import 三种模式

### 6.4.1、导入普通类

```java
@Configuration
@Import(MyService.class)
public class AppConfig {}
```

- Spring 将 `MyService` 注册为 BeanDefinition。
- 等价于 XML `<bean class="MyService"/>`。

### 6.4.2、导入 `ImportSelector`

```java
public class MyImportSelector implements ImportSelector {
    public String[] selectImports(AnnotationMetadata metadata) {
        return new String[]{"com.example.BeanA", "com.example.BeanB"};
    }
}
```

- 可根据条件动态返回要导入的配置类。
- Spring Boot 的 `EnableAutoConfigurationImportSelector` 就是基于此。

### 6.4.3、导入 `ImportBeanDefinitionRegistrar`

```java
public class MyRegistrar implements ImportBeanDefinitionRegistrar {
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
        registry.registerBeanDefinition("myBean", new RootBeanDefinition(MyBean.class));
    }
}
```

- 可以手动注册 BeanDefinition，完全控制 Bean 元数据。

## 6.5、@Import 与 Spring Boot 自动装配

- `@EnableAutoConfiguration` 自身就是通过 `@Import(AutoConfigurationImportSelector.class)` 工作的。
- `AutoConfigurationImportSelector` 读取 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 文件，动态导入 Starter 配置类。

调用链：
```
@EnableAutoConfiguration
   └─ @Import(AutoConfigurationImportSelector.class)
       └─ selectImports()
           └─ 加载所有自动配置类
```

## 6.5、原理总结

- `@Import` 通过 `ConfigurationClassPostProcessor` 解析，在 **BeanDefinition 注册阶段** 将指定类加载到容器。
- 支持三种模式：
    - 普通类 → 直接注册
    - ImportSelector → 动态返回配置类名
    - ImportBeanDefinitionRegistrar → 手动注册 BeanDefinition
- 是 Spring Boot 自动装配的底层机制。

## 6.6、@Import注解与@ComponentScan注解的区别

`@Import` 和 `@ComponentScan` 最终目的都是向Spring容器中注册Bean，但它们的**工作机制、设计意图和使用场景有本质区别**。
- **`@ComponentScan` 像“校园招聘”**：HR（Spring）去指定的学校（基础包路径）里，根据专业（注解类型如 `@Component`, `@Service`）批量招聘应届生（Bean）。
- **`@Import` 像“社会招聘”或“猎头推荐”**：HR（Spring）根据公司需求，精确地引入一位特定的资深专家（配置类或特定类）或一个完整的团队（模块）。

核心区别对比表：

| 特性   | `@ComponentScan`                                                    | `@Import`                                                                                                    |
| ---- | ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| 工作机制 | **==扫描（Scanning）==**：在指定的包路径下，**批量、递归地扫描**带有特定注解（如 `@Component`）的类。 | **==导入（Importing）==**：**精确、直接地引入**一个或多个特定的类。                                                                 |
| 注册方式 | **隐式/声明式**：通过在类上添加标记性注解（如 `@Service`）来声明这是一个Bean。                   | **显式/程序式**：直接指定要引入的类，这个类本身可能就是一个显式配置（`@Configuration`）。                                                      |
| 粒度   | **粗粒度**：操作单位是**包（Package）**。你告诉Spring“去这个包里找”，具体找到什么Bean由扫描结果决定。    | **细粒度**：操作单位是**类（Class）**。你明确告诉Spring“请引入这个类”。                                                               |
| 主要用途 | 注册**业务组件**（如Service, Controller, Repository等你自己编写的业务类）。             | 1. 引入**配置类**（拆分大型配置）。  <br>2. 引入**第三方库的组件**（这些类你不能修改源码去加注解）。  <br>3. 实现**高级功能**（如使用`ImportSelector`进行条件化加载）。 |
| 依赖关系 | 被扫描的类必须位于你指定的包路径下。                                                  | 被导入的类必须在类路径（Classpath）上，但**位置任意**。                                                                           |

# 7、@ComponentScan注解

好的，我们来详细介绍一下 Spring 框架中非常重要的 `@ComponentScan` 注解。

## 7.1、定义与作用

`@ComponentScan` 是 Spring 框架的核心注解之一，位于 `org.springframework.context.annotation` 包中。它的主要作用是**指示 Spring 容器去扫描指定的包及其子包，自动发现和注册带有特定注解的类为 Spring Bean**。

简单来说，它实现了 Spring 的"**组件自动发现**"机制，避免了手动在配置文件中声明每一个 Bean。

## 7.2、核心功能

### 7.2.1、自动扫描与注册
Spring 会扫描指定包路径下所有带有以下注解的类，并自动将它们注册为 Bean：
- `@Component`（通用组件）
- `@Service`（业务层组件）
- `@Repository`（数据访问层组件）
- `@Controller`（Web 控制层组件）
- `@Configuration`（配置类）

### 7.2.2、替代 XML 配置
在 Spring 3.0 之前，我们需要在 XML 中配置组件扫描：
```xml
<context:component-scan base-package="com.example.app"/>
```

现在使用注解方式更加简洁：
```java
@Configuration
@ComponentScan("com.example.app")
public class AppConfig {
}
```

## 7.3、常用属性详解

### 7.3.1、`basePackages` / `value` - 指定扫描包
```java
// 方式1：扫描单个包
@ComponentScan("com.example.service")

// 方式2：扫描多个包
@ComponentScan(basePackages = {"com.example.service", "com.example.dao"})

// 方式3：使用value（与basePackages等价）
@ComponentScan(value = "com.example.service")
```

### 7.3.2、`basePackageClasses` - 通过类反推包路径
```java
@ComponentScan(basePackageClasses = {UserService.class, UserDao.class})
```
Spring 会扫描这些类所在的包及其子包。这种方式是**类型安全**的，重构时IDE会帮助更新。

### 7.3.3、`includeFilters` - 包含过滤器
指定哪些组件应该被包含，即使它们没有标准的注解。
```java
@ComponentScan(
    basePackages = "com.example",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.ANNOTATION, 
        classes = CustomAnnotation.class
    )
)
```

### 7.3.4、`excludeFilters` - 排除过滤器
排除特定的组件，不注册为 Bean。
```java
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = {
        // 排除带有@Controller注解的类
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Controller.class),
        // 排除特定的类
        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = ExcludedService.class)
    }
)
```

### 7.3.5、`useDefaultFilters` - 是否使用默认过滤器
默认为 `true`，即自动检测 `@Component`, `@Service`, `@Repository`, `@Controller` 注解。设置为 `false` 时，只扫描显式包含的组件。

```java
@ComponentScan(
    basePackages = "com.example",
    useDefaultFilters = false,
    includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = ".*CustomComponent")
)
```

## 7.4、过滤器类型（FilterType）

Spring 提供了多种过滤方式：

| 过滤类型 | 说明 | 示例 |
|---------|------|------|
| `ANNOTATION` | 按注解过滤 | `@ComponentScan.Filter(type=ANNOTATION, classes=Service.class)` |
| `ASSIGNABLE_TYPE` | 按类或接口过滤 | `@ComponentScan.Filter(type=ASSIGNABLE_TYPE, classes=UserService.class)` |
| `REGEX` | 按正则表达式过滤类名 | `@ComponentScan.Filter(type=REGEX, pattern=".*Service")` |
| `ASPECTJ` | 使用 AspectJ 表达式 | `@ComponentScan.Filter(type=ASPECTJ, pattern="com.example..*Service")` |
| `CUSTOM` | 自定义过滤逻辑 | 实现 `TypeFilter` 接口 |

## 7.5、实际应用示例

### 示例1：基础扫描配置
```java
@Configuration
@ComponentScan(
    basePackages = {"com.example.service", "com.example.dao"},
    excludeFilters = @ComponentScan.Filter(Controller.class)
)
public class AppConfig {
    // 这个配置会扫描service和dao包，但排除所有Controller
}
```

### 示例2：多环境配置
```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION, 
            classes = Repository.class
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX, 
            pattern = ".*Test.*"
        )
    }
)
public class TestConfig {
    // 测试环境配置：排除Repository组件和所有包含Test的类
}
```

### 示例3：自定义过滤器
```java
public class CustomTypeFilter implements TypeFilter {
    @Override
    public boolean match(MetadataReader metadataReader, 
                        MetadataReaderFactory metadataReaderFactory) {
        // 自定义过滤逻辑：只包含类名以"Impl"结尾的类
        return metadataReader.getClassMetadata()
                            .getClassName().endsWith("Impl");
    }
}

@Configuration
@ComponentScan(
    basePackages = "com.example",
    useDefaultFilters = false,
    includeFilters = @ComponentScan.Filter(
        type = FilterType.CUSTOM, 
        classes = CustomTypeFilter.class
    )
)
public class CustomFilterConfig {
}
```

## 7.6、在 Spring Boot 中的特殊用法

Spring Boot 的 `@SpringBootApplication` 注解已经包含了 `@ComponentScan`：

```java
@SpringBootApplication
// 等价于：
// @SpringBootConfiguration
// @EnableAutoConfiguration
// @ComponentScan  // 默认扫描主类所在包及其子包
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### 覆盖默认扫描路径
```java
@SpringBootApplication
@ComponentScan(basePackages = {
    "com.example.app",
    "com.example.shared"
})
public class Application {
    // 显式指定扫描包，覆盖默认行为
}
```

## 7.7、最佳实践与注意事项

1. **包结构规划**：合理规划包结构，避免扫描不必要的包，提高启动性能
2. **类型安全**：优先使用 `basePackageClasses` 而非字符串包名
3. **排除策略**：合理使用排除过滤器，避免冲突组件被注册
4. **性能考虑**：扫描范围不宜过大，避免扫描第三方jar包
5. **与@Import配合**：`@ComponentScan` 用于扫描业务组件，`@Import` 用于引入配置类

## 7.8、总结

**`@ComponentScan` 是 Spring 实现"约定优于配置"理念的核心注解，它通过自动扫描和注册组件，极大地简化了 Spring 应用的配置工作。正确使用它的各种属性（特别是过滤器）可以实现精细化的组件管理，是构建模块化、可维护 Spring 应用的重要工具。**

它的核心价值在于：**让开发者专注于业务逻辑的实现，而不是繁琐的 Bean 配置**。
