提高系统稳定性、健壮性、为企业切实降低开发成本

# 单测理论

## 什么是单元测试

单元测试(unittesting)，是指**对软件中的最小可测试单元进行检查和验证**。

对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，**Java里单元指一个类/函数**，图形化的软件中可以指一个窗口或一个菜单等。

总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。

## 测试金字塔

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061628490.png)

1. **单元测试**: 又称 **==模块测试==**（也有称为方法测试），是针对软件设计的最小单位——程序模块进行正确性检验的测试工作。其 **==目的在于检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误==**。单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试；
   **==单元测试是整个测试金字塔的基石，单元测试的质量高低对整个系统的健壮性影响很大==**
2. **集成测试**: 也叫做 **==组装测试==**（也有称为模块测试）。通常在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统
3. **确认测试**: 也叫有效性测试。是在模拟的环境下，验证软件的所有功能和性能及其他特性是否与用户的预期要求一致。通过了确认测试之后的软件，才具备了进入系统测试阶段的资质
4. **系统测试**: 是在真实的系统运行的环境下，检查完整的程序系统能否和系统（包括硬件、外设、网络和系统软件、支持平台等）正确配置、连接，并最终满足用户的所有需求
5. **验收测试**: **==UAT,用户验收测试**==，是软件正式上线前的最后一道测试关卡。它的核心目的是**让真实的最终用户（或业务代表）来验证软件是否满足业务需求，以及是否“可用、好用”**。按照项目任务书或合同、供需双方约定的验收依据文档进行的对整个系统的测试与评审，决定是否接收或拒收系统。

## 缺陷与成本

1. 缺陷暴露越晚成本越高：无论缺陷的严重程度如何，越晚发现则伤害越大，缺陷的成本与发现他们所花费的时间成正比。
2. 消除缺陷和返工占用大量成本：软件开发的很大一部分成本包括错误消除和项目返工。返工过程的成本高于初始过程，因此有必要在设计和需求阶段及早发现缺陷以避免这种额外费用。大量的缺陷通常发生在项目的初始阶段，早期的缺陷检测将降低项目的总体成本。
3. 越晚解决缺陷成本越高：即使是微小的缺陷，在后期进行根本原因分析和回归测试时，也会花费巨大的成本；后期发现的缺陷一般不是犹豫缺少代码或者录入错误造成的，而是更加的隐蔽。
4. 缺陷都是在早期引入的：大量的缺陷都是在需求阶段、设计阶段引入的，而在编码期如果有充分的单元测试，就很容易发现这些问题。

## 质量差的原因和解决方案

1. **关注流程错误而不是代码错误**；代码错误并不是引发缺陷的根本原因，代码错误只是一个表象，而是流程错误导致的，流程更需要改进。
   - 是否任何测试用例都被阻塞到最后一分钟才得以解决
   - 是否单元测试覆盖率很低
   - 是否在即将要进行验收测试时还在进行代码的修改
   - 是否经常发生紧急错误
2. **改善流程和机制**；很多公司都遵循严格的时间表和敏捷开发流程，缺陷数量直线飙升，需要强有力的措施，很多预防机制。
   - 提高代码评审覆盖率，加强代码审查、code review
   - 提高单元测试覆盖率，要覆盖到所有的核心代码行
   - 构建单元测试自动化，对于不断迭代的系统，能够保障新修改的代码不影响原有功能
   - 足够多的测试用例，测试用例要具有足够的覆盖度

# 单测规范与原则

## 工程目录规范

1. `src/main/java`：应用程序Java Source目
2. `src/main/resource`：应用程序资源文件目录
3. `src/test/java`：应用程序单元测试Java Source目录
4. `src/test/resource`：应用程序单元测试资源文件目录(为自动化测试准备)

## 测试用例规范

1. 包名一致性: `src/test/java`下的包名 和 对应的src/main/java下的包名保持一致
2. 类名命名规范: `类名+Test`
   - 例1：`UserServiceTest`
   - 例2：`OrderControllerTest`
3. 测试方法命名规范：要求易读、易于理解，`test方法名_测试条件`
   - 例3：`testAddUserById_less_10`         测试addUserById方法，当id小于10的时候
   - 例4：`testAddUserById_not_less_10`  测试addUserById方法，当id不小于10的时候

## AIR原则

单元测试在线上运行时，应该像空气（AIR)一样感觉不到存在。

1. **A：Automatic，自动化**
   - 单元测试应该是全自动执行的，而非交互式的；可以在项目构建过程中执行，定期执行。
   - 单元测试的结果不需要人工检查，而是用assert断言来验证。
2. **I：Independent，独立性**
   - 保持单元测试的独立性，是为了保证单元测试的稳定性与可靠性，单元测试用例之间决不能相互调用，也不能依赖于彼此的先后执行顺序。
3. **R：Repeatable，可重复性**
   - 单元测试可重复执行的，不能受外界环境的限制。
   - 为了不受外界环境的影响，要求设计代码时就把sut的依赖改成注入，在测试时用spring这样的DI框架注入到一个本地实现或者Mock实现。

## BCDE原则

BCDE原则：编写单元测试代码要遵循BCDE原则，保证模块的交付质量

1. B: Border，**边界值测试**，包括循环边界、特殊取值、特殊时间点，数据顺序。
2. C: Correct，**正确的输入**，并得到预期的结果。
3. D: Design，**与设计文档相结合**，来编写单元测试。
4. E: Error，**单元测试的目的是证明程序有错**，而不是证明程序无错。为了发现代码中潜在的错误， 我们需要在编写测试用例时有一些强制的错误输入（如非法数据、异常流程、非业务允许输入等）来得到预期的错误结果

## 其他原则

- **粒度小**：对于单元测试，要保证测试粒度满足单一和小，能够精准定位问题，单测粒度要控制在方法级别。
- **核心通过率高**：核心业务、应用、模块、方法的单元测试要确保通过率为100%。
- **执行速度快**：单个测试用例执行时间不能超过10秒，整个项目的单测时间控制在20分钟以内。
- **覆盖率高**：整体语句、核心模块的语句覆盖率、分支覆盖率都要达到100%。
- **避免数据污染**：如果需要执行数据库相关测试，要设定回滚或打标机制。

# 单元测试实战

## 单测工具

1. Junit：[https://junit.org/junit5/](https://junit.org/junit5/)
2. Spring Test：[https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/testing.html](https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/testing.html)
3. AssertJ：断言库，[https://joel-costigliola.github.io/assertj/](https://joel-costigliola.github.io/assertj/)
4. Hamcrest：断言库/谓词库，[http://hamcrest.org/JavaHamcrest/index](http://hamcrest.org/JavaHamcrest/index)
5. Mockito：Mock框架，[https://site.mockito.org/](https://site.mockito.org/)
6. JSONassert：json断言库，[https://github.com/skyscreamer/JSONassert](https://github.com/skyscreamer/JSONassert)
7. JsonPath：json版本的XPath，[https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath)
8. TestableMock: Mock框架, [https://alibaba.github.io/testable-mock/#/](https://alibaba.github.io/testable-mock/#/)
## Maven 引入  Mokito框架依赖

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061800760.png)

## Spring 集成  Mokito框架

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061800340.png)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061801915.png)

## 什么是Mock

模拟被测试对象的依赖（包括数据和行为）
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061802269.png)

## Mokito mock对象

创建mock对象的三种方式：
1. 使用`Mockito.mock(xxx.class)`静态方法来mock对象；示例：`com.demo.unit.mokito.MockitoTest1`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.Test;  
import org.mockito.Mockito;  
import java.util.List;  
  
/**  
 * Mockito 入门-demo1  
 */
public class MockitoTest1 {  
    public void testMock(){  
        //mock一个List对象  
        List mock = Mockito.mock(List.class);  
        //是否能够成功添加数据?  
        mock.add(1);  
  
        //输出mock对象的真实类  
        System.out.println("mock.getClass().getName() = " + mock.getClass().getName());  
        //从mock对象中取出mock.add(1);添加的数据  
        System.out.println("mock.get(0) = " + mock.get(0));  
    }  
}
```

运行结果解析：
```java
//mock出来的对象，并不是真实的List对象本身  
mock.getClass().getName() = org.mockito.codegen.List$MockitoMock$gDRImbIO  
//由于mock出来的对象并不是真实的List对象本身，因此调用add(1)方法添加的数据，其实无法真实添加成功，因此这里返回的是null  
mock.get(0) = null
```

2. 使用`@Mock`注解方式来mock对象，使用`@ExtendWith(MockitoExtension.class)`注解来开启Mock注解；`com.demo.unit.mokito.MockitoTest2`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.Mock;  
import org.mockito.junit.jupiter.MockitoExtension;  
import java.util.List;  
  
/**  
 * Mockito 入门-demo2  
 * 第二种方式就是使用 @Mock 注解方式来创建 Mock 对象，使用该方式创需要注意的是要在运行测试方法前使用 MockitoAnnotations.initMocks(this) ；  
 * 或者单元测试类上加上 @ExtendWith(MockitoExtension.class) 注解。
 */  
@ExtendWith(MockitoExtension.class)  
public class MockitoTest2 {  
  
    //mock对象  
    @Mock  
    private List<String> mockList;  
  
    @Test  
    public void testMock(){  
        //是否能够成功添加数据?  
        mockList.add("demo");  
  
        //输出mock对象的真实类  
        System.out.println("mockList.getClass().getName() = " + mockList.getClass().getName());  
        //从mock对象中取出mock.add(1);添加的数据  
        System.out.println("mockList.get(0) = " + mockList.get(0));  
    }  
}
```

运行结果解析：
```java
//mock出来的对象，并不是真实的List对象本身
mockList.getClass().getName() = org.mockito.codegen.List$MockitoMock$5M7KLhN8
//由于mock出来的对象并不是真实的List对象本身，因此调用add("demo")方法添加的数据，其实无法真实添加成功，因此这里返回的是null
mockList.get(0) = null
```

3. 使用`MockitoAnnotations.initMocks(this);` 和  `MockitoAnnotations.openMocks(this);` 方法来开启Mock注解。其中`initMocks`方法已经不推荐使用；示例：`com.demo.unit.mokito.MockitoTest3`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.BeforeEach;  
import org.junit.jupiter.api.Test;  
import org.mockito.Mock;  
import org.mockito.MockitoAnnotations;  
import java.util.List;  
  
/**  
 * Mockito 入门-demo3  
 * 使用MockitoAnnotations.initMocks(this); 和 MockitoAnnotations.openMocks(this); 方法来开启Mock注解。其中initMocks方法已经不推荐使用  
 * (PS: @BeforeEach 是 Junit 5 的注解，功能类似于 Junit 4 的 @Before 注解。)：  
 */  
public class MockitoTest3 {  
  
    @Mock  
    private List<String> mockList;  
  
    @BeforeEach  
    public void beforeEach(){  
        //initMocks已经过时,不推荐使用  
        //MockitoAnnotations.initMocks(this);  
        MockitoAnnotations.openMocks(this);  
    }  
  
    @Test  
    public void testMock(){  
        //是否能够成功添加数据?  
        mockList.add("demo");  
  
        //输出mock对象的真实类  
        System.out.println("mockList.getClass().getName() = " + mockList.getClass().getName());  
        //从mock对象中取出mock.add(1);添加的数据  
        System.out.println("mockList.get(0) = " + mockList.get(0));  
    }  
}
```

运行结果解析：
```java
//mock出来的对象，并不是真实的List对象本身
mockList.getClass().getName() = org.mockito.codegen.List$MockitoMock$COZmkpfI
//由于mock出来的对象并不是真实的List对象本身，因此调用add("demo")方法添加的数据，其实无法真实添加成功，因此这里返回的是null
mockList.get(0) = null
```

## Mokito 验证性测试

**==场景：验证方法是否被调用过、验证方法调用指定次数、验证方法调用顺序==**

示例：`com.demo.unit.mokito.MockitoTest4`
1. 核心方法：
   - `org.mockito.Mockito#verify(T, VerificationMode)`
   - `org.mockito.InOrder#verify(T)`
2. 参数说明：
   - T 代表被mock的对象
   - `org.mockito.verification.VerificationMode`代表验证模式（调用次数）
   - `VerificationModeFactory`工厂类提供了很多返回验证模式的方法，并且在Mockito类中进行了封装。
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.InOrder;  
import org.mockito.Mock;  
import org.mockito.junit.jupiter.MockitoExtension;  
import java.util.List;  
//静态引入Mockito类  
import static org.mockito.Mockito.*;  
  
/**  
 * Mockito 入门-demo4-调用验证  
 */  
@ExtendWith(MockitoExtension.class)  
public class MockitoTest4 {  
  
    //mock对象  
    @Mock  
    private List<String> mockList;  
  
    /**  
     * 测试是否有调用  
     */  
    @Test  
    public void testMock_verify1() {  
        //是否能够成功添加数据?  
        mockList.add("demo");  
        //验证mock对象是否调用了add("demo")方法  
        verify(mockList).add("demo");  
    }  
  
    /**  
     * 测试是否有调用  
     */  
    @Test  
    public void testMock_verify2() {  
        //是否能够成功添加数据?  
        mockList.add("demo");  
        //验证mock对象是否调用了add("test")方法，注意只是参数不同  
        verify(mockList).add("test");  
    }  
  
    /**  
     * 测试调用次数  
     */  
    @Test  
    public void testMock_verify3() {  
        mockList.add("demo");  
        mockList.get(0);  
        mockList.add("demo");  
        mockList.add("demo");  
        mockList.size();  
        mockList.size();  
  
        //验证mock对象是否调用了add("demo")方法2次  
        verify(mockList,times(3)).add("demo");  
        //验证mock对象是否调用了add("demo")方法至少1次  
        verify(mockList,atLeastOnce()).add("demo");  
        //验证mock对象是否调用了add("demo")方法至少2次  
        verify(mockList,atLeast(3)).add("demo");  
        //验证mock对象是否调用了get(0)方法最多1次  
        verify(mockList,atMostOnce()).get(0);  
        //验证mock对象是否调用了size()方法最多2次  
        verify(mockList,atMost(2)).size();  
        //验证mock对象是否从来没有调用过remove(0)方法  
        verify(mockList,never()).remove(0);  
    }  
  
    /**  
     * 测试调用顺序  
     */  
    @Test  
    public void testMock_verify5() {  
        mockList.size();  
        mockList.get(1);  
        mockList.remove(0);  
        mockList.get(0);  
  
        //创建顺序验证对象,使用Mockito.inOrder方法  
        InOrder inOrder = inOrder(mockList);  
        //验证调用顺序  
        inOrder.verify(mockList).size();  
        inOrder.verify(mockList).get(0);  
        inOrder.verify(mockList).get(1);  
        inOrder.verify(mockList).remove(0);  
    }  
  
    /**  
     * 测试调用顺序  
     */  
    @Test  
    public void testMock_verify6() {  
        mockList.size();  
        mockList.get(1);  
        mockList.get(0);  
        mockList.remove(0);  
  
        //创建顺序验证对象,使用Mockito.inOrder方法  
        InOrder inOrder = inOrder(mockList);  
        //验证调用顺序  
        inOrder.verify(mockList).size();  
        inOrder.verify(mockList).get(1);  
        inOrder.verify(mockList).get(0);  
        inOrder.verify(mockList).remove(0);  
    }  
  
    /**  
     * only 只掉用过1个方法  
     */  
    @Test  
    public void testMock_verify7() {  
        mockList.get(0);  
        //mockList.add("demo");  
        //验证：只掉用过get(0)这个方法  
        verify(mockList,only()).get(0);  
    }  
}
```

## Mokito mock方法返回值

**==场景：mock方法返回值场景、mock方法抛出异常、mock方法返回变化性返回值==**

示例：`com.demo.unit.mokito.MockitoTest5`
```java
package com.demo.unit.mokito;  
  
import com.demo.unit.po.TUser;  
import org.junit.jupiter.api.Assertions;  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.Mock;  
import org.mockito.invocation.InvocationOnMock;  
import org.mockito.junit.jupiter.MockitoExtension;  
import org.mockito.stubbing.Answer;  
  
import java.util.List;  
  
import static org.mockito.Mockito.*;  
  
/**  
 * Mockito 入门-demo5-方法返回模拟  
 */  
@ExtendWith(MockitoExtension.class)  
public class MockitoTest5 {  
  
    //mock对象  
    @Mock  
    private List<Integer> mockList;  
    @Mock  
    private List<TUser> mockUserList;  
  
    @Test  
    public void testMock_return1() {  
        //当调用mockList.get(0)方法的时候，会返回10  
        when(mockList.get(0)).thenReturn(10);  
        System.out.println("mockList.get(0) = " + mockList.get(0));  
        System.out.println("mockList.get(0) = " + mockList.get(0));  
  
        //当调用mockList.get(1)方法的时候，会依次返回1、2、3，当调用多余3次之后，会依然返回3  
        when(mockList.get(1)).thenReturn(1,2,3);  
        System.out.println("mockList.get(1) = " + mockList.get(1));  
        System.out.println("mockList.get(1) = " + mockList.get(1));  
        System.out.println("mockList.get(1) = " + mockList.get(1));  
        System.out.println("mockList.get(1) = " + mockList.get(1));  
  
        //当调用mockList.get(2)方法的时候，会依次返回9、8、7  
        when(mockList.get(2)).thenReturn(9).thenReturn(8).thenReturn(7);  
        System.out.println("mockList.get(2) = " + mockList.get(2));  
        System.out.println("mockList.get(2) = " + mockList.get(2));  
        System.out.println("mockList.get(2) = " + mockList.get(2));  
  
        //当调用mockUserList.get(0)方法时，返回对象  
        TUser tUser = new TUser();  
        tUser.setUserid(1);  
        tUser.setPassword("123456");  
        tUser.setUsername("zhangsan");  
        tUser.setPhone("phone");  
        when(mockUserList.get(0)).thenReturn(tUser);  
        System.out.println("mockUserList.get(0) = " + mockUserList.get(0));  
    }  
  
    @Test  
    public void testMock_exception() {  
        //模拟当调用mockList.get(0)方法时抛出RuntimeException异常  
        when(mockList.get(0)).thenThrow(RuntimeException.class);  
        //断言：调用get(0)方法,会抛出RuntimeException异常  
        Assertions.assertThrows(RuntimeException.class,()->mockList.get(0));  
    }  
  
    /**  
     * 自定义应答（返回值）  
     */  
    @Test  
    public void testMock_answer() {  
        //anyInt()模拟的是任意int参数，代表调用add(任意int参数)，都会返回某返回值  
        //thenAnswer()方法需要实现Answer接口，从而实现返回值的自定义逻辑  
        when(mockList.add(anyInt())).thenAnswer(new Answer<Boolean>() {  
            @Override  
            public Boolean answer(InvocationOnMock invocation) throws Throwable {  
                // invocation.getArguments 可获取调用参数；  
                // 当参数大于10的时候返回true，否则返回false  
                Integer argument = (Integer) invocation.getArguments()[0];  
                System.out.println("argument = " + argument);  
                return argument>10;  
            }  
        });  
  
        //断言：当调用mockList.add(1)方法的时候会返回false  
        Assertions.assertEquals(false,mockList.add(1));  
        //断言：当调用mockList.add(11)方法的时候会返回true  
        Assertions.assertEquals(true,mockList.add(11));  
    }  
}
```

## 使用断言判断

**==作用：断言(assertion)是一种在程序中的一阶逻辑(如：一个结果为真或假的逻辑判断式)，目的为了表示与验证软件开发者预期的结果——当程序执行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止执行，并给出错误信息。==**

示例：`com.demo.unit.mokito.MockitoTest6`

断言
- 方案1、`org.junit.jupiter.api.Assertions` 
  - Assertions 一般以静态化方式引入: `import static org.junit.jupiter.api.Assertions.*;`
- 方案2、`org.hamcrest.MatcherAssert` 

## Mockito @Spy

**==作用：`@Spy`注解或者spy函数修饰的对象，其上的方法都是真实调用的。 而Mock的对象都是假调用==**

示例：`com.demo.unit.mokito.MockitoTest7`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.Spy;  
import org.mockito.junit.jupiter.MockitoExtension;  
import java.util.ArrayList;  
import java.util.LinkedList;  
import java.util.List;  
import static org.junit.jupiter.api.Assertions.*;  
import static org.mockito.Mockito.spy;  
import static org.mockito.Mockito.when;  
  
/**  
 * Mockito 入门-demo7-spy  
 */@ExtendWith(MockitoExtension.class)  
public class MockitoTest7 {  
  
    @Spy  
    private List<Integer> spyList1;  
    @Spy  
    private List<Integer> spyList2 = new ArrayList<Integer>();  
  
    @Test  
    public void testSpy1(){  
        //虽然使用了@spy，但是没有实例化，是无法真实调用方法的  
        spyList1.add(10);  
        System.out.println("spyList1.get(0) = " + spyList1.get(0));  
        //使用了@spy并且初始化了对象，则调用对象的真实方法  
        spyList2.add(10);  
        System.out.println("spyList2.get(0) = " + spyList2.get(0));  
  
        //使用spy()函数进行包装,调用对象的真实方法  
        List<Integer> list = new LinkedList<Integer>();  
        List<Integer> spyList3 = spy(list);  
        spyList3.add(10);  
        System.out.println("spyList3.get(0) = " + spyList3.get(0));  
    }  
  
    @Test  
    public void testSpy2(){  
        //此处的add方法也会被真实调用  
        when(spyList2.add(10)).thenReturn(false);  
        System.out.println("spyList2.get(0) = " + spyList2.get(0));  
  
        //校验通过，但是此处的spyList2.add(10)不会再被真实调用了  
        assertFalse(spyList2.add(10));  
        System.out.println("spyList2.size() = " + spyList2.size());  
    }  
}
```

## Unnecessary stubbings detected 检测到不必要的存根

示例：`com.demo.unit.mokito.MockitoTest8`
异常：有时候会遇到`Unnecessary stubbings detected.`报错是怎么回事？
```java
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected.
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code): 
1. -> at com.demo.unit.mokito.MockitoTest8.testSpy(MockitoTest8.java:29)
Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.
```

**==方案：在`@Mock`注解上使用宽松模式：`@Mock(lenient = true)`==**

## Mockito 框架的工作原理  & 实现一个微型Mockito

实现：`com.demo.unit.simple`
测试：`com.demo.unit.simple.SimpleMockitoTest`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.Mock;  
import org.mockito.junit.jupiter.MockitoExtension;  
import java.util.List;  
import static org.junit.jupiter.api.Assertions.assertEquals;  
import static org.mockito.Mockito.when;  
  
/**  
 * Mockito 入门-demo8-exception  
 */@ExtendWith(MockitoExtension.class)  
public class MockitoTest8 {  
  
    @Mock(lenient=true)  
    private List<Integer> mockList;  
  
    @Test  
    @DisplayName("检测到非必要存根")  
    public void testUnnecessary(){  
        when(mockList.add(10)).thenReturn(false);  
        when(mockList.add(11)).thenReturn(true);  
  
        assertEquals(false,mockList.add(10));  
  
        //由于mockList.add(11)这个打桩没有被使用过，因此会报错Unnecessary stubbings detected. 检测到非必要的存根信息  
        //打开以下注释，就不会报Unnecessary stubbings detected.错误了  
        //assertEquals(true,mockList.add(11));  
    }  
}
```

## 单元测试插件（提效）

搜索并安装插件：`Squaretest`，可一键快速生成Mokito测试用例
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071133908.png)

## JSONassert

JSONassert断言
参考：`com.demo.unit.jsonassert.JSONAssertDemo` 
官方：
- [http://jsonassert.skyscreamer.org/](http://jsonassert.skyscreamer.org/)
- [http://jsonassert.skyscreamer.org/quickstart.html](http://jsonassert.skyscreamer.org/quickstart.html)
- [http://jsonassert.skyscreamer.org/cookbook.html](http://jsonassert.skyscreamer.org/cookbook.html)

# 单测覆盖率

## Jacoco

**==代码覆盖（Code coverage）是软件测试中的一种度量，描述程序中源代码被测试的比例和程度，所得** 
**比例称为代码覆盖率。==**

单元测试覆盖率常用的框架有JaCoCo、EMMA和Cobertura
- Jacoco工具：[https://www.eclemma.org/jacoco/](https://www.eclemma.org/jacoco/)
- Emma工具：[http://emma.sourceforge.net/](http://emma.sourceforge.net/)
- Cobertra工具：[http://cobertura.github.io/cobertura/](http://cobertura.github.io/cobertura/)

### 引入依赖

```xml
<build>  
    <plugins>  
        <!-- 生成JaCoCo覆盖率数据插件 -->  
        <plugin>  
            <groupId>org.jacoco</groupId>  
            <artifactId>jacoco-maven-plugin</artifactId>  
            <version>0.8.8</version>  
            <executions>  
                <execution>  
                    <goals>  
                        <goal>prepare-agent</goal>  
                    </goals>  
                </execution>  
                <execution>  
                    <id>report</id>  
                    <phase>test</phase>  
                    <goals>  
                        <goal>report</goal>  
                    </goals>  
                </execution>  
            </executions>  
        </plugin>  
    </plugins>  
</build>
```

### 运行单测生成报告

本地通过命令行执行命令，运行单元测试：`mvn clean test -Dmaven.test.failure.ignore=true`

### jacoco报告及说明

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071147235.png)
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071148947.png)
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071149766.png)

Jacoco 覆盖率报告说明
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071150605.png)

### 统计指标

1. 指令（C0 Coverage）：JaCoCo计数的最小单元是单一的Java字节码指令。指令覆盖率提供了关于字节码执行数量、未执行数量的信息。
2. 分支（C1 Coverage）：对所有的if和switch语句计算分支覆盖率。统计在方法中分支执行数量、未执行数量的信息。但要注意，异常处理不在此计算范围内。
3. 圈复杂度（Cyclomatic Complexity）：对非抽象方法计算圈复杂度，并汇总类、包和组的（圈）复杂度。这个值可以做为单元测试用例是否完全覆盖的参考。
4. 行（Lines）：一行可能包含一条或多条指令，如果至少有一条指令被执行了，那么该行就算作是被执行了。
5. 方法（Methods）：每个非抽象方法至少包含一条指令。如果至少有一条指令被执行了，那么该方法就算作是被执行了。
6. 类（Classes）：如果类中至少有一个方法被执行了，那么该类就算作是被执行了。

## IDEA单测覆盖率

IDEA已经集成了覆盖率插件
- 执行单元测试的时候
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071143042.png)
- 执行完毕查看覆盖率
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510071144236.png)

在这里看看: [https://youtrack.jetbrains.com/issue/IDEABKL-5941](https://youtrack.jetbrains.com/issue/IDEABKL-5941)
您可以将`-Djava.io.tmpdir`参数添加到idea的启动脚本中，或替换TMP系统属性；也许您还必须在安装目录中的`idea.properties`中更改`idea.config.path`和`idea.system.path`。














