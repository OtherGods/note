提高系统稳定性、健壮性、为企业切实降低开发成本

# 单测理论

## 什么是单元测试

单元测试(unittesting)，是指**对软件中的最小可测试单元进行检查和验证**。

对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，**Java里单元指一个类/函数**，图形化的软件中可以指一个窗口或一个菜单等。

总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。

## 测试金字塔

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061628490.png)

1. **单元测试**: 又称 **==模块测试==**（也有称为方法测试），是针对软件设计的最小单位——程序模块进行正确性检验的测试工作。其 **==目的在于检查每个程序单元能否正确实现详细设计说明中的模块功能、性能、接口和设计约束等要求，发现各模块内部可能存在的各种错误==**。单元测试需要从程序的内部结构出发设计测试用例。多个模块可以平行地独立进行单元测试；
   **==单元测试是整个测试金字塔的基石，单元测试的质量高低对整个系统的健壮性影响很大==**
2. **集成测试**: 也叫做 **==组装测试==**（也有称为模块测试）。通常在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统
3. **确认测试**: 也叫有效性测试。是在模拟的环境下，验证软件的所有功能和性能及其他特性是否与用户的预期要求一致。通过了确认测试之后的软件，才具备了进入系统测试阶段的资质
4. **系统测试**: 是在真实的系统运行的环境下，检查完整的程序系统能否和系统（包括硬件、外设、网络和系统软件、支持平台等）正确配置、连接，并最终满足用户的所有需求
5. **验收测试**: **==UAT,用户验收测试**==，是软件正式上线前的最后一道测试关卡。它的核心目的是**让真实的最终用户（或业务代表）来验证软件是否满足业务需求，以及是否“可用、好用”**。按照项目任务书或合同、供需双方约定的验收依据文档进行的对整个系统的测试与评审，决定是否接收或拒收系统。

## 缺陷与成本

1. 缺陷暴露越晚成本越高：无论缺陷的严重程度如何，越晚发现则伤害越大，缺陷的成本与发现他们所花费的时间成正比。
2. 消除缺陷和返工占用大量成本：软件开发的很大一部分成本包括错误消除和项目返工。返工过程的成本高于初始过程，因此有必要在设计和需求阶段及早发现缺陷以避免这种额外费用。大量的缺陷通常发生在项目的初始阶段，早期的缺陷检测将降低项目的总体成本。
3. 越晚解决缺陷成本越高：即使是微小的缺陷，在后期进行根本原因分析和回归测试时，也会花费巨大的成本；后期发现的缺陷一般不是犹豫缺少代码或者录入错误造成的，而是更加的隐蔽。
4. 缺陷都是在早期引入的：大量的缺陷都是在需求阶段、设计阶段引入的，而在编码期如果有充分的单元测试，就很容易发现这些问题。

## 质量差的原因和解决方案

1. **关注流程错误而不是代码错误**；代码错误并不是引发缺陷的根本原因，代码错误只是一个表象，而是流程错误导致的，流程更需要改进。
   - 是否任何测试用例都被阻塞到最后一分钟才得以解决
   - 是否单元测试覆盖率很低
   - 是否在即将要进行验收测试时还在进行代码的修改
   - 是否经常发生紧急错误
2. **改善流程和机制**；很多公司都遵循严格的时间表和敏捷开发流程，缺陷数量直线飙升，需要强有力的措施，很多预防机制。
   - 提高代码评审覆盖率，加强代码审查、code review
   - 提高单元测试覆盖率，要覆盖到所有的核心代码行
   - 构建单元测试自动化，对于不断迭代的系统，能够保障新修改的代码不影响原有功能
   - 足够多的测试用例，测试用例要具有足够的覆盖度

# 单测规范与原则

## 工程目录规范

1. `src/main/java`：应用程序Java Source目
2. `src/main/resource`：应用程序资源文件目录
3. `src/test/java`：应用程序单元测试Java Source目录
4. `src/test/resource`：应用程序单元测试资源文件目录(为自动化测试准备)

## 测试用例规范

1. 包名一致性: `src/test/java`下的包名 和 对应的src/main/java下的包名保持一致
2. 类名命名规范: `类名+Test`
   - 例1：`UserServiceTest`
   - 例2：`OrderControllerTest`
3. 测试方法命名规范：要求易读、易于理解，`test方法名_测试条件`
   - 例3：`testAddUserById_less_10`         测试addUserById方法，当id小于10的时候
   - 例4：`testAddUserById_not_less_10`  测试addUserById方法，当id不小于10的时候

## AIR原则

单元测试在线上运行时，应该像空气（AIR)一样感觉不到存在。

1. **A：Automatic，自动化**
   - 单元测试应该是全自动执行的，而非交互式的；可以在项目构建过程中执行，定期执行。
   - 单元测试的结果不需要人工检查，而是用assert断言来验证。
2. **I：Independent，独立性**
   - 保持单元测试的独立性，是为了保证单元测试的稳定性与可靠性，单元测试用例之间决不能相互调用，也不能依赖于彼此的先后执行顺序。
3. **R：Repeatable，可重复性**
   - 单元测试可重复执行的，不能受外界环境的限制。
   - 为了不受外界环境的影响，要求设计代码时就把sut的依赖改成注入，在测试时用spring这样的DI框架注入到一个本地实现或者Mock实现。

## BCDE原则

BCDE原则：编写单元测试代码要遵循BCDE原则，保证模块的交付质量

1. B: Border，**边界值测试**，包括循环边界、特殊取值、特殊时间点，数据顺序。
2. C: Correct，**正确的输入**，并得到预期的结果。
3. D: Design，**与设计文档相结合**，来编写单元测试。
4. E: Error，**单元测试的目的是证明程序有错**，而不是证明程序无错。为了发现代码中潜在的错误， 我们需要在编写测试用例时有一些强制的错误输入（如非法数据、异常流程、非业务允许输入等）来得到预期的错误结果

## 其他原则

- **粒度小**：对于单元测试，要保证测试粒度满足单一和小，能够精准定位问题，单测粒度要控制在方法级别。
- **核心通过率高**：核心业务、应用、模块、方法的单元测试要确保通过率为100%。
- **执行速度快**：单个测试用例执行时间不能超过10秒，整个项目的单测时间控制在20分钟以内。
- **覆盖率高**：整体语句、核心模块的语句覆盖率、分支覆盖率都要达到100%。
- **避免数据污染**：如果需要执行数据库相关测试，要设定回滚或打标机制。

# 单元测试实战

## 单测工具

1. Junit：[https://junit.org/junit5/](https://junit.org/junit5/)
2. Spring Test：[https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/testing.html](https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/testing.html)
3. AssertJ：断言库，[https://joel-costigliola.github.io/assertj/](https://joel-costigliola.github.io/assertj/)
4. Hamcrest：断言库/谓词库，[http://hamcrest.org/JavaHamcrest/index](http://hamcrest.org/JavaHamcrest/index)
5. Mockito：Mock框架，[https://site.mockito.org/](https://site.mockito.org/)
6. JSONassert：json断言库，[https://github.com/skyscreamer/JSONassert](https://github.com/skyscreamer/JSONassert)
7. JsonPath：json版本的XPath，[https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath)
8. TestableMock: Mock框架, [https://alibaba.github.io/testable-mock/#/](https://alibaba.github.io/testable-mock/#/)
## Maven 引入  Mokito框架依赖

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061800760.png)

## Spring 集成  Mokito框架

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061800340.png)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061801915.png)

## 什么是Mock

模拟被测试对象的依赖（包括数据和行为）
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202510061802269.png)

## Mokito mock对象

创建mock对象的三种方式：
1. 使用`Mockito.mock(xxx.class)`静态方法来mock对象；示例：`com.demo.unit.mokito.MockitoTest1`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.Test;  
import org.mockito.Mockito;  
import java.util.List;  
  
/**  
 * Mockito 入门-demo1  
 */
public class MockitoTest1 {  
    public void testMock(){  
        //mock一个List对象  
        List mock = Mockito.mock(List.class);  
        //是否能够成功添加数据?  
        mock.add(1);  
  
        //输出mock对象的真实类  
        System.out.println("mock.getClass().getName() = " + mock.getClass().getName());  
        //从mock对象中取出mock.add(1);添加的数据  
        System.out.println("mock.get(0) = " + mock.get(0));  
    }  
}
```

运行结果解析：
```java
//mock出来的对象，并不是真实的List对象本身  
mock.getClass().getName() = org.mockito.codegen.List$MockitoMock$gDRImbIO  
//由于mock出来的对象并不是真实的List对象本身，因此调用add(1)方法添加的数据，其实无法真实添加成功，因此这里返回的是null  
mock.get(0) = null
```

2. 使用`@Mock`注解方式来mock对象，使用`@ExtendWith(MockitoExtension.class)`注解来开启Mock注解；`com.demo.unit.mokito.MockitoTest2`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.Mock;  
import org.mockito.junit.jupiter.MockitoExtension;  
import java.util.List;  
  
/**  
 * Mockito 入门-demo2  
 * 第二种方式就是使用 @Mock 注解方式来创建 Mock 对象，使用该方式创需要注意的是要在运行测试方法前使用 MockitoAnnotations.initMocks(this) ；  
 * 或者单元测试类上加上 @ExtendWith(MockitoExtension.class) 注解。
 */  
@ExtendWith(MockitoExtension.class)  
public class MockitoTest2 {  
  
    //mock对象  
    @Mock  
    private List<String> mockList;  
  
    @Test  
    public void testMock(){  
        //是否能够成功添加数据?  
        mockList.add("demo");  
  
        //输出mock对象的真实类  
        System.out.println("mockList.getClass().getName() = " + mockList.getClass().getName());  
        //从mock对象中取出mock.add(1);添加的数据  
        System.out.println("mockList.get(0) = " + mockList.get(0));  
    }  
}
```

运行结果解析：
```java
//mock出来的对象，并不是真实的List对象本身
mockList.getClass().getName() = org.mockito.codegen.List$MockitoMock$5M7KLhN8
//由于mock出来的对象并不是真实的List对象本身，因此调用add("demo")方法添加的数据，其实无法真实添加成功，因此这里返回的是null
mockList.get(0) = null
```

3. 使用`MockitoAnnotations.initMocks(this);` 和  `MockitoAnnotations.openMocks(this);` 方法来开启Mock注解。其中`initMocks`方法已经不推荐使用；示例：`com.demo.unit.mokito.MockitoTest3`
```java
package com.demo.unit.mokito;  
  
import org.junit.jupiter.api.BeforeEach;  
import org.junit.jupiter.api.Test;  
import org.mockito.Mock;  
import org.mockito.MockitoAnnotations;  
import java.util.List;  
  
/**  
 * Mockito 入门-demo3  
 * 使用MockitoAnnotations.initMocks(this); 和 MockitoAnnotations.openMocks(this); 方法来开启Mock注解。其中initMocks方法已经不推荐使用  
 * (PS: @BeforeEach 是 Junit 5 的注解，功能类似于 Junit 4 的 @Before 注解。)：  
 */  
public class MockitoTest3 {  
  
    @Mock  
    private List<String> mockList;  
  
    @BeforeEach  
    public void beforeEach(){  
        //initMocks已经过时,不推荐使用  
        //MockitoAnnotations.initMocks(this);  
        MockitoAnnotations.openMocks(this);  
    }  
  
    @Test  
    public void testMock(){  
        //是否能够成功添加数据?  
        mockList.add("demo");  
  
        //输出mock对象的真实类  
        System.out.println("mockList.getClass().getName() = " + mockList.getClass().getName());  
        //从mock对象中取出mock.add(1);添加的数据  
        System.out.println("mockList.get(0) = " + mockList.get(0));  
    }  
}
```

运行结果解析：
```java
//mock出来的对象，并不是真实的List对象本身
mockList.getClass().getName() = org.mockito.codegen.List$MockitoMock$COZmkpfI
//由于mock出来的对象并不是真实的List对象本身，因此调用add("demo")方法添加的数据，其实无法真实添加成功，因此这里返回的是null
mockList.get(0) = null
```

## Mokito 验证性测试

**==场景：验证方法是否被调用过、验证方法调用指定次数、验证方法调用顺序==**

示例：`com.demo.unit.mokito.MockitoTest4`
1. 核心方法：
   - `org.mockito.Mockito#verify(T, VerificationMode)`
   - `org.mockito.InOrder#verify(T)`
2. 参数说明：
   - T 代表被mock的对象
   - `org.mockito.verification.VerificationMode`代表验证模式（调用次数）
   - `VerificationModeFactory`工厂类提供了很多返回验证模式的方法，并且在Mockito类中进行了封装。








