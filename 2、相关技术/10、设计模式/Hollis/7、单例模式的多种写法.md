# 典型回答

**==想要实现一个单例，首先就是要考虑把构造函数设置成`private`的==**，否则的话就可以随时通过构造函数创建对象了，就不是单例了。

那把构造函数private之后，就还需要提供一个方法，可以初始化单例对象，并且要保证只能初始化一个单例对象。并且需要考虑线程安全的问题。

具体到写法上，主要有5种。分别是：懒汉、饿汉、静态内部类、双重校验锁以及枚举。

# 扩展知识

## 懒汉 

所谓**懒汉**，就是在 **==需要的时候才会去创建对象==**。
```java
public class Singleton {
	private Singleton (){}
    private static Singleton instance;
    public static synchronized Singleton getInstance() {
	    if (instance == null) {
	        instance = new Singleton();
	    }
	    return instance;
    }
}
```

好处就是避免提前创建浪费资源，但是缺点也明显，就是第一创建的时候浪费时间。

## 饿汉

所谓**饿汉**，就是在 **==类刚一初始化的时候就立即把单例对象创建出来==**。
```java
public class Singleton {
	private Singleton (){}
    private static Singleton instance = new Singleton();
    public static Singleton getInstance() {
	    return instance;
    }
}
```

```java
public class Singleton {  
	private Singleton (){}  
    private Singleton instance = null;  
    static {  
        instance = new Singleton();  
    }  
    public static Singleton getInstance() {  
        return this.instance;  
    }  
}
```

以上两种都是饿汉模式的具体实现。

## 静态内部类

懒加载方式，**Java中==类的加载是延迟加载的==，JVM启动时会自动加载一些基础类，比如：`java.lang.Object`、`java.lang.Class`等**
类加载时机：[23、Java中的类什么时候会被加载？](2、相关技术/3、JVM/Hollis/23、Java中的类什么时候会被加载？.md)
可以通过JVM参数查看那些类在JVM启动时被加载：`-verbose:class`
```java
public class Singleton {  
	private Singleton (){}  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();  
    }  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
}
```

## 枚举

[为什么说枚举是实现单例最好的方式？](2、相关技术/1、Java基础/Hollis/为什么说枚举是实现单例最好的方式？.md)

## 双重校验锁

```java
public class Singleton {  
	private Singleton (){}  
    private volatile static Singleton singleton;  
    public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
}
```

[23、有了synchronized为什么还需要volatile？](2、相关技术/2、JUC/Hollis/Java并发/23、有了synchronized为什么还需要volatile？.md)

# 扩展知识

## CAS实现单例

[补2_不使用synchronized和lock如何实现一个线程安全的单例？](2、相关技术/2、JUC/补2_不使用synchronized和lock如何实现一个线程安全的单例？.md)

## 如何破坏单例

[如何破坏单例模式？](2、相关技术/1、Java基础/Hollis/如何破坏单例模式？.md)
