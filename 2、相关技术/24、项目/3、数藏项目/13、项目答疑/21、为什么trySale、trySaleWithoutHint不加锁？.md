以下是我们的trySaleWithoutHint方法，有人问这个方法为啥不加锁？ 不需要防止并发吗？同理，trySale方法也一样，为啥呢？
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161825115.png)

是这样的，加锁的目的是为了防止并发，这里的并发由两种情况，一种是同一个请求的并发（消息重投），还有一种是不同的请求的并发。

对于第二种情况，不同请求的并发，在下单，尤其是秒杀场景，是非常正常的情况，我们要做的只要防超卖就行了，不需要做额外的加锁的控制，额外的加锁反而会降低秒杀的并发度。 具体可以参考文档和视频中关于这部分的介绍：
[18、为什么不用分布式锁实现秒杀？](2、相关技术/24、项目/3、数藏项目/13、项目答疑/18、为什么不用分布式锁实现秒杀？.md)

那么，对于第一种情况，同一个请求的并发，那就是避免重复下单。

这种有很多方案，比如一锁二判三更新，还有就是乐观锁、或者是依靠数据库的唯一性约束的方案。

为啥不用乐观锁，在下文中讲了：
[22、为什么库存扣减不需要加锁？尤其是乐观锁？](2、相关技术/24、项目/3、数藏项目/13、项目答疑/22、为什么库存扣减不需要加锁？尤其是乐观锁？.md)

剩下的就是悲观锁和数据库唯一性约束来解决了。具体用哪种更好呢，其实主要看出现并发的概率，这个场景中，我认为并发冲突其实并不算高（消息重投的概率并不是特别大），而且是在MQ投递的异步链路上，直接依靠数据库的唯一性约束的冲突，在这个场景中就是流水表中做唯一索引就行了。
