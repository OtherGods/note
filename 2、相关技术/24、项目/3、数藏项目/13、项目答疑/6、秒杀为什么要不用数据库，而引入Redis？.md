因为秒杀的时候，会有大量的用户对同一个商品做下单，那么大家在同时对这个商品的库存进行扣减的时候，这个商品在数据库中就是个热点行了。那么针对热点行的更新就是热点更新。

如：
```sql
UPDATE collection  
SET saleable_inventory = saleable_inventory - #{quantity}, lock_version = lock_version + 1,gmt_modified = now()  
WHERE id = #{id} and <![CDATA[saleable_inventory >= #{quantity}]]>
```

热点数据的更新是我们需要避免的，因为他存在以下问题：

**1、锁竞争**，热点数据的更新是通过update语句进行的，而update是需要给记录增加排他锁的（**即使`update`语句的`where`条件不满足也会锁数据行**），这就会导致大量的请求被阻塞。降低整个系统的吞吐量。

**2、占用数据库连接**，当有大量的update语句，因为要修改同一条记录而被阻塞的时候，他们持有的数据库连接是不会释放的，而数据库连接又是有限的，所以会导致连接数不够，进而影响整个系统的吞吐量及可用性。

**3、耗尽数据库CPU**，大量锁等待，就会导致大量的自旋，多个线程就会不断的尝试获取锁，CPU就需要不断的执行自旋操作，消耗大量CPU时间。并且在这个过程中，操作系统也需要频繁的进行线程上下文的切换，这个过程会导致CPU时间片的浪费。

**4、死锁风险**，在高并发的情况下。由于数据库需要频繁定位和更新这些特定行，可能会增加锁竞争和死锁的风险，影响并发性能。

**5、索引维护开销大**，频繁的更新热点数据，不仅会导致数据的变化，还可能导致相关索引的频繁维护，这可能会增加数据库的开销，导致性能下降。

**6、主从不一致**，热点数据的频繁更新，如果在主从复制出现延迟的情况下，就会放大数据不一致的概率。

所以，我们应该尽量避免大量的并发更新请求被打到数据库上面，那么，又要防止并发，又要高性能，又要防止超卖，有啥好办法呢？

答案就是在 Redis 进行扣减，借助 Redis 的单线程、高性能等特性，来保证在不超卖的情况可以进行高性能的库存扣减。

具体的Redis的扣减采用Lua脚本，保证扣减过程的原子性。
[2、基于Lua+Redis实现库存的秒杀扣减](2、相关技术/24、项目/3、数藏项目/8、最佳实践/2、秒杀（热点扣减）/2、基于Lua+Redis实现库存的秒杀扣减.md)

Redis过滤后的流量在通过MySQL来抗，抗的方式其实就是排队执行。至于这个排队有两种方案，一种是自己通过MQ排队，一种就是像阿里云上的Inventory Hint机制一样在引擎层排队。

