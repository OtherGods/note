因为我们的项目中，秒杀分别在 Redis和数据库中做的扣减，那么防超卖其实在 Redis 中和数据库中都做了。

其实防超卖，只要不要库存扣减为负数即可。那么分别怎么防呢？

### Redis 防超卖

因为 Redis 是单线程执行的，所以，我们只需要确保每次线程执行的时候，能够有效的检查库存是否足够，避免扣减后库存为负数即可。

最简单的方案就是：
```redis
local key = KEYS[1] -- 商品的键名  
local amount = tonumber(ARGV[1]) -- 扣减的数量  
  
-- 获取商品当前的库存量  
local stock = tonumber(redis.call('get', key))  
          
-- 如果库存足够，则减少库存并返回新的库存量  
if stock >= amount then  
    redis.call('decrby', key, amount)  
    return redis.call('get', key)  
else  
        return "INSUFFICIENT STOCK"  
end
```

也就是在一个 lua 脚本中，先查询当前库存，如果大于等于本次扣减数量，则可以扣减，反之则不可以。

因为lua脚本在执行过程中，可以避免被打断，并且redis执行的过程也是单线程的，所以在脚本中进行判断，再扣减，这个过程是可以避免并发的。所以也就可以实现前面我们说的原子性+有序性了。

并且Redis是一个高性能的分布式缓存，使用Lua脚本扣减库存的方案也非常的高效。

那我们的项目中的 lua 要比上面的复杂一些，一方面是我们增加了很多前置校验，另外是我们在 lua 脚本中同时会记录库存扣减流水。详见：
[2、基于Lua+Redis实现库存的秒杀扣减](2、相关技术/24、项目/3、数藏项目/8、最佳实践/2、秒杀（热点扣减）/2、基于Lua+Redis实现库存的秒杀扣减.md)

### 数据库防超卖

那么，在数据库中库存扣减时，我们可以借助数据库自己执行引擎的顺序执行机制，只要保证库存不要扣减成负数就行了，那么可行的方案是通过SQL语句就能控制，如：

如果你的 SQL 是这样的:
```sql
UPDATE collectionSET saleable_inventory = #{saleableInventory}WHERE id = #{id} 
```

也就是说这个变更后的saleableInventory是你自己算好的，给到 SQL 去执行的，那么就必须要加锁来避免并发的时候计算出错，但是我们通过在 SQL 中扣减不会有任何并发导致出错的问题。

而如果这里不加乐观锁，只通过库存扣减，以及库存不能小于0来做控制，那么只需要他们各自抢锁然后按顺序扣减就行了，反正每次库存都是在前面的结果上依次扣减的：
```sql
SET saleable_inventory = saleable_inventory - #{quantity}
```

所以，这里我们只需要保证不会超卖就行了，剩下的并发问题 update 过程中的锁会帮我们解决的。


