兄弟们，在我们的项目中，支付回调的方法，全程我们是没加分布式锁的，如：
```java
@GlobalTransactional(rollbackFor = Exception.class)  
public boolean paySuccess(PaySuccessEvent paySuccessEvent) {  
      
    PayOrder payOrder = payOrderService.queryByOrderId(paySuccessEvent.getPayOrderId());  
    if (payOrder.isPaid()) {  
        return true;  
    }  
}
```

这里并没有用我们的@DistributeLock 注解，没有加任何的分布式锁，为啥呢？

其实没必要。

因为支付回调这里，最大的可能出现并发的地方就是针对库存做真正的扣减：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161810979.png)

但是，这里我认为不太有必要加这个分布式锁，如果加分布式锁的话，就需要针对藏品 id 进行加锁，那么就会导致如果有多个用户同时支付成功后，很多人因为抢不到锁而失败。

那如果不加锁，我们其实也是可以防止并发导致库存出现异常的，就是因为我们在库存修改的时候，是直接在数据库中通过 SQL 做的原子性库存操作：
```sql
UPDATE /*+ COMMIT_ON_SUCCESS ROLLBACK_ON_FAIL TARGET_AFFECT_ROW 1 */ collection  
SET occupied_inventory = occupied_inventory + #{quantity}, lock_version = lock_version + 1,gmt_modified = now()  
WHERE id = #{id} and <![CDATA[occupied_inventory + #{quantity} <= quantity ]]>
```

重点的是这一句：SET occupied_inventory = occupied_inventory + #{quantity}

那么对个线程并发执行的时候，数据库层面 update 本身会有一个互斥锁，那么就能保证所有现场执行完之后，库存不会出现异常错乱的情况。

那我们通过这种方式解决了问题，所以就没必要加分布式锁了。

本身分布式锁是一种悲观锁的思想，我认为这个支付成功后的回调处理，并不算典型的高并发场景，所以不用加这个分布式锁。
