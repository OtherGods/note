[4、引入TCC实现普通交易环节订单和库存的一致性](2、相关技术/24、项目/3、数藏项目/8、最佳实践/6、数据一致性（分布式事务）/4、引入TCC实现普通交易环节订单和库存的一致性.md)

几个原因：

首先，Seata的TCC，在Confirm之后，就协调Cancel了，我不认为这是一种好的做法（虽然TCC的规范就是这么要求的），我认为好的方案应该是尽可能的Confirm，实在Confirm不掉了，再考虑Cancel。

这有啥区别？区别在于，下单环节，我们应该尽可能让用户下单成功，而不是让用户下单失败。还有就是，Try已经成功了，Confirm成功的概率是非常大的，因为Try的时候已经预留了资源，所以我们应该尽可能得尝试Confirm。

第二个，在Seata的旧版本中，是没有解决空回滚和悬挂的问题的，虽然新版本解决了，但是我还是想给大家讲一下如何自己解决这两个问题。

第三个，就是我想给大家讲一下TCC到底应该咋用，如何设计一个好的TCC的方案，避免用Seata这么重的方案。

但是，需要大家注意一下，如果你拿这个项目出去面试，简历上或者介绍项目的时候，不建议说自己同时用了 Seata 的 AT，以及自己手写了一个 TCC 的方案，建议要么就都用 Seata 的 ，要么就都是手写。避免被误认为造轮子。因为我们是个教学类的项目，所以尽可能给大家多讲一点东西

