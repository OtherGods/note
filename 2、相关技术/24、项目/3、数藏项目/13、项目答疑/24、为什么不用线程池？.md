项目中，我们定义过一个ThreadPoolUtils，最开始是想在短信发送这里用的：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503190006255.png)

但是后来没用上，改成了直接用虚拟线程来做，因为虚拟线程更加快，更加轻量级。

在我的八股文中提到过。虚拟线程不要和线程池一起使用。主要是因为

**像所有资源池一样，线程池旨在共享昂贵的资源，但虚拟线程并不昂贵，因此永远不需要将它们池化。**

**虚拟线程被设计为可以轻松地创建和销毁的轻量级实体**，旨在允许每个任务都在其自己的虚拟线程中运行。这与传统的平台线程不同，后者创建和销毁的成本较高，因此经常被放入线程池中重用以提高效率。

虚拟线程的设计使得它们在遇到阻塞操作（如I/O操作）时可以被挂起，释放底层操作系统线程给其他任务使用。这种模型在高并发场景下能有效利用系统资源，减少了因阻塞操作而浪费的CPU周期。如果虚拟线程被放入池中重用，这种灵活的资源调度优势就会被削弱。

还有就是，虚拟线程的引入有个目的是为了简化并发编程模型，让开发者可以像编写顺序代码一样编写并发代码，而无需担心线程管理和线程池的复杂性。要求虚拟线程不被池化，是为了鼓励开发者利用这一简化的模型，避免回到传统的线程池管理模式。

总之，**我们可以随意利用虚拟线程的轻量级特性和系统资源的高效利用，简化并发编程模型，而无需依赖传统的线程池技术。**

### 也用了线程池

但是，其实我们项目中还是用了线程池的，比如orderListenExecutor是我们定义的一个线程池，用来处理订单的事件监听的。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503192225212.png)

这里是因为Spring 的事件机制他主要支持线程池的方式，详见：
[1、基于SpringEvent+XXL-JOB实现订单确认自动推进](2、相关技术/24、项目/3、数藏项目/8、最佳实践/4、订单管理/1、基于SpringEvent+XXL-JOB实现订单确认自动推进.md)

