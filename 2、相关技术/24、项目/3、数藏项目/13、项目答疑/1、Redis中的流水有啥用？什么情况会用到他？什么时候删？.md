[2、基于Lua+Redis实现库存的秒杀扣减](2、相关技术/24、项目/3、数藏项目/8、最佳实践/2、秒杀（热点扣减）/2、基于Lua+Redis实现库存的秒杀扣减.md)

库存扣减的 lua 脚本中，我们不仅做了库存的扣减，还用 hash 结构存储了一条流水，流水结构如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508241649112.png)

- `clc:inventory:stream:10010`：以 `固定前缀 + 库存id` 为键值对的键
- `DECREASE_1019593009082742333440003`：以 `扣减/增加 + 订单id` 为值中的key
- Json字符串：值中的value
  ```json
{  
    "change": "1",  // 库存变化数量
    "action": "decrease",  //流水类型
    "from": "19",  // 扣减前库存数
    "timestamp": 1755968714762,  // 当前时间
    "by": "DECREASE_1019593009082742333440003",  // key
    "to": 18  // 扣减后库存数
}
    ```
这里的 key 是用**流水类型、订单单号**拼接到一起的。
value 中明确的记录了本次扣减的变化的库存数、变化前的库存数以及变化后的库存数，还有变化的操作ID 以及变化的时间戳。

有这样的一条流水有2个作用：
1. **幂等**
   当我们在lua脚本执行时，会先去查询下是否存在对应的流水，如果查询到了，则说明本次是一个重复请求，直接幂等掉。
   对应代码：`redis.call('hexists', clc:inventory:stream:10010, DECREASE_1019593009082742333440003) == 1`
2. **对账**
   Redis的库存扣减之后，数据库还是要扣减的，那么如何保证双方都一定成功呢，如何发现不一致的情况呢，那就需要这个流水了。每一次扣减都有一条流水记录，这样就可以用Redis中的流水和数据库中的流水做核对，如果一致的话则没问题，但是不一致的话，可能是丢消息了，或者系统执行异常了。这时候就需要人工介入来解决这个问题了。

库存流水也不是一直都存在的，以下几种情况会删除，一种是主动删除，一种是惰性删除。
1. **主动删除**：
	当某条流水已经完成对账之后，则删除。
2. **惰性删除**
	当商品下架后，流水设置24小时后到期，到期后基于Redis的删除策略做删除