在我们的基于MQ的秒杀方案中，newBuy这个方法进去可以看到：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161745307.png)

先做了一次下单的前置校验，这里用到的是一个orderPreValidatorChain，这个玩意是在OrderPreValidatorConfig中定义的：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161745414.png)

这里组装了4个节点，用户校验器、商品校验器、库存校验器以及预定校验器。这里校验通过之后就可以扣减库存，下单了。

但是，在下单链路中，会调到createAndConfirm方法，这里面又做了一次校验：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161746915.png)

这里用到的是orderConfirmValidatorChain，和刚刚的orderPreValidatorChain并不是同一个，这个orderValidatorChain是在OrderCreateAndConfirmValidatorConfig中定义的，他的定义如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161746285.png)

这里面只有两个校验器，一个是用户校验器、一个是商品校验器。这里面就有两个问题：

### 为什么要校验2遍

这里为啥要校验2遍呢，主要是因为第二遍那个地方是异步的，异步的话就意味着这里面有时间差，有时间差的话，就有可能校验的状态发生变化了。站在风控的角度，应该在下单前，再做一次校验，确保安全。

### 为什么第二遍比第一遍校验的少

第二遍只校验了用户状态和商品状态，针对库存和预定没有做校验，为啥呢？

因为没必要。

走到这个地方，库存已经在redis做过扣减了，这里一定是够得。

预约我们是不支持取消的，只要前面校验过了，后面也不会变了，没必要再校验一次。

而用户状态和商品状态，是有可能发生变化的，比如用户被拉黑了，商品下架了等等的。

### OrderCreateValidator什么鬼？

这个第三个校验器，他使用在秒杀第一套方案的，那个方案中没有基于MQ，订单的创建是在同步进行的，所以只需要做一次校验即可。

而这里没必要校验库存了，因为库存在前面已经扣减过了，没必要再校验了。