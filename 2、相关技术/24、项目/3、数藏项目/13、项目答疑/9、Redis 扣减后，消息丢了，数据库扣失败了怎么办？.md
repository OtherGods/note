如下图，是我们的库存扣减的一个过程，先在 Redis 中做库存预扣减，然后再从数据库中扣减库存：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503161219416.png)

但是，如果预扣减成功之后，应用挂了，没来得及做数据库中的扣减怎么办？这不是不一致了么？

没错，这就是典型的少卖的问题。我们先来分析一下什么是少卖，以及少卖有啥问题。

### 少卖

什么叫少卖，就是明明你有100份库存，只卖出去99份。剩下一份没办法卖了，这就叫少卖。

为什么这种情况会发生少卖呢？假设 Redis 中有100个库存，一个线程来扣减，在 Redis 中扣减成99了之后，没扣数据库，应用挂了，这时候数据库库存还是100，但是 Redis 已经变成99了。

我们从两个方面看，对于用户来说，这笔订单是没有下单成功的，因为他虽然 Redis 扣减成功了，但是数据库并没成功，订单也没有创建出来，前端是轮询不到这笔订单的，会提示他下单失败，他会以为自己没抢到然后重试。

对于系统来说，就会导致一个库存的浪费，因为下一个用户来 Redis 扣减的时候会从99开始扣，最终就只能创建成功99笔订单了。

这就是发生了少卖的问题了。对于少卖来说，很多电商系统是不解决的，因为这种对于用户来说影响不大，对于商品来说，少卖一个影响也没那么大，少卖的问题比超卖小多了。所以很多电商直接就就不去解决他，少了就少了，下次继续卖就好了。

### CAP

那你说这是不是个问题的，他是的。是一个众所周知的问题，即使我们这里不用 Spring 的 Event，用 MQ 的方案，也会有这个问题。

或者说，只要用了 Redis 来做库存扣减，这个问题就天然存在。那为啥这个方案仍然是一个主流方案呢？

其实，这就是 CAP 的一个知识了，可用性，也就是我们通常认为的性能，在我们的项目中就是秒杀扣将能抗更高的流量这个要求，和一致性，也就是我们的Redis 和数据库的一致性问题，他在分布式系统中就是天然不可能同时满足的。

> CAP 理论：在分布式系统中，可用性、一致性和分区容错性不可能同时满足。

你想要更强的一致性，那势必要牺牲可用性，比如就干脆不用 Redis，只用数据库，一致性问题没了，但是数据库扛不住。

你想要更好的可用性，引入了 Redis 来提升性能，那么就势必会存在 Redis 和数据库的不一致问题。

所以，很多公司选择牺牲一定的一致性，来保障可用性。

但是牺牲一致性，就意味着什么都不做了么？也不是，我们也做可以做很多事情，来让这个不一致的问题可以被发现，这个不一致的时长可以更短。

### 如何减少不一致问题？

在我们的项目中，我们也做了事情。

一方面，在秒杀的第二套基于 MQ的方案中，我们用了事务消息，来保证只要 Redis 扣减成功后，MQ 就能发出去。

还有就是我们引入机制，让这种不一致可以被及时发现，让这种不一致可以被矫正。

那么我们的做法就是在 Redis 中不仅记录了商品的库存值，还会针对每一次的扣减都会记录一条流水，把扣库存和记录流水放到同一个 lua 中，保证原子性，然后我们基于这个流水做核对，比如每隔一分钟，拉一下Redis 中的库存扣减流水和数据库中的库存扣减流水做比对，如果发现Redis 中有，而数据库中没有，则可以考虑是丢消息了，那么就可以做补偿了。
