我们在项目中，有一个 `tokenFilter`，用来针对 `token` 做过滤，判断是否重复创建订单：
[1、基于Token校验避免订单重复提交](2、相关技术/24、项目/3、数藏项目/8、最佳实践/2、秒杀（热点扣减）/1、基于Token校验避免订单重复提交.md)

但是，在订单创建的时候，我们还是用了个分布式锁，来防止重复创建订单，
[5、基于分布式锁解决高并发情况下的订单重复创建](2、相关技术/24、项目/3、数藏项目/8、最佳实践/5、并发处理（分布式锁）/5、基于分布式锁解决高并发情况下的订单重复创建.md)

那为啥要做两次？前面已经有了个 `tokenfiter` 了，后面这个分布式锁还有意义吗？

答案是有的。

因为 `tokenFilter` 是 `trade` 模块做的事情，而加分布式锁是 `order` 模块做的事情。

对于订单模块来说，他自己需要有防重的能力，而不能完全依赖上面的 `trade` 模块，换句话说，有的时候订单创建不一定通过交易模块来的，有可能别的模块来创单，比如一些 `ERP` 场景可能会自动创单。

所以，站在订单模块的角度来看，他自己需要有这个防止重复下单的防控能力，不能完全依靠上游。