在我们的项目中，为了保证一致性，引入了多种分布式事务的方案。

在行业内，用的比较多的分布式事务的方案就是可靠消息最终一致性、TCC、Seata 等方案了。

在我们的项目中，有多种不同的方案，因为要解决的场景不太一样。目前一致性方案都是围绕着订单来的。我们主要用到了**4种一致性方案**，分别是：
- RocketMQ事务消息
- Seata 的 AT 模式
- 定时任务重试
- 数据对账+人工介入

这4种，其实都是最终一致性的方案。在一致性的保障上，即不一致的时长上面，AT是最短的，其次是事务消息，然后的是定时任务的方案、最差的就是对账+人工的方案了。

在我们项目的订单模块中，需要保障一致性的主要有3个场景。
- 订单创建
	- 在订单创建的时候，我们会**先在 Redis 中做库存的预扣减**，然后**再操作数据库中的 Collection 进行库存预扣减、创建订单**。
	- 这里**要保障的是 Redis 的库存和数据库的库存的一致性**，如果不一致，会出现少卖的问题（数据上的体现：Redis中库存量少于MysSQL中库存量）。
- 订单关单
	- 在订单关单时，我们要做的事情也很多，首先是把**订单关闭**、其次是再把**库存回滚回去**。
	- 这里要保障的是**订单系统、库存系统以及 Redis 库存的一致性**，如果不一致，会出现少卖的问题
- 订单支付
	- 在订单支付的时候，我们要做的事情也很多，首先是**把支付单状态推进、订单状态推进、库存做真正的扣减、生成持有藏品、持有的藏品上链**。等等一系列操作。
	- 这里要保证以上这些模块的**一致性**，如果不一致，会导致缺这少那。

### 订单创建的一致性方案

在订单创建的这个环节，我们首要的 **==*目标*是可用性并不是一致性==**。即在 `CAP` 中，我们需要保证下单接口，尤其是秒杀过程中的 `AP` 而不是 `CP`。这个大家都能理解，因为如果**因为不一致，发生了少卖，影响其实没那么大的**，但是如果系统不可用，无法下单，影响更大一些。

所以，在订单创建的这个过程中，我们的一致性保障其实比较弱，这里为了提升性能，只把 `Redis` 的库存扣减放在了同步链路，而把数据库中库存扣减以及订单创建，放到了异步链路上。

这里 **==保证一致性的方案是对账 + 人工介入==**，通过在 Redis 中记录库存扣减流水，然后和订单的流水进行核对，发现不一致的时候，人工介入处理即可。
[2、基于Lua+Redis实现库存的秒杀扣减](2、相关技术/24、项目/3、数藏项目/8、最佳实践/2、秒杀（热点扣减）/2、基于Lua+Redis实现库存的秒杀扣减.md)

### 订单关单的一致性方案

订单关单的这个场景，相比于下单来说，性能要求就没有那么高了，所以可以抽出更多的精力做一致性的保障。减少对账及人工介入的成本。但是这个环节的一致性要求其实也没特别高高，并且只有订单和藏品两个模块交互，那么我们就直接采用了事务消息，这里基于 RocketMQ 的事务消息来实现的。
[3、基于RocketMQ事务消息实现订单取消的一致性](2、相关技术/24、项目/3、数藏项目/8、最佳实践/6、数据一致性（分布式事务）/3、基于RocketMQ事务消息实现订单取消的一致性.md)

### 支付成功的一致性方案

在一致性的重要程度上来说，订单支付成功的一致性要求更高一些，所以我们引入了 Seata，通过 AT 模式来保证更高一点的一致性方案。

之所以选择 AT，虽然他是最终一致性的方案，但是他的一致性要比靠消息这种更加好一些，不一致的时长也更短一些，而且在订单支付的这个节点，本来就是外部支付渠道就有消息在驱动，我们再引入一个消息最终一致性，整个链路就会太多的异步，就会很复杂。而且这个环节参与方也比较多，用 MQ 的话就需要有很多人都要监听同一个消息，处理起来也比较麻烦。代码的侵入性太高了。

而相比 TCC、XA 两种模式，AT 的侵入性是最低的，并且在性能上也有所保障，所以我们选择了 Seata 的 AT 模式来保证这个环节的一致性。
[1、基于Seata分布式事务实现支付环节的数据一致性](2、相关技术/24、项目/3、数藏项目/8、最佳实践/6、数据一致性（分布式事务）/1、基于Seata分布式事务实现支付环节的数据一致性.md)

在支付成功的这个链路中，有一个模块很特殊，那就是区块链模块，我们需要在支付成功后，对本次交易进行上链。

但是因为上链是需要调外部服务的，所以我们没办法把他放到我们的 Seata 的分布式事务中，因为外部服务不可靠，把他放到事务中可能会导致事务经常回滚。那么如果保障他和支付成功过程的一致性呢？

这里其实借助了 Seata 的事务回调以及定时任务来保障的。即我们给 Seata 的全局事务注册一个 Hook，在事务commit 之后，回调这个 hook，然后在这个 hook 中调链服务进行上链。

这个过程如果失败了，不会对原本的事务造成任何影响，那么我们只需要再引入一个定时任务来重试即可。
[2、基于 Seata 的事务钩子+定时任务保障支付成功后上链的一致性](2、相关技术/24、项目/3、数藏项目/8、最佳实践/6、数据一致性（分布式事务）/2、基于%20Seata%20的事务钩子+定时任务保障支付成功后上链的一致性.md)

# 普通交易订单创建

其实，不管是普通交易、还是秒杀交易，订单创建和库存扣减（数据库中）都是要保证一致性的，但是因为秒杀场景中，库存扣减和订单创建在异步链路上，有重试的，所以基于MQ的这种最终一致性保证的。

但是普通交易，没有MQ的，所以我们需要一个别的方案来保障，支付哪里我们用了AT，这里行不行呢？

其实也行，完全可以引入Seata的AT模式来搞定，但是我们为了讲解TCC，以及TCC中的空回滚、悬挂等问题，这里用了TCC（但是面试的时候，不建议大家说两套不同的方案，要么就都是AT，要么就都是TCC）

但是我们的方案中，我们没有使用Seata中的TCC，因为我觉得那个方案不好， 因为我始终认为，TCC在Try成功之后，Confirm大概率都是可以成功的，所以在Confirm之后立刻就去Cancel，虽然提升了一致性，但是也带来很多回滚。所以我自己实现了一个TCC。
[4、引入TCC实现普通交易环节订单和库存的一致性](2、相关技术/24、项目/3、数藏项目/8、最佳实践/6、数据一致性（分布式事务）/4、引入TCC实现普通交易环节订单和库存的一致性.md)



