我们的项目中，有一些敏感信息，比如手机号、身份证号等，需要在日志，以及页面展示的时候进行脱敏。避免数据泄露。

## 步骤

### 1.选择脱敏框架

nfturbo 项目选择的是github上的sensitive框架：[https://github.com/houbb/sensitive](https://github.com/houbb/sensitive)

### 2.maven引入

引入核心脱敏包
```xml
<dependency>  
    <groupId>com.github.houbb</groupId>  
    <artifactId>sensitive-logback</artifactId>  
    <version>1.7.0</version>  
</dependency>
```

引入 logback 依赖包

```xml
<dependency>  
    <groupId>ch.qos.logback</groupId>  
    <artifactId>logback-classic</artifactId>  
    <version>${logback.version}</version>  
</dependency>
```

### 3.logback.xml 配置

下面是logback模版：
```xml
<configuration>  
    <!-- 基于 converter -->    <conversionRule conversionWord="sensitive" converterClass="com.github.houbb.sensitive.logback.converter.SensitiveLogbackConverter" />  
    <!-- 使用 converter -->    <appender name="STDOUTConverter" class="ch.qos.logback.core.ConsoleAppender">  
        <encoder>  
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %sensitive%n</pattern>  
        </encoder>  
    </appender>  
  
    <!-- 使用 layout -->    <appender name="STDOUTLayout" class="ch.qos.logback.core.ConsoleAppender">  
        <layout class="com.github.houbb.sensitive.logback.layout.SensitiveLogbackLayout">  
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>  
        </layout>  
    </appender>  
  
    <!-- 设置根日志级别为DEBUG，并将日志输出到控制台 -->  
    <root level="DEBUG">  
        <appender-ref ref="STDOUTConverter"/>  
        <appender-ref ref="STDOUTLayout"/>  
    </root>  
</configuration>
```

这里共计支持 Converter 和 Layout 两种模式，任选一个即可。

建议使用 SensitiveLogbackConverter，脱敏日志内容。

配置项目里面的logback.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>  
<configuration>  
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>  
  
    <springProperty scope="context" name="app.name" source="spring.application.name"/>  
    <!-- 基于 converter -->    <conversionRule conversionWord="sensitive" converterClass="com.github.houbb.sensitive.logback.converter.SensitiveLogbackConverter" />  
  
    <property name="APP_NAME" value="${app.name}"/>  
    <property name="LOG_PATH" value="${user.home}/${APP_NAME}/logs"/>  
    <property name="LOG_FILE" value="${LOG_PATH}/application.log"/>  
    <property name="FILE_LOG_PATTERN" value="%d %-5level [%thread %logger - %sensitive%n"/>  
  
    <appender name="APPLICATION"  
              class="ch.qos.logback.core.rolling.RollingFileAppender">  
        <file>${LOG_FILE}</file>  
        <encoder>  
            <pattern>${FILE_LOG_PATTERN}</pattern>  
        </encoder>  
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">  
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>  
            <maxHistory>7</maxHistory>  
            <maxFileSize>50MB</maxFileSize>  
            <totalSizeCap>20GB</totalSizeCap>  
        </rollingPolicy>  
    </appender>  
  
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">  
        <encoder>  
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>  
            <charset>utf8</charset>  
        </encoder>  
    </appender>  
  
    <root level="INFO">  
        <appender-ref ref="APPLICATION"/>  
    </root>  
</configuration>
```

其中需要关注的是converter引入
```xml
<conversionRule conversionWord="sensitive" converterClass="com.github.houbb.sensitive.logback.converter.SensitiveLogbackConverter" />
```

还有日志格式配置
```xml
<property name="FILE_LOG_PATTERN" value="%d %-5level [%thread %logger - %sensitive%n"/>
```

### 4.日志效果

脱密效果如下：
```json
2024-05-26 11:55:50,260 INFO  [http-nio-8085-exec-10 cn.hollis.nft.turbo.rpc.facade.FacadeAspect - start to execute , method = auth , args = [{"idCard":"2****************2|EDB6003794DD4ED72CFA72F54CF4280D","realName":"张三","userId":9}]
```

### 5.脱敏前台展示字段

脱敏注解举例
```java
public class Example {  
      
    @SensitiveStrategyChineseName  
    private String username;  
      
    @SensitiveStrategyPassword  
    private String password;  
      
    @SensitiveStrategyPassport  
    private String passport;  
      
    @SensitiveStrategyIdNo  
    private String idNo;  
      
    @SensitiveStrategyCardId  
    private String bandCardId;  
      
    @SensitiveStrategyPhone  
    private String phone;  
      
    @SensitiveStrategyEmail  
    private String email;  
      
    @SensitiveStrategyAddress  
    private String address;  
      
    @SensitiveStrategyBirthday  
    private String birthday;  
      
    @SensitiveStrategyGps  
    private String gps;  
      
    @SensitiveStrategyIp  
    private String ip;  
      
    @SensitiveStrategyMaskAll  
    private String maskAll;  
      
    @SensitiveStrategyMaskHalf  
    private String maskHalf;  
      
    @SensitiveStrategyMaskRange  
    private String maskRange;  
}
```

具体操作
```java
@Getter  
@Setter  
@NoArgsConstructor  
public class UserInfo implements Serializable {  
      
    /**  
     * 手机号  
     */  
    @SensitiveStrategyPhone  
    private String telephone;  
}
```

增加一个拦截器

当运行getUserInfo的时候
```java
@GetMapping("/getUserInfo")  
public Result<UserInfo> getUserInfo() {  
    String userId = (String) StpUtil.getLoginId();  
    UserQueryRequest request = new UserQueryRequest();  
    request.setUserId(Long.valueOf(userId));  
    User user = userService.findById(Long.valueOf(userId));  
      
    if (user == null) {  
        throw new UserException(USER_NOT_EXIST);  
    }  
      
    return Result.success(UserConvertor.INSTANCE.mapToVo(user));  
}
```

然后判断返回对象是UserInfo，通过 SensitiveUtil.desCopy(UserInfo)进行脱敏
### 6、ChatGPT对5代码的解释

这段代码定义了一个名为 `SensitiveResponseBodyAdvice` 的类，该类实现了 Spring MVC 的 `ResponseBodyAdvice<Object>` 接口。这个类的主要作用是作为一个全局的响应体增强器，用于在控制器方法返回响应体之前对响应体进行自定义处理。以下是详细的解释：

#### 1. 类注解和接口实现

- `@ControllerAdvice`：这是一个 Spring MVC 的注解，用于标识一个类，该类包含了一些对控制器（Controller）全局生效的增强器（Advice）。这些增强器可以应用于异常处理、数据绑定、模型增强等方面。
    
- `implements ResponseBodyAdvice<Object>`：通过实现 `ResponseBodyAdvice<Object>` 接口，`SensitiveResponseBodyAdvice` 类能够对所有控制器方法返回的响应体进行拦截和处理。
    

#### 2. 支持的方法

- `supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType)`：这个方法用于判断当前的增强器是否应该应用于某个控制器方法的返回类型。在这个实现中，只有当返回类型是 `Result` 类或其子类时，才会执行后续的 `beforeBodyWrite` 方法。

#### 3. 响应体处理

- `beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class<? extends HttpMessageConverter<?>> selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)`：这个方法在控制器方法返回响应体之前被调用，允许对响应体进行修改。
    - 首先，检查响应体（`body`）是否为 `Result` 类型的实例，并且其数据部分不为空。
    - 如果数据部分是一个集合（`Collection`），则使用 `SensitiveUtil.desCopyCollection` 方法对集合中的每个元素进行脱敏处理。
    - 如果数据部分是 `UserInfo` 或 `InviteRankInfo` 类型的实例，则分别使用 `SensitiveUtil.desCopy` 方法对它们进行脱敏处理。
    - 如果数据部分不是上述类型，则不对其进行处理，直接返回原响应体。

#### 4. 总结

这段代码通过实现 `ResponseBodyAdvice<Object>` 接口，定义了一个全局的响应体增强器，用于在控制器方法返回响应体之前对特定类型（`Result`）的响应体进行脱敏处理。这对于保护敏感信息（如用户个人信息、邀请排名信息等）不被泄露非常有用。

这段代码的核心在于利用 Spring MVC 提供的扩展点，对响应体进行自定义处理，以满足特定的业务需求。

### 7、个性化配置

用户可以在应用 resources 下通过 chars-scan-config.properties 配置文件指定。

默认配置

SensitivePatternLayout 配置默认为：
```java
chars.scan.prefix=:：,，'"‘“=| +()（）  
chars.scan.scanList=1,2,3,4,9  
chars.scan.replaceList=1,2,3,4,9  
chars.scan.defaultReplace=12  
chars.scan.replaceHash=md5  
chars.scan.whiteList=""
```

属性说明

SensitivePatternLayout 策略的属性说明。

| 属性             | 说明          | 说明                    | 备注                                       |
| -------------- | ----------- | --------------------- | ---------------------------------------- |
| prefix         | 需要脱敏信息的匹配前缀 | :：,，'"‘“= +()（） 和英文竖线 | 降低误判率                                    |
| replaceHash    | 哈希策略模式      | md5                   | 支持 md5/none 两种模式                         |
| scanList       | 敏感扫描策略列表    | 1,2,3,4               | 1~10 内置的10种敏感信息扫描策略，多个用逗号隔开              |
| replaceList    | 敏感替换策略列表    | 1,2,3,4               | 1~10 内置的10种敏感信息替换策略，多个用逗号隔开              |
| defaultReplace | 敏感替换默认策略    | 12                    | 1~13 内置的13种敏感信息替换策略，指定一个。当列表没有匹配时，默认使用这个 |
| whiteList      | 白名单         | ``                    | 希望跳过处理的白名单信息                             |

其中 1-13 的内置策略说明如下：

| 策略标识 | 说明                     |
| ---- | ---------------------- |
| 1    | 手机号                    |
| 2    | 身份证                    |
| 3    | 银行卡                    |
| 4    | 邮箱                     |
| 5    | 中国人名                   |
| 6    | 出生日期                   |
| 7    | GPS                    |
| 8    | IPV4                   |
| 9    | 地址                     |
| 10   | 护照                     |
| 11   | 匹配任意不掩盖                |
| 12   | 匹配任意半掩盖                |
| 13   | 匹配任意完全掩盖               |
| m1   | 拓展类合并操作(m3:4&5&9) 性能更好 |
