缓存和数据库的一致性方案，基本上业内可行的就三种：

1、先更新数据库，再删除缓存

2、延迟双删

3、Cache-Aside，即用 binlog 监听实现缓存更新/删除

### 先更新数据库，再删除缓存

对于并发不太高的情况，直接用第一种即可，先更新数据库，然后再删除缓存即可。

比如用户信息我们做了缓存，但是在用户状态发生变更时，我们需要同时更新缓存，所以这里就是典型的一个先更新数据库，然后再删除缓存的方案：
```java
public UserOperatorResponse modify(UserModifyRequest userModifyRequest) {  
    UserOperatorResponse userOperatorResponse = new UserOperatorResponse();  
    User user = userMapper.findById(userModifyRequest.getUserId());  
    Assert.notNull(user, () -> new UserException(USER_NOT_EXIST));  
    Assert.isTrue(user.canModifyInfo(), () -> new UserException(USER_STATUS_CANT_OPERATE));  
      
    if (StringUtils.isNotBlank(userModifyRequest.getNickName()) && nickNameExist(userModifyRequest.getNickName())) {  
        throw new UserException(NICK_NAME_EXIST);  
    }  
    BeanUtils.copyProperties(userModifyRequest, user);  
      
    if (StringUtils.isNotBlank(userModifyRequest.getPassword())) {  
        user.setPasswordHash(DigestUtil.md5Hex(userModifyRequest.getPassword()));  
    }  
    //更新数据库  
    if (updateById(user)) {  
        //加入流水  
        long streamResult = userOperateStreamService.insertStream(user.getId(), UserOperateTypeEnum.MODIFY);  
        Assert.notNull(streamResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));  
        addNickName(userModifyRequest.getNickName());  
        userOperatorResponse.setSuccess(true);  
          
        //删除缓存  
        telUserCache.remove(user.getTelephone());  
        idUserCache.remove(user.getId().toString());  
          
        return userOperatorResponse;  
    }  
    userOperatorResponse.setSuccess(false);  
    userOperatorResponse.setResponseCode(UserErrorCode.USER_OPERATE_FAILED.getCode());  
    userOperatorResponse.setResponseCode(UserErrorCode.USER_OPERATE_FAILED.getMessage());  
      
    return userOperatorResponse;  
}
```

因为用户的信息变化并不是特别的频繁，所以其实并发量也不是很高，及时极端情况下出现缓存删除不及时，导致脏读也是可以接受的，所以我们选的是方案1 ，先更新数据库，再删除缓存。

同时，为了避免这种极端的情况下出现的缓存删除失败导致的不一致的情况，我们也做了一些事情，比如我们在查询处都增加了缓存的自动刷新，到时间之后，缓存也能进行自动更新。
```java
@Cached(name = ":user:cache:id:", expire = 3000, cacheType = CacheType.BOTH, key = "#userId", cacheNullValue = true)  
@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)  
public User findById(Long userId) {  
    return userMapper.findById(userId);  
}
```

### 延迟双删

除了第一种方案，延迟双删这种方案我们用的也多，主要是为了避免一次删除缓存导致的缓存删除失败出现的不一致问题，我们在用户模块中同样做了延迟双删的方案设计。

那就是在我们的用户的冻结、解冻接口中，我们做了延迟双删，因为对于冻结、解冻接口来说，虽然并发量不高，但是对于不一致的接受度比较低，我们希望能快速的更新缓存，避免不一致。所以引入了延迟双删。

为了减少缓存的不一致，我们其实只需要把删除挪到更新数据库之前就行了，这样就能确保更新数据库的时候，缓存一定已经删除了，那么就可以避免脏数据。

但是，这样会带来一个问题，那就是在删除缓存之后，更新数据库之前，另外一个线程如果从数据库中读取了旧值又更新到了缓存中，那么就会导致缓存又变成旧值了。还是会出现不一致的情况了。

所以，解决的方案就是延迟双删，也就是在删除缓存、更新数据库之后，在删除一次缓存。如我们的冻结接口：
```java
@Transactional(rollbackFor = Exception.class)  
public UserOperatorResponse freeze(Long userId) {  
    UserOperatorResponse userOperatorResponse = new UserOperatorResponse();  
    User user = userMapper.findById(userId);  
    Assert.notNull(user, () -> new UserException(USER_NOT_EXIST));  
    Assert.isTrue(user.getState() == UserStateEnum.ACTIVE, () -> new UserException(USER_STATUS_IS_NOT_ACTIVE));  
      
    //第一次删除缓存  
    telUserCache.remove(user.getTelephone());  
    idUserCache.remove(user.getId().toString());  
      
    if (user.getState() == UserStateEnum.FROZEN) {  
        userOperatorResponse.setSuccess(true);  
        return userOperatorResponse;  
    }  
    //更新数据库  
    user.setState(UserStateEnum.FROZEN);  
    boolean updateResult = updateById(user);  
    Assert.isTrue(updateResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));  
    //加入流水  
    long result = userOperateStreamService.insertStream(userId, UserOperateTypeEnum.FREEZE);  
    Assert.notNull(result, () -> new BizException(RepoErrorCode.UPDATE_FAILED));  
      
    //第二次删除缓存  
    userCacheDelayDeleteService.delayedCacheDelete(telUserCache, idUserCache, user);  
      
    userOperatorResponse.setSuccess(true);  
    return userOperatorResponse;  
}
```

这里，我们在更新数据库之前先删除了一次缓存。在更新数据库之后借助userCacheDelayDeleteService进行了一次延迟双删。

delayedCacheDelete其实就是一个延迟任务，延迟2秒钟再清空一次缓存，避免出现不一致的情况。
```java
@Scheduled(fixedDelay = 2, timeUnit = TimeUnit.SECONDS)  
public void delayedCacheDelete(Cache telUserCache, Cache idUserCache, User user) {  
    boolean telDeleteResult = telUserCache.remove(user.getTelephone());  
    log.info("telUserCache removed, key = {} , result  = {}", user.getTelephone(), telDeleteResult);  
    boolean idDeleteResult = idUserCache.remove(user.getId().toString());  
    log.info("idUserCache removed, key = {} , result  = {}", user.getId(), idDeleteResult);  
}
```

