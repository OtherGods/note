我们的项目中提供了很多子服务，他们都是提供了 `web` 访问入口的，比如`User`、`Trade` 等模块，如果知道应用启动的端口号就能直接通过端口访问。

这样就会存在绕过网关访问内网服务的风险。所以，我们需要提供一套机制来实现逻辑隔离，即：**==子服务与网关同时暴露在外网，但是子服务会有一个权限拦截层保证只接受网关发送来的请求，绕过网关直接访问子服务会被提示：无效请求==**

我们的项目中就是 **==借助 `SaToken` 实现内部服务外网隔离==**。主要的原理就是在 `Gateway` 中埋一个授权，并且在自服务中进行校验，如果有这个授权，则认为请求是从网关过来的，否则就不是，就可以直接拒绝掉请求。

主要的实现方式如下（这段在 master 中暂时没有，后来发现有点问题没解决，等解决后重新发）：

1、在网关中埋点`SAME_TOKEN`：
```java
@Component  
public class AuthFilter implements GlobalFilter {  
    @Override  
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {  
        ServerHttpRequest request = exchange.getRequest();  
          
        // 修改请求头  
        request = request.mutate()  
                .header(SaSameUtil.SAME_TOKEN, SaSameUtil.getToken())  
                .build();  
          
        ServerWebExchange newExchange = exchange.mutate().request(request).build();  
        return chain.filter(newExchange);  
    }  
}
```

以上代码在Gateway的应用中添加。

2、在子服务中进行Token校验
```java
@AutoConfiguration  
@ConditionalOnWebApplication  
public class WebConfiguration implements WebMvcConfigurer {  
      
    @Bean  
    @ConditionalOnMissingBean  
    GlobalWebExceptionHandler globalWebExceptionHandler() {  
        return new GlobalWebExceptionHandler();  
    }  
      
    /**  
     * 注册 Sa-Token 全局过滤器  
     */  
    @Bean  
    public SaServletFilter getSaServletFilter() {  
        return new SaServletFilter().addInclude("/**").setAuth(obj -> {  
            SaSameUtil.checkCurrentRequestToken();  
        }).setError(e -> SaResult.error(e.getMessage()));  
    }  
}
```

在子服务中增加对`token`的校验，如果校验失败则无法访问。