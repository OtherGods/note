水平权限漏洞是指Web应用程序接收到用户请求时，没有判断数据的所属人，或者在判断数据所属人时是从用户提交的参数中获取了userid，导致攻击者可以自行修改userid修改不属于自己的数据。**【ChatGPT解释：水平权限漏洞的关键在于缺乏对同级用户之间权限的严格控制。通过严格的身份验证、访问权限检查和安全的参数设计，可以有效防止这种漏洞的发生】**

我们的项目中提供了很多接口，我们是如何做水平权限控制的呢？

其实我们就做了两件事：

1、用户id 不相信前端输入的，而是我们自己从 session 中获取。

2、用户资产（如订单）操作的时候，进行 userId 的校验。

那我们的订单支付接口举例。以下是支付接口的部分代码：
```java
@PostMapping("/pay")  
public Result<PayOrderVO> pay(@Valid @RequestBody PayParam payParam) {  
    String userId = (String) StpUtil.getLoginId();  
    SingleResponse<TradeOrderVO> singleResponse = orderFacadeService.getTradeOrder(payParam.getOrderId(), userId);  
}
```

从这里可以看到，我们并没有从PayParam中获取userId，而是通过StpUtil从 session 中获取的，获取到的用户 ID一定是当前登录的用户 ID。

并且，使用用户传入的订单号+Session 中取出来的 userId 进行订单查询，如果这订单不存在，或者不是属于这个用户的，那么就会查不到，那么接口就会提示错误，避免了水平越权。只有订单存在并且属于当前登录用户时才能进行支付操作！

并且，我们在OrderManageService 提供了一个hasPermission方法，也是用来控制判断操作权限的。
```java
private boolean hasPermission(TradeOrder existOrder, TradeOrderEvent orderEvent, String operator, UserType operatorType) {  
    switch (orderEvent) {  
        case PAY:  
        case CANCEL:  
            return existOrder.getBuyerId().equals(operator);  
        case TIME_OUhasPermissionT:  
        case CONFIRM:  
        case FINISH:  
            return operatorType == UserType.PLATFORM;  
        default:  
            throw new UnsupportedOperationException("unsupport order event : " + orderEvent);  
    }  
}
```

这里之所以又做了一遍，主要是因为这个服务是一个基础服务，我们不能完全依赖上游的 Controller 的实现，因为在实际业务中，交易模块和订单模块是两个模块。即使交易模块做了越权校验，但是订单模块也还是要做的，这是一种自我保护的机制。万一上游没做好，我自己还是可以的控住避免出现水平越权的！
