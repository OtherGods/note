在我们的项目中，为了方便统一处理参数，我定义了一个通用的入参的基类和出参的基类。

入参的基类——BaseRequest
```java
package cn.hollis.nft.turbo.base.request;  
  
import lombok.Getter;  
import lombok.Setter;  
  
import java.io.Serializable;  
  
@Setter  
@Getter  
public class BaseRequest implements Serializable {  
    private static final long serialVersionUID = 1L;  
      
}
```

出参的基类——BaseResponse
```java
package cn.hollis.nft.turbo.base.response;  
  
import lombok.Getter;  
import lombok.Setter;  
  
import java.io.Serializable;  
@Setter  
@Getter  
public class BaseResponse implements Serializable {  
    private static final long serialVersionUID = 1L;  
      
    private Boolean success;  
      
    private String responseCode;  
      
    private String responseMessage;  
}
```

定义这个的好处是什么呢？

首先就是一些通用的参数我们可以直接封装好，比如出参中的 success、responseCode、responseMessage 等字段，以及serialVersionUID的通用定义等。

这样我们自己的具体的业务的入参和出参，只需要继承这两个基类，然后定义好自己的业务字段就行了。不需要关注非业务相关字段了。

除了这两个通用的BaseRequest和BaseResponse外，在他们的同级目录下，还定义了一些其他的通用类型。如：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202412292336289.png)

如用作分页的 PageRequest 和 PageResponse ：
```java
package cn.hollis.nft.turbo.base.request;  
  
import lombok.Getter;  
import lombok.Setter;  
  
@Setter  
@Getter  
public class PageRequest extends BaseRequest {  
    private static final long serialVersionUID = 1L;  
      
    /**  
     * 当前页  
     */  
    private int currentPage;  
    /**  
     * 每页结果数  
     */  
    private int pageSize;  
}
```

```java
package cn.hollis.nft.turbo.base.response;  
  
import lombok.Getter;  
import lombok.Setter;  
  
import java.util.List;  
  
@Setter  
@Getter  
public class PageResponse<T> extends MultiResponse<T> {  
    private static final long serialVersionUID = 1L;  
      
    /**  
     * 当前页  
     */  
    private int currentPage;  
    /**  
     * 每页结果数  
     */  
    private int pageSize;  
    /**  
     * 总页数  
     */  
    private int totalPage;  
    /**  
     * 总数  
     */  
    private int total;  
      
    public static <T> PageResponse<T> of(List<T> datas, int total, int pageSize) {  
        PageResponse<T> multiResponse = new PageResponse<>();  
        multiResponse.setSuccess(true);  
        multiResponse.setDatas(datas);  
        multiResponse.setTotal(total);  
        multiResponse.setPageSize(pageSize);  
        multiResponse.setTotalPage((pageSize + total - 1) / pageSize);  
        return multiResponse;  
    }  
}
```

