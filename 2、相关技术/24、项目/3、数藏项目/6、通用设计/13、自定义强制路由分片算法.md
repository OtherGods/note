ShardingJDBC支持通过 Hint 的方式进行强制路由，也就是说我们可以自己指定想要去那张表做增删改查。

But，这里吐槽一句 sharding jdbc的官方文档，例子根本就是错的，配置完不生效，问题排查了一天，网上各种资料，也 tm 都是拿官方文档抄出来的，根本就运行不了。

以下是我用的5.2.1版本的文档，大家就不要参考了，是错误的（辣鸡！！！！）,直接看我给大家的配置就行了。

https://shardingsphere.apache.org/document/5.2.1/cn/user-manual/shardingsphere-jdbc/special-api/sharding/hint/

配置文件启用 hint的策略：
```xml
shardingsphere:  
  rules:  
    sharding:  
      tables:  
        trade_order:  
          actual-data-nodes: ds.trade_order_000${0..3}  
          keyGenerateStrategy:  
            column: id  
            keyGeneratorName: snowflake  
          table-strategy:  
            hint:  
              shardingAlgorithmName: turbo-hint-sharding  
      shardingAlgorithms:  
        turbo-hint-sharding:  
          type: CLASS_BASED  
          props:  
            algorithmClassName: cn.hollis.nft.turbo.datasource.sharding.algorithm.TurboHintShardingAlgorithm  
            strategy: hint  
      keyGenerators:  
        snowflake:  
          type: SNOWFLAKE  
      auditors:  
        sharding_key_required_auditor:  
          type: DML_SHARDING_CONDITIONS
```

通过table-strategy.hint.shardingAlgorithmName指定具体算法，再通过算法名定义具体的实现类。

以下是TurboHintShardingAlgorithm的具体实现，其实就是根据用户通过 hint 设置的值进行精确路由，找到具体的代表。
```java
package cn.hollis.nft.turbo.datasource.sharding.algorithm;  
  
import org.apache.commons.collections4.CollectionUtils;  
import org.apache.shardingsphere.sharding.api.sharding.hint.HintShardingAlgorithm;  
import org.apache.shardingsphere.sharding.api.sharding.hint.HintShardingValue;  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
  
import java.util.Collection;  
import java.util.HashSet;  
import java.util.Properties;  
  
/**  
 * @author Hollis */public class TurboHintShardingAlgorithm implements HintShardingAlgorithm<String> {  
    private Properties props;  
      
    private static final Logger LOG = LoggerFactory.getLogger(TurboHintShardingAlgorithm.class);  
      
    @Override  
    public Collection<String> doSharding(Collection<String> collection, HintShardingValue<String> hintShardingValue) {  
        String logicTableName = hintShardingValue.getLogicTableName();  
        Collection<String> shardingTargets = hintShardingValue.getValues();  
          
        Collection<String> matchedTables = new HashSet<>();  
        for (String shardingTarget : shardingTargets) {  
            matchedTables.add(logicTableName + "_" + shardingTarget);  
        }  
          
        LOG.info("matchedTables : " + matchedTables);  
        return CollectionUtils.intersection(collection, matchedTables);  
    }  
      
    @Override  
    public Properties getProps() {  
        return props;  
    }  
      
    @Override  
    public void init(Properties props) {  
        this.props = props;  
    }  
}
```

接着再看下调用方式：
```java
@Component  
public class OrderJob {  
      
    @Autowired  
    private OrderReadService orderReadService;  
      
    @Autowired  
    private DataSource dataSource;  
      
    private static final int PAGE_SIZE = 100;  
      
    private static final Logger LOG = LoggerFactory.getLogger(OrderJob.class);  
      
    @XxlJob("orderTimeOutExecuteWithHint")  
    public ReturnT<String> orderTimeOutExecuteWithHint() {  
        try {  
            int shardIndex = XxlJobHelper.getShardIndex();  
            int shardTotal = XxlJobHelper.getShardTotal();  
              
            LOG.info("orderTimeOutExecute start to execute , shardIndex is {} , shardTotal is {}", shardIndex, shardTotal);  
              
            int shardingTableCount = BusinessCode.TRADE_ORDER.tableCount();  
              
            if (shardIndex >= shardingTableCount) {  
                return ReturnT.SUCCESS;  
            }  
              
            List<Integer> shardingTableIndexes = new ArrayList<>();  
            for (int realTableIndex = 0; realTableIndex < shardingTableCount; realTableIndex++) {  
                if (realTableIndex % shardTotal == shardIndex) {  
                    shardingTableIndexes.add(realTableIndex);  
                }  
            }  
              
            shardingTableIndexes.forEach(index -> {  
                  
                try (HintManager hintManager = HintManager.getInstance()) {  
                    LOG.info("shardIndex {} is execute", index);  
                    hintManager.addTableShardingValue("trade_order", "000" + index);  
                    int currentPage = 1;  
                    Page<TradeOrder> page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE);  
                    page.getRecords().forEach(this::executeTimeoutSingle);  
                    while (page.hasNext()) {  
                        currentPage++;  
                        page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE);  
                        page.getRecords().forEach(this::executeTimeoutSingle);  
                    }  
                }  
            });  
              
            return ReturnT.SUCCESS;  
        } catch (Exception e) {  
            LOG.error("orderTimeOutExecute failed", e);  
            throw e;  
        }  
    }  
}
```

关键部分是：

```java
HintManager hintManager = HintManager.getInstance();hintManager.addTableShardingValue("trade_order", "000" + index);
```

即通过 HintManager来设置具体的分表进行CRUD。

在调用时，部分日志如下：
```java
2024-04-30 11:58:05,527 INFO [Thread-50 cn.hollis.nft.turbo.datasource.sharding.algorithm.TurboHintShardingAlgorithm - matchedTables : [trade_order_0002]

2024-04-30 11:58:05,528 INFO [Thread-50 ShardingSphere-SQL - Actual SQL: ds ::: SELECT COUNT(*) AS total FROM trade_order_0002 WHERE deleted = 0 AND (order_state = ? AND gmt_create < ?) ::: [CONFIRM, 2024-04-30 11:28:05.502]
```

可以看到，这里通过算法TurboHintShardingAlgorithm得到trade_order_0002，然后 SQL 就直接去trade_order_0002表查询了。

这里需要注意以下问题：
[11、Hint has previous value, please clear first.](2、相关技术/24、项目/3、数藏项目/14、问题排查/11、Hint%20has%20previous%20value,%20please%20clear%20first..md)
