
项目中使用分布式锁实例(包括锁在Redis的数据结构)：[9、分布式锁组件：nft-turbo-lock](2、相关技术/24、项目/3、数藏项目/9、公共组件/9、分布式锁组件：nft-turbo-lock.md)

我们经常要在代码中使用分布式锁，有很多锁，是要在方法入口处加锁，结束后解锁的，于是为了方便，我们定义了一个通用的注解，来进行分布式锁的实现。

# 分布式锁注解

```java
package cn.hollis.nft.turbo.lock;  
  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
  
/**  
 * 分布式锁注解  
 *  
 * @author Hollis
 */
@Target(ElementType.METHOD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface DistributeLock {  
      
    /**  
     * 锁的场景  
     *  
     * @return     
     * */    
     public String scene();  
      
    /**  
     * 加锁的key，优先取key()，如果没有，则取keyExpression()  
     *     
     * @return     
     * */    
     public String key() default DistributeLockConstant.NONE_KEY;  
      
    /**  
     * SPEL表达式:  
     * <pre>  
     *     #id     
     *     #insertResult.id     
     * </pre>  
     *     
     * @return     
     * */    
     public String keyExpression() default DistributeLockConstant.NONE_KEY;  
      
    /**  
     * 超时时间，毫秒  
     * 默认情况下不设置超时时间，会自动续期  
     *  
     * @return     
     * */    
     public int expireTime() default DistributeLockConstant.DEFAULT_EXPIRE_TIME;  
      
    /**  
     * 加锁等待时长，毫秒  
     * 默认情况下不设置等待时长，不做等待  
     * @return  
     */    
     public int waitTime() default DistributeLockConstant.DEFAULT_WAIT_TIME;  
}
```

其中定义了很多参数，其中 `key` 和 `keyExpression` 二选一，只能有一个，`key` 表示规定值当作锁的 `key`，`keyExpression`表示是一个SPEL 表达式。

使用方法如下：
```java
@DistributeLock(keyExpression = "#payCreateRequest.bizNo", scene = "GENERATE_PAY_URL")  
public PayCreateResponse generatePayUrl(PayCreateRequest payCreateRequest) {

}
```

在生成支付链接时，直接在方法上加上注解，实现自动加锁和解锁。

# 分布式锁注解解析器

锁的实现逻辑如下：
```java
package cn.hollis.nft.turbo.lock;  
  
import org.aspectj.lang.ProceedingJoinPoint;  
import org.aspectj.lang.annotation.Around;  
import org.aspectj.lang.annotation.Aspect;  
import org.aspectj.lang.reflect.MethodSignature;  
import org.redisson.api.RLock;  
import org.redisson.api.RedissonClient;  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import org.springframework.core.StandardReflectionParameterNameDiscoverer;  
import org.springframework.expression.EvaluationContext;  
import org.springframework.expression.Expression;  
import org.springframework.expression.spel.standard.SpelExpressionParser;  
import org.springframework.expression.spel.support.StandardEvaluationContext;  
import org.springframework.stereotype.Component;  
  
import java.lang.reflect.Method;  
import java.util.concurrent.TimeUnit;  
  
@Aspect  
@Component  
public class DistributeLockAspect {  
      
    private RedissonClient redissonClient;  
      
    public DistributeLockAspect(RedissonClient redissonClient) {  
        this.redissonClient = redissonClient;  
    }  
      
    private static final Logger LOG = LoggerFactory.getLogger(DistributeLockAspect.class);  
      
    @Around("@annotation(cn.hollis.nft.turbo.lock.DistributeLock)")  
    public Object process(ProceedingJoinPoint pjp) throws Exception {  
        Object response = null;  
        Method method = ((MethodSignature) pjp.getSignature()).getMethod();  
        DistributeLock distributeLock = method.getAnnotation(DistributeLock.class);  
          
        String key = distributeLock.key();  
        if (DistributeLockConstant.NONE_KEY.equals(key)) {  
            if (DistributeLockConstant.NONE_KEY.equals(distributeLock.keyExpression())) {  
                throw new DistributeLockException("no lock key found...");  
            }  
            SpelExpressionParser parser = new SpelExpressionParser();  
            Expression expression = parser.parseExpression(distributeLock.keyExpression());  
              
            EvaluationContext context = new StandardEvaluationContext();  
            // 获取参数值  
            Object[] args = pjp.getArgs();  
              
            // 获取运行时参数的名称  
            StandardReflectionParameterNameDiscoverer discoverer  
                    = new StandardReflectionParameterNameDiscoverer();  
            String[] parameterNames = discoverer.getParameterNames(method);  
              
            // 将参数绑定到context中  
            if (parameterNames != null) {  
                for (int i = 0; i < parameterNames.length; i++) {  
                    context.setVariable(parameterNames[i], args[i]);  
                }  
            }  
              
            // 解析表达式，获取结果  
            key = String.valueOf(expression.getValue(context));  
        }  
          
        //锁的 key 拼装  
        String scene = distributeLock.scene();  
          
        String lockKey = scene + "#" + key;  
          
        int expireTime = distributeLock.expireTime();  
        int waitTime = distributeLock.waitTime();  
          
        //获取 rLock        RLock rLock = redissonClient.getLock(lockKey);  
        boolean lockResult = false;  
          
        //如果未设置waitTime，则调用 lock，否则调用tryLock  
        if (waitTime == DistributeLockConstant.DEFAULT_WAIT_TIME) {  
            //根据失效时间，判断调用不同方法  
            if (expireTime == DistributeLockConstant.DEFAULT_EXPIRE_TIME) {  
                LOG.info(String.format("lock for key : %s", lockKey));  
                rLock.lock();  
            } else {  
                LOG.info(String.format("lock for key : %s , expire : %s", lockKey, expireTime));  
                rLock.lock(expireTime, TimeUnit.MILLISECONDS);  
            }  
            lockResult = true;  
        } else {  
            if (expireTime == DistributeLockConstant.DEFAULT_EXPIRE_TIME) {  
                LOG.info(String.format("try lock for key : %s , wait : %s", lockKey, waitTime));  
                lockResult = rLock.tryLock(waitTime, TimeUnit.MILLISECONDS);  
            } else {  
                LOG.info(String.format("try lock for key : %s , expire : %s , wait : %s", lockKey, expireTime, waitTime));  
                lockResult = rLock.tryLock(waitTime, expireTime, TimeUnit.MILLISECONDS);  
            }  
        }  
          
          
        //加锁失败，打印日志。并抛出异常  
        if (!lockResult) {  
            LOG.warn(String.format("lock failed for key : %s , expire : %s", lockKey, expireTime));  
            throw new DistributeLockException("acquire lock failed... key : " + lockKey);  
        }  
          
        try {  
            //加锁成功，执行正常的业务逻辑  
            LOG.info(String.format("lock success for key : %s , expire : %s", lockKey, expireTime));  
            response = pjp.proceed();  
        } catch (Throwable e) {  
            throw new Exception(e);  
        } finally {
		    // 增加判断是为了让代码更具健壮性，如果没成功获取锁，那么这个继承自jdk自带的juc的api会抛异常
	        if (rLock.isHeldByCurrentThread()) {
	            //finally 中进行解锁  
	            rLock.unlock();  
	            LOG.info(String.format("unlock for key : %s , expire : %s", lockKey, expireTime));  
            }
        }  
        return response;  
    }  
}
```


> **代码解释**
> 在 `DistributeLockAspect` 类中，SpEL（Spring Expression Language）表达式的处理主要用于动态生成分布式锁的键（`key`）。这一过程允许开发者通过注解中的表达式引用方法参数或其他上下文信息来动态生成锁键，从而提供更加灵活和动态的锁控制。
> 
> **SpEL 表达式处理流程**
> 1. **获取注解和表达式**：
>     - 在 `process` 方法中，首先通过反射获取被注解方法上的 `@DistributeLock` 注解。
>     - 检查注解中的 `key` 属性是否为空或指定为默认值（如 `NONE_KEY`）。如果是，则进一步检查 `keyExpression` 属性，该属性包含了用于生成锁键的 SpEL 表达式。
> 2. **解析 SpEL 表达式**：
>     - 如果存在 `keyExpression`，则使用 `SpelExpressionParser` 来解析该表达式。
>     - 创建 `StandardEvaluationContext` 实例，用于后续评估表达式时提供上下文环境。
> 3. **准备上下文环境**：
>     - 获取方法参数值（`args`）和参数名称（`parameterNames`）。这通过 `ProceedingJoinPoint` 和 `StandardReflectionParameterNameDiscoverer` 实现。
>     - 将参数名称和对应的参数值设置到 `EvaluationContext` 中，以便在评估表达式时能够引用这些值。
> 4. **评估表达式并生成锁键**：
>     - 使用 `Expression` 实例的 `getValue(context)` 方法评估 SpEL 表达式，并根据上下文环境生成最终的锁键。
>     - 将生成的锁键转换为字符串类型，以便后续使用。
> 
> **代码优化** 
> 
> 1. 注解解析器最后finally块中的判断逻辑：增强代码健壮性 ===> 增加判断，未成功获取锁就不释放锁，否则这个JUC的API会报错 [1.2、误解锁问题](2、相关技术/5、数据库-Redis/Hollis/51、Redis实现分布锁的时候，哪些问题需要考虑？.md#1.2、误解锁问题)

代码中给大家加了注释，就不展开介绍了。

后面还做了个优化，在这个切面上加了个@Order(Integer.MIN_VALUE)，让它可以最早执行，避免并发时事务未提交但是锁释放导致的问题。

[14、用了一锁二判三更新，但是幂等被击穿](2、相关技术/24、项目/3、数藏项目/14、问题排查/1、重写中间件源码/14、用了一锁二判三更新，但是幂等被击穿.md)


