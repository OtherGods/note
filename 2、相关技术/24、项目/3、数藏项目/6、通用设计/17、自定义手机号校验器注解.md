如果我们想要在用户登录环节、针对输入的手机号做校验，常见的做法是通过正则表达式进行匹配，判断是不是一个合法的手机号格式。

这个功能，我们可以直接用 Hutool 给我们提供的`Validator.isMobile();` 方法轻松实现。这没啥好说的，无非就是一个 API 的调用。

能不能更加优雅一点，通过自定义注解来实现自动校验？比如下面这个@NotBlank，是否可以实现一个手机号校验的自定义注解呢
```java
@GetMapping("/sendCaptcha")  
public Result<Boolean> sendCaptcha(@NotBlank String telephone) {  
    NoticeResponse noticeResponse = noticeFacadeService.generateAndSendSmsCaptcha(telephone);  
    return Result.success(noticeResponse.getSuccess());  
}
```

有了它之后，我们就可以在参数中增加这个注解来实现手机号的快速校验了。

那肯定是可以的，说干就干。在Java中，自定义一个用于手机号校验的注解可以通过以下步骤实现：
1. **创建自定义注解**：定义一个注解，并指定目标和保留策略。
2. **实现校验器**：创建一个实现`ConstraintValidator`接口的类。
3. **将注解应用于字段**：在需要校验的字段上使用自定义注解。

### 创建自定义注解

```java
package cn.hollis.nft.turbo.base.validator;  
  
import jakarta.validation.Constraint;  
import jakarta.validation.Payload;  
  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
  
/**  
 * 是否手机号校验注解  
 *  
 * @author Hollis 
 */
@Constraint(validatedBy = MobileValidator.class)  
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.PARAMETER})  
@Retention(RetentionPolicy.RUNTIME)  
public @interface IsMobile {  
    String message() default "手机号格式不正确"; // 默认错误信息  
    Class<?>[] groups() default {};  
      
    Class<? extends Payload>[] payload() default {};  
}
```

#### ChatGPT解释

这段代码定义了一个名为`IsMobile`的自定义校验注解，用于验证某个字段或方法的参数是否为一个有效的手机号。这个注解是基于Jakarta Bean Validation API（Java EE的一部分，用于声明式验证）实现的。下面是对这段代码的详细解释：

##### 1. 注解定义

```java
@interface IsMobile {
```

这行代码定义了一个名为`IsMobile`的注解。在Java中，使用`@interface`关键字来定义一个注解。

##### 2. 校验器指定

```java
@Constraint(validatedBy = MobileValidator.class)
```

- `@Constraint`：这是Jakarta Bean Validation API中的一个注解，用于指定该自定义注解的校验器类。
- `validatedBy = MobileValidator.class`：这表示`IsMobile`注解的校验逻辑将由`MobileValidator`类实现。

##### 3. 注解适用目标

```java
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.PARAMETER})
```

- `@Target`：这个注解用于指定`IsMobile`注解可以应用的目标元素类型。
- `{ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.PARAMETER}`：这表示`IsMobile`注解可以应用于方法、字段、注解类型和参数上。

##### 4. 注解保留策略

```java
@Retention(RetentionPolicy.RUNTIME)
```

- `@Retention`：这个注解用于指定注解的保留策略。
- `RetentionPolicy.RUNTIME`：这表示`IsMobile`注解不仅会被保留在编译后的.class文件中，还会在运行时通过反射机制被JVM保留，因此可以通过反射在运行时访问到该注解的信息。

##### 5. 注解属性

```java
String message() default "手机号格式不正确"; // 默认错误信息
Class<?>[] groups() default {};
Class<? extends Payload>[] payload() default {};
```

- `message()`：这是一个返回字符串的方法，用于指定当校验失败时返回的错误信息。默认值为`"手机号格式不正确"`。
- `groups()`：这是一个返回`Class<?>[]`数组的方法，用于指定校验分组。默认值为空数组，表示该注解不属于任何特定的校验分组。
- `payload()`：这是一个返回`Class<? extends Payload>[]`数组的方法，用于指定校验的负载（Payload）。默认值为空数组，表示该注解不携带任何额外的负载信息。

##### 6. 总结

`IsMobile`注解是一个自定义的校验注解，用于验证某个字段或方法的参数是否为一个有效的手机号。它指定了校验器类`MobileValidator`来实现具体的校验逻辑，并定义了注解的适用目标、保留策略以及默认的错误信息。通过使用这个注解，开发者可以在代码中方便地声明对手机号格式的校验要求，提高代码的可读性和可维护性。

### 实现校验器

创建一个实现`ConstraintValidator`接口的类，进行实际的校验逻辑：
```java
package cn.hollis.nft.turbo.base.validator;  
  
  
import cn.hutool.core.lang.Validator;  
import jakarta.validation.ConstraintValidator;  
import jakarta.validation.ConstraintValidatorContext;  
  
/**  
 * 手机号校验器  
 *  
 * @author Hollis
 */
public class MobileValidator implements ConstraintValidator<IsMobile, String> {  
    @Override  
    public boolean isValid(String value, ConstraintValidatorContext context) {  
        return Validator.isMobile(value);  
    }  
}
```

如上，定义好之后，只需要如下方式使用：
```java
@GetMapping("/sendCaptcha")  
public Result<Boolean> sendCaptcha(@IsMobile String telephone) {  
    NoticeResponse noticeResponse = noticeFacadeService.generateAndSendSmsCaptcha(telephone);  
    return Result.success(noticeResponse.getSuccess());  
}
```

或者：
```java
public class RegisterParam {  
      
    /**  
     * 手机号  
     */  
    @IsMobile  
    private String telephone;  
}
```

就可以了，改造之后，我们在页面上注册时候输入一个不合法的手机号，得到的响应内容如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501022315085.png)

