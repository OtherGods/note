我们的代码中，有很多 RPC 的调用，然后为了方便的做参数校验，我们自定义了一个 AOP 来统一处理。

首先定义了一个注解 @Facade
```java
package cn.hollis.nft.turbo.rpc.facade;  
/**  
 * @author Hollis
*/
public @interface Facade {  
}
```

然后实现他的处理逻辑：
```java
package cn.hollis.nft.turbo.rpc.facade;  
  
  
/**  
 * Facade的切面处理类，统一统计进行参数校验及异常捕获  
 *  
 * @author Hollis 
 */
@Aspect  
@Component  
public class FacadeAspect {  
      
    private static final Logger LOGGER = LoggerFactory.getLogger(FacadeAspect.class);  
      
    @Around("@annotation(cn.hollis.nft.turbo.rpc.facade.Facade)")  
    public Object facade(ProceedingJoinPoint pjp) throws Exception {  
          
        StopWatch stopWatch = new StopWatch();  
        stopWatch.start();  
          
        Method method = ((MethodSignature) pjp.getSignature()).getMethod();  
        Object[] args = pjp.getArgs();  
        LOGGER.info("start to execute , method = " + method.getName() + " , args = " + JSON.toJSONString(args));  
          
        Class returnType = ((MethodSignature) pjp.getSignature()).getMethod().getReturnType();  
          
        //循环遍历所有参数，进行参数校验  
        for (Object parameter : args) {  
            try {  
                BeanValidator.validateObject(parameter);  
            } catch (ValidationException e) {  
                printLog(stopWatch, method, args, "failed to validate", null, e);  
                return getFailedResponse(returnType, e);  
            }  
        }  
          
        //省略其他代码  
    }  
}
```

在这个切面中 ，针对参数做循环遍历，案后可通过我们的BeanValidator.validateObject进行参数校验。如果校验失败，则直接返回失败。

这里的 BeanValidator 的代码如下：
```java
package cn.hollis.nft.turbo.base.utils;  
  
  
/**  
 * 参数校验工具  
 *  
 * @author Hollis 
 */
public class BeanValidator {  
      
    private static Validator validator = Validation.byProvider(HibernateValidator.class).configure().failFast(true)  
            .buildValidatorFactory().getValidator();  
      
    /**  
     * @param object object  
     * @param groups groups  
     */    public static void validateObject(Object object, Class<?>... groups) throws ValidationException {  
        Set<ConstraintViolation<Object>> constraintViolations = validator.validate(object, groups);  
        if (constraintViolations.stream().findFirst().isPresent()) {  
            throw new ValidationException(constraintViolations.stream().findFirst().get().getMessage());  
        }  
    }  
}
```

其实逻辑挺简单的，就是通过 HibernateValidator 进行统一校验。

这里需要注意一下：
```java
private static Validator validator = Validation.byProvider(HibernateValidator.class).configure().failFast(true)  
        .buildValidatorFactory().getValidator();
```

一定要定义成 static 的变量，而不是在方法内每次都创建一个 ，会导致CPU 飙高！

用法如下：
```java
/**  
 * @author Hollis 
 */
@DubboService(version = "1.0.0")  
public class OrderFacadeServiceImpl implements OrderFacadeService {  
      
      
    @Override  
    @Facade  
    public OrderResponse create(OrderCreateRequest request) {  
        Boolean preDeductResult = inventoryWrapperService.preDeduct(request);  
        if (preDeductResult) {  
            return orderService.create(request);  
        }  
        throw new OrderException(OrderErrorCode.INVENTORY_DEDUCT_FAILED);  
    }  
}
```

在方法上增加 @Facade 注解即可。

