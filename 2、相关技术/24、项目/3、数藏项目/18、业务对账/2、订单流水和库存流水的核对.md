下单过程中，会扣减库存，创建订单。关单过程，会释放库存，取消订单。而这两个系统是分布式的，不同的微服务，他们之间无法通过本地事务保证一致性。

虽然我们做了分布式事务，下单的时候，我们通过MQ重试的方式或者TCC的方式来保证一致性。关单的时候我们通过RocketMQ的事务消息来保证一致性。

但是，在极端情况下还是会出现不一致新的问题，比如：

1、秒杀方案中，MQ链路上进行订单创建和库存扣减的时候，因为系统或者数据库异常，导致长时间未恢复，最终MQ超时进入了死信队列，而死信队列又没监听，那么就会出现库存和订单不一致的情况。

2、TCC方案中，如果在Confirm阶段，库存处理成功了，订单处理失败了，系统重启了，这时候就不一致了。

总之，无论是本地消息表、事务消息、还是任务重试，系统之间的调用都是有可能失败的。而一旦发生失败，就需要有一套机制来发现这些不一致的问题，这时候就需要做**数据对账**了。

那么，我们就需要可以核对出库存和订单的不一致的情况。

### 流水的重要性

想要核对库存和订单之间的一致性，先说说他们的一致性怎么定义？

怎么算一致呢了？要满足以下几个条件：

1、库存扣减了，订单一定生成了

2、订单生成了，库存一定扣减了

3、库存释放了，订单一定取消了

4、订单取消了，库存一定释放了

5、库存扣减了几个，订单上面的下单商品数一定也是几个

那么，想要做这些内容的核对，**流水**就至关重要了。

所谓流水，其实就是每一次的操作记录。对于订单流水，我们有一张order_stream表，每一次的订单操作都会记录一条操作记录。对于库存流水，我们有一张collection_inventory_stream表，每一次的库存操作都会记录一条流水。

有了这两张表之后，就可以做核对了。

### 核对的方式

**对账的技术实现上一般主要就是两种，要么是写代码核对，要么是写SQL核对。**

写代码就是查出需要比对的两条记录，然后进行字段的比对，不一致的就抛出来。
- 写代码这种核对方式，一般来说都是通过定时任务实现的，通过运行定时任务，扫描库存流水，然后逐一去查询订单流水，比对是否存在，以及内容是否都一致。
- 定时任务的方案适合用在数据量不大的场景中，因为他的缺点就是一旦数据量大了，代码核对的时效性就会比较差，而且代码运行存在失败的可能。万一数据量特别大，就可能会出现扫表扫不动，文件加载到内存导致OOM等问题。

那么，更好一点的方式就是写SQL了，写SQL就是做join查询或者子查询，然后通过where条件比较需要核对的字段，不一致的就抛出来。

写SQL的话，有3种方式:

1、直接基于数据库做SQL查询

2、数据同步到准实时数据库，在准实时数据库中做SQL查询

3、数据同步到离线数仓，在离线数仓中写SQL查询

### 直接基于数据库做SQL查询

先说最简单的这种基于数据库直连做SQL查询对账的方案，SQL 核对脚本：对比订单流水表 (`trade_order_stream`) 和库存流水表 (`collection_inventory_stream`) 的一致性

**目标**

确保订单流水 (`trade_order_stream`) 与库存流水 (`collection_inventory_stream`) 的数据一致：

- **流水类型**：库存扣减流水（TRY_SALE、UNFREEZE_AND_SALE）和订单确认流水（CONFIRM）做匹配
- **数量一致**：订单购买的 `item_count` 是否与库存变更的 `changed_quantity` 一致。
- **幂等号一致**：订单表 (`trade_order_stream`) 的 `order_id` 与库存表 (`collection_inventory_stream`) 的 `identifier` 进行匹配。

**订单支付成功的状态是否匹配库存变更**。

1. **找出异常数据**
- **库存流水表中缺失的订单记录**（即 `trade_order_stream` 有订单，但 `collection_inventory_stream` 没有对应的库存变更）。
- **库存流水比订单流水多的情况**（可能是重复扣减库存）。
- **订单状态异常，如订单已支付但库存未扣减**。

SQL1：针对订单创建，但是库存未扣减，或者扣减数不一致的情况核对：

```sql
SELECT 
    o.order_id,
    o.goods_id AS collection_id,	o.gmt_create as order_time,	i.gmt_create as inventory_decrease_time,
    o.item_count AS order_quantity,
    i.changed_quantity AS inventory_quantity,
    CASE 
        WHEN i.identifier IS NULL THEN '库存未扣减'
        WHEN o.item_count > i.changed_quantity THEN '库存扣减不足'
        WHEN o.item_count < i.changed_quantity THEN '库存多扣减'

    END AS check_result
FROM trade_order_stream o
LEFT JOIN collection_inventory_stream i
ON o.order_id = i.identifier  -- 订单表的 order_id 匹配库存表的 identifier
AND o.goods_id = i.collection_idAND o.goods_type = "COLLECTION"
AND i.stream_type in ('TRY_SALE','UNFREEZE_AND_SALE')  -- 只比较库存扣减的流水
WHERE o.order_state = 'CONFIRM'  -- 只检查CONFIRM操作
AND o.deleted = 0  -- 排除已删除订单
AND (i.deleted = 0 OR i.identifier IS NULL)  -- 过滤库存逻辑删除，但保留未扣减情况AND (
    i.identifier IS NULL  -- 库存未扣减
    OR o.item_count > i.changed_quantity  -- 库存扣减不足
    OR o.item_count < i.changed_quantity  -- 库存多扣减
);
```

核对结果如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202509021100479.png)

SQL2：针对库存扣减了，但是订单未创建，或者订单上商品数量不一致的情况核对：

```sql
SELECT 
    i.identifier  AS order_id, 
    i.collection_id AS collection_id,
    NULL AS order_time,
    i.gmt_create AS inventory_decrease_time,
    NULL AS order_quantity,
    i.changed_quantity AS inventory_quantity,
    CASE 
        WHEN o.order_id IS NULL THEN '库存扣减但订单未创建'
        WHEN o.item_count <> i.changed_quantity THEN '库存扣减与订单数量不一致'
    END AS check_result
FROM collection_inventory_stream i
LEFT JOIN trade_order_stream_0003 o
ON i.identifier = o.order_id  
AND i.collection_id = o.goods_id  
AND o.goods_type = "COLLECTION"
WHERE 
i.stream_type IN ('TRY_SALE', 'UNFREEZE_AND_SALE')  
AND i.deleted = 0
AND (
    o.order_id IS NULL  -- 库存扣减但无对应订单
    OR o.item_count <> i.changed_quantity  -- 订单商品数量与库存变更数量不一致
);
```

核对结果如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202509021100698.png)

不过这里需要有1个点需要注意：

1、trade_order_stream 我们其实是做了分库分表的，核对的时候需要考虑多个分表的情况，要么就把他们union到一起做查询，例如：

```sql
SELECT 
    o.order_id,
    o.goods_id AS collection_id,
    o.gmt_create AS order_time,
    i.gmt_create AS inventory_decrease_time,
    o.item_count AS order_quantity,
    i.changed_quantity AS inventory_quantity,
    CASE 
        WHEN i.identifier IS NULL THEN '库存未扣减'
        WHEN o.item_count > i.changed_quantity THEN '库存扣减不足'
        WHEN o.item_count < i.changed_quantity THEN '库存多扣减'
    END AS check_result
FROM (
    SELECT * FROM trade_order_stream_0000
    UNION ALL
    SELECT * FROM trade_order_stream_0001
    UNION ALL
    SELECT * FROM trade_order_stream_0002
    UNION ALL
    SELECT * FROM trade_order_stream_0003
) o
LEFT JOIN collection_inventory_stream i
ON o.order_id = i.identifier  -- 订单表的 order_id 匹配库存表的 identifier
AND o.goods_id = i.collection_id
AND o.goods_type = "COLLECTION"
AND i.stream_type IN ('TRY_SALE','UNFREEZE_AND_SALE')  -- 只比较库存扣减的流水
WHERE o.order_state = 'CONFIRM'  -- 只检查CONFIRM操作
AND o.deleted = 0  -- 排除已删除订单
AND (i.deleted = 0 OR i.identifier IS NULL)  -- 过滤库存逻辑删除，但保留未扣减情况
AND (
    i.identifier IS NULL  -- 库存未扣减
    OR o.item_count > i.changed_quantity  -- 库存扣减不足
    OR o.item_count < i.changed_quantity  -- 库存多扣减
);
```

以上SQL能执行的前提是，trade_order_stream 和 collection_inventory_stream 是在同一个数据库中的。

**但是实际的业务中，订单和库存可能不在同一个数据库中，如果是同一个数据库实例的话，那还可以通过指定库名的方式做跨库join，但是如果不是同一个数据库实例，那这个方案就玩不转了。**

另外，还有个问题，那就是这个SQL应该在哪执行？有几种方式，第一种是通过定时任务，运行SQL查询，还有一种方式，就是开发一个专门做核对的平台，上面支持定时核对脚本执行。我们是用的第二种方案。

### 基于实时数仓核对

为了解决跨库无法join的问题，还有一种方案，那就是不直接在数据库中写SQL，而是把数据同步到其他的地方，比如通过监听binlog的方式，把MYSQL的数据同步到**实时数仓**，比如我们公司内部用的就是AnalyticDB：https://www.aliyun.com/product/ApsaraDB/ads

把需要做核对的数据同步到ADB中，我们会尽量放到一个空间下面，然后在这里面写SQL作核对。同步出来的这个ADB数据，不仅可以做核对，还可以用于查询或者做报表。

SQL和上面的基于数据库的查询基本一致，因为一般实时数仓都是兼容SQL语法的。

### 基于离线数仓核对

但是用准实时数据库也有个限制，那就是一般同一个部门的可以在一个空间下面，如果跨部门怎么办呢？

那就要用离线数仓了，如我们内部用的就是DataWorks：https://www.aliyun.com/product/bigdata/ide

离线数仓，主要用于离线数据核对。我们现在每天会把需要离线存储的数据同步到数仓中，然后在数仓中写SQL进行数据的核对。

SQL和上面的基于数据库的查询基本一致，因为离线数仓也基本都是支持SQL语法的。