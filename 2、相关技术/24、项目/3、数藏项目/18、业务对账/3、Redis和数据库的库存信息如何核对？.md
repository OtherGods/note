下单的时候，我们会分别在Redis和数据库中做库存扣减，可能会遇到 Redis 和数据库不一致 的问题。

那么这个一致性问题就至关重要了，我们如何通过核对来发现不一致的问题呢？

有两种方式，一种是实时逐条核对，一种是定时统一核对。

### 旁路验证

旁路验证，就是实时的逐条核对。**旁路验证**是一种**独立于主业务逻辑**的验证方法，它可以通过 监控、比对等方式，发现 Redis 和数据库的库存不一致问题。

比如我们的秒杀方案中，先扣减Redis的库存，然后发MQ，再监听MQ做数据库库存的扣减。

这时候就可以在主流程结束之后，做一个旁路，也就是启动一个子线程，他要做的事情就是延迟检查数据库库存是否扣减成功，比如延迟3秒钟（时间可调控）做检查

如果检查成功，则可以把Redis中的流水删除。如果没成功，则什么都不用做，可能是消息延迟了，等定时任务再重新检查即可。

`cn.hollis.nft.turbo.trade.controller.TradeController#inventoryBypassVerify`
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202509021106276.png)

### 定时核对

如果出现了一些延迟，导致旁路验证的时候数据库并没有库存扣减记录。那么这种情况怎么办的呢？

可以通过定时任务定期核对的方式实现。

我们可以定义一个定时任务，每1分钟执行一次，任务的内容：

1、查询所有参与秒杀的热点商品

2、针对热点商品，去Redis查询库存扣减流水（可用`HGETALL` 命令）

3、遍历所有库存扣减流水，逐条去库存数据库查询扣减记录，去订单库查询订单
- 因为Redis的流水中，也记录了幂等号，而数据库的库存流水和订单流水也有幂等号，所以只要没丢就都可以查询到。

4、如果没查到，则可能是丢消息了，通过告警或者插入废单的方式解决。

5、如果都查到了，判断其中的扣减数量是否一致，如果一致，则说明对齐了。

6、对齐的情况，可以考虑在流水中打个标，方便下次核对的时候做过滤。

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202509021107641.png)

告警方式可以是写入一条告警表，然后有个控制台可以看哪些告警，也可以发邮件之类的。

或者如果不想通过告警的方式做，也可以更加激进一点，那就是延迟1分钟发现还没有扣减库存成功，订单也没创建成功，这时候就直接往库存表和订单表插入一条费单记录，然后调Redis把库存回滚。

这样即使后面的扣减操作再来执行，也会失败，因为我们基于数据库的唯一性约束可以保证一个幂等号只能有一条操作流水，已经有一条废单了，正常单就不能写入了。（如果这时候有并发了也没关系，谁先来，谁先处理就行了。）

