[1、基于Redis的ZSET实现用户邀请排行榜](2、相关技术/24、项目/3、数藏项目/8、最佳实践/9、排行榜/1、基于Redis的ZSET实现用户邀请排行榜.md)

前面的实现中，如果分数相同，那么排序的结果是不确定的，那么如果我们想要实现多维度排名，即先按照分数排，分数相同的话按照上榜时间排，如何实现呢？

为了实现分数相同按照时间顺序排序，**我们可以将分数score设置为一个浮点数，其中整数部分为得分，小数部分为时间戳**，如下所示：

score = 分数 + 时间戳/1e13

假设现在的时间戳是1680417299000，除以1e13得到0.1680417299000，再加上一个固定的分数（比如10），那么最终的分数就是10.1680417299000，可以将它作为zset中某个成员的分数，用来排序。

这么做了之后，假如有四个数字：

10.1680417299000、10.1680417299011、11.1680417299000、11.1680417299011

他们按照倒序拍完顺序之后，会是：

11.1680417299011>11.1680417299000>10.1680417299011>10.1680417299000

实现了分数倒序排列，分数相同时间戳大（上榜更晚的）的排在了前面，这和我们的需求相反了，所以，就需要在做一次转换。

`score = 分数 + 1-时间戳/1e13`

因为时间戳是这种形式1708746590000 ，共有13位，而1e13是10000000000000，即1后面13个0，所以用时间戳/1e13就能得到一个小数

这样可以保证分数相同时，按照时间戳从小到大排序，即先得分的先被排在前面。

修改后的代码如下：
```java
private void updateInviteRank(String inviterId) {
    if (inviterId == null) {  
        return;  
    }  
    //1、这里因为是一个私有方法，无法通过注解方式实现分布式锁。  
    //2、register方法已经加了锁，这里需要二次加锁的原因是register锁的是注册人，这里锁的是邀请人  
    RLock rLock = redissonClient.getLock(inviterId);  
    rLock.lock();  
    try {  
        //获取当前用户的积分  
        Double score = inviteRank.getScore(inviterId);  
        if (score == null) {  
            score = 0.0;  
        }  
          
        //获取最近一次上榜时间  
        long currentTimeStamp = System.currentTimeMillis();  
        //把上榜时间转成小数(时间戳13位，所以除以10000000000000能转成小数)，并且倒序排列（用1减），即上榜时间越早，分数越大（时间越晚，时间戳越大，用1减一下，就反过来了）  
        double timePartScore = 1 - (double) currentTimeStamp / 10000000000000L;  
          
        //1、当前积分保留整数，即移除上一次的小数位  
        //2、当前积分加100，表示新邀请了一个用户  
        //3、加上“最近一次上榜时间的倒序小数位“作为score  
        inviteRank.add(score.intValue() + 100.0 + timePartScore, inviterId);  
    } finally {  
        rLock.unlock();  
    }  
}
```