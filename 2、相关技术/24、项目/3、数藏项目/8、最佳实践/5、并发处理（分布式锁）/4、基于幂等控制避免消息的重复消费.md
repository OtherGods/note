在分布式系统中，幂等性是指对相同操作执行多次，结果应该是相同的。

在消息传递系统中，我们需要确保消息的消费是幂等的，以避免重复消费带来的问题。

通常通过消息体中带入幂等号，然后再消息消费的时候对该幂等号进行校验，来控制并避免消息的重复消费.

## 步骤：

拿订单模块的消息取消来举例

### 1.设置消息体

```java
@Getter  
@Setter  
public class OrderCancelRequest extends BaseOrderUpdateRequest {  
      
    @Override  
    public TradeOrderEvent getOrderEvent() {  
        return TradeOrderEvent.CANCEL;  
    }  
}
```

```java
@Setter  
@Getter  
public abstract class BaseOrderUpdateRequest extends BaseOrderRequest {  
      
    /**  
     * 订单id  
     */
    @NotNull(message = "orderId 不能为空")  
    private String orderId;  
      
    /**  
     * 操作时间  
     */  
    @NotNull(message = "operateTime 不能为空")  
    private Date operateTime;  
      
    /**  
     * 操作人  
     */  
    @NotNull(message = "operator 不能为空")  
    private String operator;  
      
    /**  
     * 操作人类型  
     */  
    @NotNull(message = "operatorType 不能为空")  
    private UserType operatorType;  
}
```

```java
@Getter  
@Setter  
public abstract class BaseOrderRequest extends BaseRequest {  
      
    /**  
     * 操作幂等号  
     */  
    @NotNull(message = "identifier 不能为空")  
    private String identifier;  
      
    /**  
     * 获取订单事件  
     *  
     * @return
     */    
    public abstract TradeOrderEvent getOrderEvent();  
}
```

可以看到在BaseOrderRequest里面有identifier和orderEvent这两个参数，通过这两个参数来定义对订单的一次操作的幂等，对于为什么一个消息体需要定义成这几个类，这个是基于业务的抽象，把一些共有的属性往上层抽，便于复用

### 2.新增订单操作流水

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202503031004630.png)

该表是基于订单进行修改，新增stream_identifier和stream_type两个字段

### 3.消息配置
```yml
# 关于这段配置，可以参考：https://juejin.cn/post/7169946950920470542 或者更多spring cloud stream相关知识
spring:  
  cloud:  
    function:  
      definition: orderClose;heldCollection
    stream:  
      rocketmq:  
        bindings:  
          orderClose-out-0:  
            producer:  
              producerType: Trans  
              transactionListener: orderCloseTransactionListener  
          heldCollection-in-0:  
            consumer:  
              subscription:  
                expression: 'ACTIVE' # 这里设置你希望订阅的Tag  
      bindings:  
        heldCollection-in-0:  
          content-type: application/json  
          destination: held-collection-result-topic  
          group: held-collection-group  
          binder: rocketmq  
        orderClose-out-0:  
          content-type: application/json  
          destination: order-close-topic  
          group: order-group  
          binder: rocketmq
```

这里绑定了orderClose-out-0，有消息过来会触发orderCloseTransactionListener进行处理

#### 3.1 ChatGPT解释消息配置

这段配置是用于Spring Cloud Stream与RocketMQ集成的设置，主要涉及消息生产者和消费者的定义、事务消息处理以及主题订阅等。以下是对配置的逐层解析：

---

##### **1. Spring Cloud Function 定义**
```yaml
spring:
  cloud:
    function:
      definition: orderClose;heldCollection
```
- **作用**：声明了两个函数 `orderClose` 和 `heldCollection`，分别对应消息的生产者和消费者。
- **说明**：
  - `orderClose` 作为**生产者**，将消息发送到 RocketMQ。
  - `heldCollection` 作为**消费者**，从 RocketMQ 订阅消息。
  - 函数名需与实际代码中的 `@Bean` 或 `@StreamListener` 定义一致。

##### **2. RocketMQ 绑定配置**
```yaml
spring:
  cloud:
    stream:
      rocketmq:
        bindings:
          # 生产者配置
          orderClose-out-0:
            producer:
              producerType: Trans  # 事务型生产者
              transactionListener: orderCloseTransactionListener  # 事务监听器
          # 消费者配置
          heldCollection-in-0:
            consumer:
              subscription:
                expression: 'ACTIVE'  # 订阅Tag为"ACTIVE"的消息
```

###### **生产者 (`orderClose-out-0`)**
- **`producerType: Trans`**  
  指定生产者类型为**事务型**，确保消息发送与本地事务的原子性。
- **`transactionListener`**  
  关联事务监听器 `orderCloseTransactionListener`，需在代码中实现 `RocketMQLocalTransactionListener`，处理事务提交/回滚和回查逻辑。

###### **消费者 (`heldCollection-in-0`)**
- **`subscription.expression: 'ACTIVE'`**  
  订阅 Tag 为 `ACTIVE` 的消息。RocketMQ 通过 Tag 过滤消息，此处表示仅消费带有此 Tag 的消息。

##### **3. 消息通道绑定**
```yaml
spring:
  cloud:
    stream:
      bindings:
        heldCollection-in-0:
          content-type: application/json  # 消息格式为JSON
          destination: held-collection-result-topic  # 消费的主题
          group: held-collection-group  # 消费者组
          binder: rocketmq  # 使用RocketMQ绑定器
        orderClose-out-0:
          content-type: application/json
          destination: order-close-topic  # 发送的主题
          group: order-group
          binder: rocketmq
```

###### **公共配置**
- **`content-type: application/json`**  
  消息以 JSON 格式序列化/反序列化。
- **`destination`**  
  对应 RocketMQ 的 **Topic**。
- **`group`**  
  - 生产者：可选，通常用于分类。
  - 消费者：**消费者组名**，用于集群消费和偏移量管理。
- **`binder: rocketmq`**  
  指定使用 RocketMQ 的绑定器实现。

---

##### 4. **关键概念解析**
1. **事务消息 (`producerType: Trans`)**  
   - 生产者发送**半消息**到 RocketMQ，等待本地事务执行结果。
   - 事务监听器处理：
     - `executeLocalTransaction`：执行本地事务并返回状态（提交/回滚/未知）。
     - `checkLocalTransaction`：在事务状态未知时，RocketMQ 回调此方法检查最终状态。

2. **消费者组 (`group`)**  
   - 同一消费者组内的实例**分摊消费**消息（集群模式）。
   - 不同消费者组**独立消费**全量消息（广播模式）。

3. **Tag 过滤 (`subscription.expression`)**  
   - Tag 是 RocketMQ 的消息过滤标签，比 Topic 更细粒度。
   - 表达式 `'ACTIVE'` 表示只消费 Tag 为 `ACTIVE` 的消息，需与生产者发送时设置的 Tag 一致。

---

##### 5. **代码实现参考**

**事务监听器**
```java
@Component
public class OrderCloseTransactionListener implements RocketMQLocalTransactionListener {
    @Override
    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) {
        // 执行本地事务，返回COMMIT/ROLLBACK/UNKNOWN
        return RocketMQLocalTransactionState.COMMIT;
    }

    @Override
    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) {
        // 检查本地事务状态
        return RocketMQLocalTransactionState.COMMIT;
    }
}
```

**生产者与消费者函数**
```java
@Bean
public Supplier<Message<String>> orderClose() {
    return () -> MessageBuilder.withPayload("closeOrder")
        .setHeader(RocketMQHeaders.TAGS, "ACTIVE") // 设置消息Tag
        .build();
}

@Bean
public Consumer<Message<String>> heldCollection() {
    return msg -> {
        // 处理消费到的消息
        System.out.println("Received: " + msg.getPayload());
    };
}
```

**可能遗漏的配置**
- **RocketMQ Nameserver 地址**  
  需在配置中指定 RocketMQ 的 Namesrv 地址，通常如下：
  ```yaml
  spring:
    cloud:
      stream:
        rocketmq:
          binder:
            name-server: 127.0.0.1:9876
  ```

##### 6. **总结**
- 通过此配置，`orderClose` 函数向 `order-close-topic` 发送事务消息，由 `orderCloseTransactionListener` 处理事务。
- `heldCollection` 函数从 `held-collection-result-topic` 消费 Tag 为 `ACTIVE` 的 JSON 格式消息。
- 消费者组和事务机制保障了消息的可靠传输和处理。

### 4.消息处理通过流水进行幂等控制

```java
@Component
public class OrderCloseTransactionListener implements TransactionListener {
      
    private static final Logger logger = LoggerFactory.getLogger(OrderCloseTransactionListener.class);  
      
    @Autowired  
    private OrderManageService orderManageService;  
      
    @Autowired  
    private OrderReadService orderReadService;  
      
    @Override  
    public LocalTransactionState executeLocalTransaction(Message message, Object o) {  
        try {  
            Map<String, String> headers = message.getProperties();  
            String closeType = headers.get("CLOSE_TYPE");  
              
            OrderResponse response = null;  
            if (TradeOrderEvent.CANCEL.name().equals(closeType)) {  
                OrderCancelRequest cancelRequest = JSON.parseObject(JSON.parseObject(message.getBody()).getString("body"), OrderCancelRequest.class);  
                logger.info("executeLocalTransaction , baseOrderUpdateRequest = {} , closeType = {}", JSON.toJSONString(cancelRequest), closeType);  
                response = orderManageService.cancel(cancelRequest);  
            } else if (TradeOrderEvent.TIME_OUT.name().equals(closeType)) {  
                OrderTimeoutRequest timeoutRequest = JSON.parseObject(JSON.parseObject(message.getBody()).getString("body"), OrderTimeoutRequest.class);  
                logger.info("executeLocalTransaction , baseOrderUpdateRequest = {} , closeType = {}", JSON.toJSONString(timeoutRequest), closeType);  
                response = orderManageService.timeout(timeoutRequest);  
            } else {  
                throw new UnsupportedOperationException("unsupported closeType " + closeType);  
            }  
              
            if (response.getSuccess()) {  
                return LocalTransactionState.COMMIT_MESSAGE;  
            } else {  
                return LocalTransactionState.ROLLBACK_MESSAGE;  
            }  
        } catch (Exception e) {  
            logger.error("executeLocalTransaction error, message = {}", message, e);  
            return LocalTransactionState.ROLLBACK_MESSAGE;  
        }  
    }  
      
    @Override  
    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {  
        BaseOrderUpdateRequest baseOrderUpdateRequest = JSON.parseObject(messageExt.getBody(), BaseOrderUpdateRequest.class);  
          
        TradeOrder tradeOrder = orderReadService.getOrder(baseOrderUpdateRequest.getOrderId());  
          
        if (tradeOrder.getOrderState() == TradeOrderState.CLOSED) {  
            return LocalTransactionState.COMMIT_MESSAGE;  
        }  
          
        return LocalTransactionState.ROLLBACK_MESSAGE;  
    }  
}
```

如果是cancel的消息，会通过下面的代码块进行处理
```java
if (TradeOrderEvent.CANCEL.name().equals(closeType)) {  
OrderCancelRequest cancelRequest = JSON.parseObject(JSON.parseObject(message.getBody()).getString("body"), OrderCancelRequest.class);  
    logger.info("executeLocalTransaction , baseOrderUpdateRequest = {} , closeType = {}", JSON.toJSONString(cancelRequest), closeType);  
response = orderManageService.cancel(cancelRequest);  
}
```

其中cancel的核心逻辑
```java
/**  
 * 订单取消  
 *  
 * @param request  
 * @return  
 */public OrderResponse cancel(OrderCancelRequest request) {  
    return doExecute(request, tradeOrder -> tradeOrder.close(request));  
}
```

会调用通用的订单处理逻辑
```java
/**  
 * 通用订单更新逻辑  
 *  
 * @param orderRequest * @param consumer * @return */protected OrderResponse doExecute(BaseOrderUpdateRequest orderRequest, Consumer<TradeOrder> consumer) {  
    OrderResponse response = new OrderResponse();  
    return handle(orderRequest, response, "doExecute", request -> {  
          
        TradeOrder existOrder = orderMapper.selectByOrderId(request.getOrderId());  
        if (existOrder == null) {  
            throw new OrderException(ORDER_NOT_EXIST);  
        }  
          
        if (!hasPermission(existOrder, orderRequest.getOrderEvent(), orderRequest.getOperator(), orderRequest.getOperatorType())) {  
            throw new OrderException(PERMISSION_DENIED);  
        }  
          
        TradeOrderStream existStream = orderStreamMapper.selectByIdentifier(orderRequest.getIdentifier(), orderRequest.getOrderEvent().name(), orderRequest.getOrderId());  
        if (existStream != null) {  
            return new OrderResponse.OrderResponseBuilder().orderId(existStream.getOrderId()).streamId(existStream.getId().toString()).buildDuplicated();  
        }  
          
        //核心逻辑执行  
        consumer.accept(existOrder);  
          
        //开启事务  
        return transactionTemplate.execute(transactionStatus -> {  
              
            boolean result = orderMapper.updateByOrderId(existOrder) == 1;  
            Assert.isTrue(result, () -> new OrderException(OrderErrorCode.UPDATE_ORDER_FAILED));  
              
            TradeOrderStream orderStream = new TradeOrderStream(existOrder, orderRequest.getOrderEvent(), orderRequest.getIdentifier());  
            result = orderStreamMapper.insert(orderStream) == 1;  
            Assert.isTrue(result, () -> new BizException(RepoErrorCode.INSERT_FAILED));  
              
            return new OrderResponse.OrderResponseBuilder().orderId(orderStream.getOrderId()).streamId(String.valueOf(orderStream.getId())).buildSuccess();  
        });  
    });  
}
```

可以看到通过幂等号和orderEvent进行了幂等控制