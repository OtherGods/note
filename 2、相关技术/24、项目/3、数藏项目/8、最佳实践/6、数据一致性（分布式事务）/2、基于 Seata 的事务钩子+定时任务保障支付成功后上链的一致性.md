在我们的项目中，在订单完成支付后，我们会接受到外部支付渠道的支付成功消息。接收到消息之后需要做以下事情：
```java
1、查询订单状态  
2、推进订单状态到支付成功  
3、藏品库存真正扣减  
4、创建持有的藏品  
5、推进支付状态到支付成功  
6、持有的藏品上链
```

为了保证1-5步骤的一致性，我们用了Seata的AT模式来保证他们在同一个事务中，保证可以要么都提交，要么都回滚。

但是第六步，我们并没有放到分布式事务中，原因是什么？不放到事务中，怎么保证一致性呢？

### 为什么不放到事务中？

主要是因为上链的这个动作，我们需要依赖外部第三方的链平台。这里面就需要有网络交互，并且要依赖外部的可用性。

一旦出现网络延迟，中断，或者外部平台的不可用，就可能会导致整个事务回滚，更重要的是，即使我们做了分布式事务，用了AT模式，但是外部平台是无法回滚的，只有我们自己的数据库才能一起回滚，

这就就是说不仅会使得事务异常回滚的概率增大，并且还会带来不一致的问题，所以我们不能把上链的这个操作放到事务中。

当然，我们可以把上链拆成2步骤，第一步先存到chain的数据库中，然后再异步任务轮询调用。也可以，但是这就会存在一定的延迟问题。

所以我们没用这个方案，而是换了一个方案。

### 如何保证一致性？

为了保证这6步能够保持一致，那么我们看下前五步的结果。

其实，对于前五步来说，他们在一个事务中，那么最终的结果是要么commit，要么rollback。

针对前五步的rollback，那么第六步什么都不需要做。

针对前五步的commit，第六步需要确保可以成功。

基于以上的思考，如果我们能在前五步commit之后，触发第六步的执行，并且想办法保证他一定能成功就行了。

如何实现的呢？这里借助了seata的TransactionHook，这是个事务回调，他可以在事务的commit、rollbak等动作执行的时候，回调对应的方法。

那么我们就可以注册一个commit的hook，这样当seata事务提交时，就可以回调我们的afterCommit方法，我们在afterCommit中调用链服务上链。

当然，调链服务，或者上链操作，有可能也会失败，只不过这种失败的概率就比较低了，我们只需要再引入一个定时任务针对失败的重试就可以了。

而且即使afterCommit方法中执行失败了，也不影响事务本身的执行。

这样既能减少异常导致事务回滚的概率，也能降低不一致的概率和时长。这其实就是一种典型的同步转异步的做法。

> 就是说同步先干一把，如果失败了，再异步重试

实现方式就是我们在paySuccess的全局事务中，注册一个回调（TransactionHookManager）。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501051524185.png)

然后定义一个回调处理类，并且实现TransactionHook这个接口，重写他的afterCommit方法：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501051524538.png)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501051524810.png)







