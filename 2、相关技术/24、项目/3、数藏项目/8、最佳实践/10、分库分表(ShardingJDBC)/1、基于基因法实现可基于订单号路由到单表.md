我们的订单采用了分库分表，会基于买家 ID 做分表，同一个买家的订单会路由到同一张分表中。

但是如果我们用订单号查询订单的话，因为没有买家ID 这个分表键，就会不知道具体去哪张分表中查询，就需要做全表扫描，把所有的分表都查询一遍。

这样做效率太差了，于是我们的项目中采用了基因法。

也就是在生成订单号的时候，我们一般会把分表结果编码到订单号中去，因为订单生成的时候是一定可以知道买家ID的，那么我们就把买家ID的路由结果比如1023，作为一段固定的值放到订单号中就行了。这就是所谓的 **"基因法"**
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501051717398.png)

**这样按照订单号查询的时候，解析出这段数字，直接去对应分表查询就好了。**

以下方法，我们的项目中通过generateWithSnowflake获取一个订单号，同时需要传入两个参数，一个是 businessCode，一个是externalId。

这里的externalId就是我们前面提到的需要用来做分表的`买家 ID`

generateWithSnowflake会调用generate方法，generate中调用create方法生成一个DistributeID：
```java
/**  
 * 利用雪花算法生成一个唯一ID  
 */
public static String generateWithSnowflake(BusinessCode businessCode, String externalId) {
    long id = IdUtil.getSnowflake(businessCode.code()).nextId();  
    return generate(businessCode, externalId, id);  
}  
  
/**  
 * 生成一个唯一ID：10（业务码） 1769649671860822016（sequence) 1023(分表）  
 */  
public static String generate(BusinessCode businessCode, String externalId, Long sequenceNumber) {
    DistributeID distributeId = create(businessCode, externalId, sequenceNumber);
    return distributeId.businessCode + distributeId.seq + distributeId.table;
}  
  
public static DistributeID create(BusinessCode businessCode, String externalId, Long sequenceNumber) {
    DistributeID distributeId = new DistributeID();
    distributeId.businessCode = businessCode.getCodeString();
    String table = String.valueOf(shardingTableStrategy.getTable(externalId, businessCode.tableCount()));  
    distributeId.table = StringUtils.leftPad(table, 4, "0");  
    distributeId.seq = String.valueOf(sequenceNumber);  
    return distributeId;  
}
```

而create方法中，会基于传入的externalId进行计算，算出他会被分表到哪张具体的单表中：
```java
String table = String.valueOf(shardingTableStrategy.getTable(externalId, businessCode.tableCount()));  
  
  
public int getTable(String externalId,int tableCount) {  
    int hashCode = externalId.hashCode();  
    return (int) Math.abs((long) hashCode) % tableCount;  
}
```

计算出结果之后，在把他前面补上0，最终让他变成4位字符，如`0001`、`0002`。这样我们的订单号的最后4位就是带有分表结果的这个基因了。

当我们拿订单号查询的时候，直接解析出最后的四位数字就可以直接路由到指定的表中去做 CRUD 了。

具体基于订单号做分片算法的路由，在下面有介绍：
[12、自定义多Key分片算法](2、相关技术/24、项目/3、数藏项目/6、通用设计/12、自定义多Key分片算法.md)

