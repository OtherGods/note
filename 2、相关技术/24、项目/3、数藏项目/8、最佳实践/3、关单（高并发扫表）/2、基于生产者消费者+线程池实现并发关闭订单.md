在我们的项目中，需要通过定时任务来扫描订单表，进行超时未支付的订单的关单操作。

但是因为我们的表是做了分库分表的，并且数据量会很大，单机任务扫表的性能可能不能满足要求，会比较慢，导致任务堆积。

为了解决这个问题，我们采用多线程扫表的方案，这里基于 XXL-JOB 的分片功能，充分利用集群中的所有实例进行任务处理，并且在每个任务的执行过程中，采用生产者消费者模式，在基于线程池进行快速消费。本文介绍生产者消费者+线程池。XXL-JOB 的分片见：
[2、基于XXL-JOB的分片实现分库分表后的扫表](2、相关技术/24、项目/3、数藏项目/8、最佳实践/10、分库分表(ShardingJDBC)/2、基于XXL-JOB的分片实现分库分表后的扫表.md)

### 生产者消费者模式

为了让我们的消费速度更快，我们把从数据库读取数据的动作和消费这些数据的动作拆分开，分别是生产者和消费者。

生产者从数据库中分页取出数据，然后把他们放到一个阻塞队列中，消费者不断从阻塞队列中取出数据进行消费。

阻塞队列：在队列为空时，获取元素的线程会等待队列变为非空。 当队列满时，存储元素的线程会等待队列可用。 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。
```java
try{  
        buyerIdTailNumberList.forEach(buyerIdTailNumber -> {  
int currentPage = 1;  
Page<TradeOrder> page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE, buyerIdTailNumber);  
//生产  
        orderTimeoutBlockingQueue.addAll(page.getRecords());  
        //消费  
        forkJoinPool.execute(this::executeTimeout);  
    });  
            }finally {  
            //添加毒丸  
            orderTimeoutBlockingQueue.add(POISON);  
    LOG.info("POISON added to blocking queue");  
}
```

这里只需要判断从队列中取出来的对象是不是毒丸对象，如果是，则跳出循环，任务结束，如果不是，则执行业务逻辑。

这里的生产其实也并不是只生产一次，而是只要数据库中还有数据就会不断向队列中添加的：
```java
try{  
        buyerIdTailNumberList.forEach(buyerIdTailNumber -> {  
int currentPage = 1;  
Page<TradeOrder> page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE, buyerIdTailNumber);  
        orderTimeoutBlockingQueue.addAll(page.getRecords());  
        forkJoinPool.execute(this::executeTimeout);  
  
        while (page.hasNext()) {  
currentPage++;  
page = orderReadService.pageQueryTimeoutOrders(currentPage, PAGE_SIZE, buyerIdTailNumber);  
            orderTimeoutBlockingQueue.addAll(page.getRecords());  
        }  
        });  
        }finally {  
        orderTimeoutBlockingQueue.add(POISON);  
    LOG.info("POISON added to blocking queue");  
}
```

### 线程池

这里为了提升消费的速度，我们的消费者是通过多线程进行并发消费的，从orderTimeoutBlockingQueue中不断的取出任务进行消费。这里用到了forkJoinPool，因为我们的消费任务之间是互相独立的任务，forkJoinPool有偷窃算法，可以更加高效的处理这类任务。

线程池的定义如下：

```java
private final ForkJoinPool forkJoinPool = new ForkJoinPool(10);
```





