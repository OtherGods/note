在我们的项目中，我们很多地方都会为了避免并发，增加分布式锁，并且会采用一锁、二判、三更新的方式实现一个幂等的逻辑。

同时，为了方便大家使用分布式锁，我们自己定义了一个@DistributeLock的直接。也是就有以下代码：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501011613755.png)

同一个方法中，增加了多个注解，同时有`@DistributeLock`和`@Transactional` 两个注解。

这种情况在，我们自定义的注解`@DistributeLock`的切面默认会在最后执行，于是这段代码就是会先执行事务，然后再执行加锁。

最终的逻辑就像下面这段代码一样：
```java
@Transactional(rollbackFor = Exception.class)  
public boolean register(Request request) {  
      
    RLock lock = redisson.getLock(request.getIdentifier());  
    try {  
        //一锁  
        lock.lock();  
          
        //二查  
        User user = userMapper.find(request.getIdentifier());  
        if (user!=null) {  
            return false;  
        }  
          
        //三更新，保存订单数据  
        userMapper.insertOrder(request);  
          
    } finally {  
        lock.unlock();  
    }  
      
    return true;  
}
```

按照这个顺序执行的：
1. 进入事务
2. 加锁
3. 解锁
4. 事务提交

这时候就会出现一种情况，在第三步和第四步中间，如果有一个其他的线程也调用这个 register 方法了。

那么就会出现一个问题，锁已经释放了，但是事务还没提交。这时候其他的线程在并发请求过来的时候：

**一锁。** 拿锁可以拿到，因为锁被释放了
**二查。** 查询数据也查不到，因为这时候之前的那个事务可能还没提交，未提交的数据，新的事务是看不到的。
**三更新。** 执行更新操作，导致数据重复或者报错。

这就是我们需要解决的问题，那么看上去就是事务的切面执行顺序的问题，我们应该让锁的粒度大于事务的粒度就能解决了这个问题了。

那么，就想办法让分布式锁的注解的切面先执行。解决办法就是借助`@Order` 注解，他可以直接用在切面类上，用于指定切面的执行顺序。值越小，优先级越高，切面会越早执行。

所以，修改后的分布式锁的切面类如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202501011625365.png)

对照：
- [如何控制 Spring Bean 的加载顺序？](2、相关技术/16、常用框架-SpringBoot/补13_SpringBoot%20Bean/如何控制%20Spring%20Bean%20的加载顺序？.md)
- [3.4 多个切面的执行顺序如何控制？](2、相关技术/15、常用框架-SSM+SpringSecurity/补5_Spring常见面试题.md#3.4%20多个切面的执行顺序如何控制？)

新增 `Order` 注解，把他的优先级设置为最小值，即优先级最高，最先开始执行即可。