# 为什么会重复支付？

大家看了支付这部分的代码应该会知道，在生成支付链接的时候，我们是做了幂等控制的，严格的遵守了"一锁、二判、三更新"的。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202412292212313.png)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202412292213341.png)

这样确实可以保证幂等，但是，如果大家仔细看的话，会发现，我们在查询支付单的时候，条件如下：
```java
PayOrder selectByBizNoAndPayer(String payerId, String bizNo, String bizType, String payChannel);
Plain Text
```

付款方、订单号（业务单号+业务类型）、支付渠道，是用这三个关键信息做的唯一性检查。那么也就说，如果用户针对同一笔订单，换了一个支付方式的话，比如之前用微信、现在改用支付宝，那么就可以重新发起一次新的支付了。

虽然我们加的分布式锁是针对bizNo 也就是订单号加的锁，但是分布式锁防的是并发，如果没有并发呢？看一下这个真实场景：

用户下单后，先用微信支付去付款，用微信支付扫码后，因为网络问题，一直转圈圈。用户以为支付失败了。他关闭微信的手机进程，重新回到订单这里，换用支付宝付款。付款成功。

但是，之前那笔微信支付的付款操作，是有可能实际支付成功的。那么一旦他成功了，就意味着同一笔订单，微信、支付宝都支付成功了，这就发生了重复支付的问题。而且这个问题没办法防止，你总不能要求用户微信支付发起后，就不能再发起支付宝支付了吧。万一用户微信钱不够，想换支付宝付款，这再正常不过了。

还有一种多付的场景，那就是用户已经尝试支付的时候，支付单还未失效，然后去微信支付了，但是支付

所以，我们需要通过技术手段来识别并解决这个问题。

### 如何识别多付？

那么，我们如何识别出一笔订单多付了呢？

1. 订单需要有一个明确的状态，记录下来订单已经被支付成功过了。
2. 订单上需要记录是哪笔支付单最终把他推进到支付成功的。具体的就是哪个渠道和那笔具体的支付交易。
3. 支付成功回调接受到时，判断订单状态是否已支付。
	1. 如果订单状态为未支付成功，说明当前是第一次支付成功，则把订单推进到已支付成功，并记录当前的渠道和渠道流水号。
	2. 如果支付单对应的订单已经支付成功了，则判断当前订单上记录的渠道和渠道流水号和本次成功的渠道&流水号是否一致。
		1. 如果一致，说明是消息重投了，直接做幂等处理即可。
		2. 如果不一致，说明之前已经有一个渠道支付成功过了，那当前这笔支付就是多付了。则执行退款操作。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202412292228924.png)

### 如何处理多付？

多付了怎么办？退款呗。原路把钱给用户退回去。比如微信支付，直接调用它的退款的接口就行了。

但是因为这里是和资金相关，并且是和退款有关，比较敏感，并且还要和外部机构交互，所以我们需要记录一些退款相关的信息。所以我们定义了一个退款单的模型，用来记录退款的信息。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202412292235448.png)

具体的代码实现如下：
```java
private void doChargeBack(PaySuccessEvent paySuccessEvent) {  
    //组装退款参数  
    RefundCreateRequest refundCreateRequest = new RefundCreateRequest();  
    refundCreateRequest.setIdentifier(paySuccessEvent.getChannelStreamId());  
    refundCreateRequest.setMemo(REFUND_MEMO_PREFIX + paySuccessEvent.getChannelStreamId());  
    refundCreateRequest.setPayOrderId(paySuccessEvent.getPayOrderId());  
    refundCreateRequest.setRefundAmount(paySuccessEvent.getPaidAmount());  
    refundCreateRequest.setRefundChannel(paySuccessEvent.getPayChannel());  
    //创建退款单  
    RefundOrder refundOrder = refundOrderService.create(refundCreateRequest);  
    Assert.notNull(refundOrder, () -> new BizException(PayErrorCode.REFUND_CREATE_FAILED));  
      
    //异步进行退款执行，失败了交给定时任务重试  
    Thread.ofVirtual().start(() -> {  
        RefundChannelRequest refundChannelRequest = new RefundChannelRequest();  
        refundChannelRequest.setRefundOrderId(refundOrder.getRefundOrderId());  
        refundChannelRequest.setPaidAmount(MoneyUtils.yuanToCent(refundOrder.getPaidAmount()));  
        refundChannelRequest.setPayChannelStreamId(refundOrder.getPayChannelStreamId());  
        refundChannelRequest.setPayOrderId(refundOrder.getPayOrderId());  
        refundChannelRequest.setRefundAmount(MoneyUtils.yuanToCent(refundOrder.getApplyRefundAmount()));  
        refundChannelRequest.setRefundReason(refundOrder.getMemo());  
        //调用支付渠道进行退款  
        RefundChannelResponse refundChannelResponse = payChannelServiceFactory.get(paySuccessEvent.getPayChannel()).refund(refundChannelRequest);  
          
        if (refundChannelResponse.getSuccess()) {  
            //调用成功后，更新退款单状态到 PAYING            refundOrderService.paying(refundOrder.getRefundOrderId());  
        }  
    });  
}
```

并在退款成功后，渠道会有回调通知，接收到通知后，推进退款单和支付单状态：
```java
@Transactional(rollbackFor = Exception.class)  
public boolean refundSuccess(RefundSuccessEvent refundSuccessEvent) {  
    RefundOrder refundOrder = refundOrderService.queryByOrderId(refundSuccessEvent.getRefundOrderId());  
    if (refundOrder.isRefunded()) {  
        return true;  
    }  
      
    boolean refundResult = payOrderService.refundSuccess(refundSuccessEvent)  
            && refundOrderService.refundSuccess(refundSuccessEvent);  
      
    Assert.isTrue(refundResult, () -> new BizException(PayErrorCode.REFUND_SUCCESS_NOTICE_FAILED));  
      
    return true;  
}
```

