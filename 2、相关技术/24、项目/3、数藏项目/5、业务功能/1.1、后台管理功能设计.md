### 藏品管理-创建藏品

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102329024.png)

藏品创建过程中，藏品的创建、快照的创建、以及藏品流水的创建都是同步的，以及调用 chain 模块进行上链操作，这个过程也是同步的。

chain 模块中，同步会存一条上链操作记录，但是调用外部的链平台（文昌链）这个动作是异步的。因为涉及到外部交互，这里没必要做成同步。

然后在 chain 中存储完上链操作记录之后，整个创建的请求就同步返回了，这时候 collection 的状态还是 INIT 的状态，这时候的藏品是无法被售卖的。

直到上链成功之后，会通过 MQ 通知到collection 模块，他会处理这个消息，然后把collection 的状态推进到 SUCCEED，然后再 Redis 中初始化库存。

这时候藏品就可以被售卖了，消息处理过程中，如果失败了，则依赖消息的重投。

同时，在藏品创建的过程，我们不仅存了一条流水，流水用于对账和幂等，同时还创建了一个快照——collection_snapshot

快照的作用其实就是用于记录订单中下单时候藏品的信息，方便后续的纠纷处理以及回溯。

所以每一次藏品的重要信息修改，比如价格、描述、之类的都需要升级一个快照版本，然后再把这个快照记录下来。这样订单表中也记录一下快照版本号，就能回溯到当时下单时候的藏品信息了。

以下是藏品快照表：
```sql
CREATE TABLE IF NOT EXISTS  `collection_snapshot` (
       `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID（自增主键）',
       `gmt_create` datetime NOT NULL COMMENT '创建时间',
       `gmt_modified` datetime NOT NULL COMMENT '最后更新时间',
       `collection_id` bigint NOT NULL COMMENT '藏品id',
       `name` varchar(512) DEFAULT NULL COMMENT '藏品名称',
       `cover` varchar(512) DEFAULT NULL COMMENT '藏品封面',
       `class_id` varchar(128) DEFAULT NULL COMMENT '藏品类目ID',
       `price` decimal(18,6) DEFAULT NULL COMMENT '价格',
       `quantity` bigint DEFAULT NULL COMMENT '藏品数量',
       `detail` text COMMENT '详情',
       `saleable_inventory` bigint DEFAULT NULL COMMENT '可销售库存',
       `create_time` datetime DEFAULT NULL COMMENT '藏品创建时间',
       `sale_time` datetime DEFAULT NULL COMMENT '藏品发售时间',
       `sync_chain_time` datetime DEFAULT NULL COMMENT '藏品上链时间',
       `deleted` int DEFAULT NULL COMMENT '是否逻辑删除，0为未删除，非0为已删除',
       `lock_version` int DEFAULT NULL COMMENT '乐观锁版本号',
       `creator_id` varchar(128) DEFAULT NULL COMMENT '创建者',
       `version` int DEFAULT NULL COMMENT '修改版本',
       PRIMARY KEY (`id`)
) ;
```

其中就是记录了藏品中的关键信息，以及当前的版本。

### 藏品管理——修改库存

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102339970.png)

后台小二在修改库存的时候，需要同时修改 Redis 和数据库中的库存。这里比较简单，看代码很容易理解。

但是这里有个问题：为啥这部分修改不做分布式事务，失败了怎么办？不一致如何处理。

这里确实没做，原因是因为这只是一个小二的后台操作入口，并不高频，而且即使操作失败了，小二也是有感知的。他可以重新点一次进行重试，所以我们只需要做好幂等就可以了。不需要搞得那么复杂，还要搞什么分布式事务。。。

库存修改的时候不需要更新快照，但是需要更新一张库存流水表，用于进行库存的核对和校验。

### 藏品管理——修改价格

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102342251.png)

价格是藏品中非常重要的信息，所以价格的修改需要去更新快照。所以他需要额外的更新一下藏品的快照。

### 藏品管理——下架藏品

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102343957.png)

~~藏品的下架这里唯一需要注意的是就是库存的处理。Redis 中的库存随着藏品下架就不再需要了，我们就可以把它们清理了。~~

~~但是对于库存和库存流水，我们的处理方式不一样，针对库存，我们直接删除就行了，针对库存流水，我们为了兼容对账的延迟性，我们把他保留24小时，设置24小时后超时，就让他自生自灭即可。~~

### 状态机

藏品状态机
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102344961.png)

-   
    INIT
- 藏品创建成功之后，状态位 INIT
- SUCCEED
- 藏品上链成功后，状态为 SUCCEED
- REMOVED
- 藏品被销毁后，状态为 REMOVED

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102345771.png)

### 接口设计

1.获取藏品列表

路径：/admin/collection/collectionList

方法：GET

请求参数：

```json
{
    "state": "SUCCEED",
    "pageSize": 10,
    "currentPage": 1
}
```

响应：
```json
{
  "status": true,
  "data": {
    "current": 1,
    "count": 100,
    "size": 10,
    "record": [
      {
        "id": "",
        "name": "",
        "cover": "",
        "classId": ""
      }
    ]
  }
}
```

2.上传藏品封面

路径：/admin/collection/uploadCollection

方法：POST

请求参数：
```json
{
    "file_data": MultipartFile
}
```

响应：
```json
{
  "code": 200,
  "success": true,
  "message": "SUCCESS",
  "data": string
}
```

3.创建藏品

路径：/admin/collection/createCollection

方法：POST

请求参数：
```json
{
    "name": "string",
    "cover": "string",
    "detail": "string",
    "price": number,
    "quantity": long,
    "saleTime": "string"
}
```

响应：

```json
{
  "code": 200,
  "success": true,
  "message": "SUCCESS",
  "data": long
}
```

4.下架藏品

路径：/admin/collection/removeCollection

方法：POST

请求参数：
```json
{
    "collectionId": long
}
```

响应：
```json
{
  "code": 200,
  "success": true,
  "message": "SUCCESS",
  "data": long
}
```

5.修改藏品库存

路径：/admin/collection/modifyInventory

方法：POST

请求参数：
```json
{
    "collectionId": long,
    "quantity": long
}
```

响应：
```json
{
  "code": 200,
  "success": true,
  "message": "SUCCESS",
  "data": long
}
```

6.修改藏品价格

路径：/admin/collection/modifyPrice【

方法：POST

请求参数：
```json
{
    "collectionId": long,
    "price": number
}
```

响应：
```json
{
  "code": 200,
  "success": true,
  "message": "SUCCESS",
  "data": long
}
```


