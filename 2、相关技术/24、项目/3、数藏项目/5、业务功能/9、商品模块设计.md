我们的项目中，已经有一个 collection、box 等模块了，他们都是具体的商品了，但是我们还是单独定义了一个 goods 模块，为啥要单独弄一个商品模块呢？
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506251111829.png)

这部分代码我们做了重构，最开始只有 collection 模块，后来新增了 goods 模块，但是在做了盲盒功能之后，我又把他们三个模块之间的关系给改了。改成现在的 goods 模块中包含 collection 和 box 两个子模块的方式 。

### 为啥要有商品模块？

其实主要是为了抽象出一个商品域，把底层的具体商品类型屏蔽掉，因为我们现在有collection（藏品）、box（盲盒）等，以及我们项目中不准备做但是其实很多数藏有的——持有藏品（held_collection）的转让等等。

所以，我们定义了一个goods模块，用于和 trade、order 模块直接交互，屏蔽掉底层的差异。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506251111564.png)

goods 这一层不要做存储，最多是和缓存交互一下而已，所以，通常都把它叫做防腐层。

### 为啥又把三个模块合到一起了？

最开始，我是有 collection 和 goods 两个平行模块的，在加了 box之后，就是三个模块平行。

这么做也没啥大毛病，goods 确实起到了防腐层的作用，但是，带来了一个新的问题，那就是多多了一次网络开销。

如果没有 goods，trade 模块直接和 collection、box交互就行了，现在有了 goods，就需要先和 goods 交互，然后 goods 再和collection、box交互，这中间就多了一次网络开销了。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506251112769.png)

在我的项目中，我们主要是做高并发，这种多余的网络开销了肯定是不想看到的。于是我就想了个办法，模块还是三个模块，但是把它们部署在一起。

最上面有一个 goods 模块，然后他包含两个子模块collection 和 box就行了。 但是后来发现一些屏蔽差异的代码没地方洗了，于是我又加了一个 interface 模块，这个模块主要是做接口，和上游做网络交互屏蔽差异的，具体的实现逻辑，都在 box 和 collection 两个模块里面。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506251112186.png)

这样，既可以各个模块之间互相不影响，又可以做到上游系统只需要和 goods 做交互，还能做到不需要额外的网络交互。又快又好！

### goods模块的实现

在藏品模块中，我们定义了通用的 VO 类，以及部分抽象方法，如：
```java
public abstract class BaseGoodsVO implements Serializable {
    /**
     * 商品名称
     *
     * @return
     */
    public abstract String getGoodsName();
﻿
    /**
     * 商品图片
     *
     * @return
     */
    public abstract String getGoodsPicUrl();
﻿
    /**
     * 卖家id
     *
     * @return
     */
    public abstract String getSellerId();
﻿
    /**
     * 版本
     *
     * @return
     */
    public abstract Integer getVersion();
﻿
    /**
     * 是否可用
     *
     * @return
     */
    public abstract Boolean available();
﻿
    /**
     * 价格
     *
     * @return
     */
    public abstract BigDecimal getPrice();
}
```

这样，具体的商品，如 CollectionVO，只需要继承这个类，实现其中的方法就行了，如：
```java
public class CollectionVO extends BaseGoodsVO {
﻿
    private static final long serialVersionUID = 1L;
﻿
    /**
     * 主键ID
     */
    private Long id;
    /**
     * '藏品名称'
     */
    private String name;
﻿
    /**
     * '藏品封面'
     */
    private String cover;
﻿
    /**
     * '藏品类目id'
     */
    private String classId;
﻿
    /**
     * '价格'
     */
    private BigDecimal price;
﻿
    /**
     * '藏品数量'
     */
    private Long quantity;
﻿
    /**
     * '库存'
     */
    private Long inventory;
﻿
    /**
     * '状态'
     */
    private CollectionVoState state;
﻿
    /**
     * '藏品创建时间'
     */
    private Date createTime;
﻿
    /**
     * '藏品发售时间'
     */
    private Date saleTime;
﻿
    /**
     * '藏品上链时间'
     */
    private Date syncChainTime;
﻿
    /**
     * 版本
     */
    private Integer version;
﻿
    public static final int DEFAULT_MIN_SALE_TIME = 60;
﻿
    public void setState(CollectionStateEnum state, Date saleTime, Long saleableInventory) {
        if (state.equals(CollectionStateEnum.INIT) || state.equals(CollectionStateEnum.REMOVED)) {
            this.setState(CollectionVoState.NOT_FOR_SALE);
        }
﻿
        Instant now = Instant.now();
﻿
        if (now.compareTo(saleTime.toInstant()) >= 0) {
            if (saleableInventory > 0) {
                this.setState(CollectionVoState.SELLING);
            } else {
                this.setState(CollectionVoState.SOLD_OUT);
            }
        } else {
            if (ChronoUnit.MINUTES.between(now, saleTime.toInstant()) > DEFAULT_MIN_SALE_TIME) {
                this.setState(CollectionVoState.WAIT_FOR_SALE);
            }
            this.setState(CollectionVoState.COMING_SOON);
        }
    }
﻿
    @Override
    public String getGoodsName() {
        return this.name;
    }
﻿
    @Override
    public String getGoodsPicUrl() {
        return this.cover;
    }
﻿
    @Override
    public String getSellerId() {
        //藏品持有人默认是平台,平台ID用O表示
        return "0";
    }
﻿
    @Override
    public Integer getVersion() {
        return version;
    }
﻿
    @Override
    public Boolean available() {
        return this.state == CollectionVoState.SELLING;
    }
﻿
    @Override
    public BigDecimal getPrice() {
        return this.price;
    }
}
Plain Text
```

然后我们在 GoodsFacadeService 中进行各类商品操作的聚合，如：
```java
@Override
public BaseGoodsVO getGoods(String goodsId, GoodsType goodsType) {
	return switch (goodsType) {
		case COLLECTION -> {
			SingleResponse<CollectionVO> response = collectionReadFacadeService.queryById(Long.valueOf(goodsId));
			if (response.getSuccess()) {
				yield response.getData();
			}
			yield null;
		}

		case BLIND_BOX -> {
			SingleResponse<BlindBoxVO> response = blindBoxReadFacadeService.queryById(Long.valueOf(goodsId));
			if (response.getSuccess()) {
				yield response.getData();
			}
			yield null;
		}
		default -> throw new UnsupportedOperationException("unsupport goods type");
	};
}
```
