用户管理功能时序图：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411102352464.png)

用户状态机
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411112127744.png)

### 延迟双删

这里用户的信息更新，为了保证缓存和 redis 的一致性，选择了**延迟双删**的方案。

因为对于冻结、解冻接口来说，虽然并发量不高，但是对于不一致的接受度比较低，我们希望能快速的更新缓存，避免不一致。所以引入了延迟双删。

为了减少缓存的不一致，我们其实只需要把删除挪到更新数据库之前就行了，这样就能确保更新数据库的时候，缓存一定已经删除了，那么就可以避免脏数据。

但是，这样会带来一个问题，那就是在删除缓存之后，更新数据库之前，另外一个线程如果从数据库中读取了旧值又更新到了缓存中，那么就会导致缓存又变成旧值了。还是会出现不一致的情况了。

所以，解决的方案就是延迟双删，也就是在删除缓存、更新数据库之后，在删除一次缓存。
```java
public UserOperatorResponse freeze(Long userId) {  
    UserOperatorResponse userOperatorResponse = new UserOperatorResponse();  
    User user = userMapper.findById(userId);  
    Assert.notNull(user, () -> new UserException(USER_NOT_EXIST));  
    Assert.isTrue(user.getState() == UserStateEnum.ACTIVE, () -> new UserException(USER_STATUS_IS_NOT_ACTIVE));  
      
    //第一次删除缓存  
    telUserCache.remove(user.getTelephone());  
    idUserCache.remove(user.getId().toString());  
      
    if (user.getState() == UserStateEnum.FROZEN) {  
        userOperatorResponse.setSuccess(true);  
        return userOperatorResponse;  
    }  
    //更新数据库  
    user.setState(UserStateEnum.FROZEN);  
    boolean updateResult = updateById(user);  
    Assert.isTrue(updateResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));  
    //加入流水  
    long result = userOperateStreamService.insertStream(userId, UserOperateTypeEnum.FREEZE);  
    Assert.notNull(result, () -> new BizException(RepoErrorCode.UPDATE_FAILED));  
      
    //第二次删除缓存  
    userCacheDelayDeleteService.delayedCacheDelete(telUserCache, idUserCache, user);  
      
    userOperatorResponse.setSuccess(true);  
    return userOperatorResponse;  
}
```

我们在更新数据库之前先删除了一次缓存。在更新数据库之后借助userCacheDelayDeleteService进行了一次延迟双删。

delayedCacheDelete其实就是一个延迟任务，延迟2秒钟再清空一次缓存，避免出现不一致的情况。
```java
@Scheduled(fixedDelay = 2, timeUnit = TimeUnit.SECONDS)  
public void delayedCacheDelete(Cache telUserCache, Cache idUserCache, User user) {  
    boolean telDeleteResult = telUserCache.remove(user.getTelephone());  
    log.info("telUserCache removed, key = {} , result  = {}", user.getTelephone(), telDeleteResult);  
    boolean idDeleteResult = idUserCache.remove(user.getId().toString());  
    log.info("idUserCache removed, key = {} , result  = {}", user.getId(), idDeleteResult);  
}
```

延迟的时间我们设定的是 2s 钟，这个值怎么来的呢，其实是业务上能接受的数据不一致的时长来确定的，我们认为冻结/解冻的场景，我们最多接受2秒钟的延迟，所以就设置2秒的延时。

### Session 更新

在完成用户的冻结解冻之后，我们还需要做一个额外的操作，那就是更新保存在 Session 中的用户信息，这个信息主要用在网关中鉴权使用。

如果没有更新这个 Session 中保存的用户信息，那么就会使得网关中的用户状态没更新，导致鉴权出现异常，即一个用户已经被冻结了，但是还能下单。

所以，我们通过以下方法实现更新 session：
```java
private void refreshUserInSession(Long userId) {  
    UserQueryRequest userQueryRequest = new UserQueryRequest(userId);  
    UserQueryResponse userQueryResponse = userFacadeService.query(userQueryRequest);  
    StpUtil.getSession().set(userId.toString(), userQueryResponse.getData());  
}
```










