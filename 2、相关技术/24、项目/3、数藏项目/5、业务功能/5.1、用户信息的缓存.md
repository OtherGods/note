用户信息是一个非常基本的信息，很多地方都需要查询用户信息，但是用户信息其实变化并不频繁，所以为了提升性能， 我们针对用户信息做了缓存。

### 缓存的写入-查询时

我们会在用户信息第一次被查询的时候进行缓存，一种是基于用户id当做key作缓存，一种是基于用户的手机号的当做key作缓存。主要的实现代码如下：
```java
/**
 * 通过手机号查询用户信息
 *
 * @param telephone
 * @return
 */
@Cached(name = ":user:cache:tel:", expire = 3000, cacheType = CacheType.BOTH, key = "#telephone", cacheNullValue = true)
@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)
public User findByTelephone(String telephone) {
    return userMapper.findByTelephone(telephone);
}

/**
 * 通过用户ID查询用户信息
 *
 * @param userId
 * @return
 */
@Cached(name = ":user:cache:id:", expire = 3000, cacheType = CacheType.BOTH, key = "#userId", cacheNullValue = true)
@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)
public User findById(Long userId) {
    return userMapper.findById(userId);
}
```

这里面都用到了一个注解：`@Cached`

这是二级缓存框架jetcache给我们提供的，当方法上增加这个注解的时候，他会通过AOP方式拦截这个方法，然后在方法执行完之后，把结果保存到缓存中。

`@Cached(name = ":user:cache:tel:", expire = 3000, cacheType = CacheType.BOTH, key = "#telephone", cacheNullValue = true)`
- name：表示缓存的key的前缀
- expire：表示缓存失效的时长，默认单位为秒
- cacheType：缓存的类型，支持REMOTE（分布式缓存）、LOCAL（本地缓存）和BOTH（同时开启二级缓存）
- key：表示缓存的key，这里面用的是EL表达式，直接从入参解析出telephone字段的值。
- cacheNullValue：表示是否缓存空值，为了避免缓存穿透

举个例子，findByTelephone这个方法被调用自之后，如果入参是18000000000，那么最终会有一个key为`nfturbo-business:user:cache:tel:1800000000` ,value为User的对象的序列化后的字节流的一个k-v。

### 缓存的写入-注册时

除了上面的查询用户信息的时候会写入用户信息到缓存中，还有一个场景，那就是用户注册的时候也需要去写入缓存。

而且，用户注册的时候，和上面不一样，他需要同时把手机号和用户id作为key的缓存都写进去（最好是这样，只写一个倒也不是不行），所以我们这里就没有用注解的方式，而是自己定义了两个cache来操作的。
```java
private Cache<String, User> telUserCache; 
private Cache<String, User> idUserCache;
```

这两个cache的key和我们前面的注解的key的定义方式是一样的，都`{app_name}:user:cache:tel:手机号` 和`{app_name}:user:cache:id:用户id`

所以他们其实操作的是同一个缓存。缓存的初始化过程如下：
```java
@PostConstruct
public void init() {
    QuickConfig telQc = QuickConfig.newBuilder(":user:cache:tel:")
            .cacheType(CacheType.BOTH)
            .expire(Duration.ofMinutes(3000))
            .syncLocal(true)
            .build();
    telUserCache = cacheManager.getOrCreateCache(telQc);

    QuickConfig idQc = QuickConfig.newBuilder(":user:cache:id:")
            .cacheType(CacheType.BOTH)
            .expire(Duration.ofMinutes(3000))
            .syncLocal(true)
            .build();
    idUserCache = cacheManager.getOrCreateCache(idQc);
}
```

具体的调用，在register方法中如下：
```java
@DistributeLock(keyExpression = "#telephone", scene = "USER_REGISTER")
public UserOperatorResponse register(String telephone) {
    //前缀 + 6位随机数 + 手机号后四位
    String defaultNickName;
    do {
        defaultNickName = DEFAULT_NICK_NAME_PREFIX + RandomUtil.randomString(6) + telephone.substring(7, 11);
    } while (nickNameExist(defaultNickName));

    User user = register(telephone, defaultNickName, telephone);
    Assert.notNull(user, UserErrorCode.USER_OPERATE_FAILED.getCode());
    telUserCache.put(telephone, user);
    idUserCache.put(user.getId().toString(), user);

    //加入流水
    long streamResult = userOperateStreamService.insertStream(user.getId(), UserOperateTypeEnum.REGISTER);
    Assert.notNull(streamResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));

    UserOperatorResponse userOperatorResponse = new UserOperatorResponse();
    userOperatorResponse.setSuccess(true);

    return userOperatorResponse;
}
```

在11-12行进行的调用，把用户信息保存到缓存中的。

### 缓存的更新

缓存写入之后，肯定还需要更新的，我们是如何更新的呢？我们其实给缓存做了个自动更新的策略，同样是在findByTelephone和findById方法上，我们用了一个:

```java
@CacheRefresh(refresh = 60, timeUnit = TimeUnit.MINUTES)
```

这个注解表示需要60分钟自动进行一次缓存的刷新，会有后台线程自动调用加了注解的方法进行缓存更新的。

### 缓存的失效

除了更新，我们还会针对缓存做失效操作，因为用户的缓存是同时基于手机号和用户id的，所以需要把两个都失效掉，所以通过注解就没办法实现了，因为我们的很多方法，在更新用户信息的时候，入参都是不带手机号的。所以需要手动写代码实现。

如active方法中的实现：
```java
public UserOperatorResponse active(UserActiveRequest userActiveRequest) {
    UserOperatorResponse userOperatorResponse = new UserOperatorResponse();
    User user = userMapper.findById(userActiveRequest.getUserId());
    Assert.notNull(user, () -> new UserException(USER_NOT_EXIST));
    Assert.isTrue(user.getState() == UserStateEnum.AUTH, () -> new UserException(USER_STATUS_IS_NOT_AUTH));
    user.active(userActiveRequest.getBlockChainUrl(), userActiveRequest.getBlockChainPlatform());
    boolean result = updateById(user);
    if (result) {
        //加入流水
        long streamResult = userOperateStreamService.insertStream(user.getId(), UserOperateTypeEnum.ACTIVE);
        Assert.notNull(streamResult, () -> new BizException(RepoErrorCode.UPDATE_FAILED));
        telUserCache.remove(user.getTelephone());
        idUserCache.remove(user.getId().toString());
        userOperatorResponse.setSuccess(true);
    } else {
        userOperatorResponse.setSuccess(false);
        userOperatorResponse.setResponseCode(UserErrorCode.USER_OPERATE_FAILED.getCode());
        userOperatorResponse.setResponseCode(UserErrorCode.USER_OPERATE_FAILED.getMessage());
    }
    return userOperatorResponse;
}
```

具体的缓存的删除有多个方案，可以参考：
[13、缓存与数据库的一致性方案](2、相关技术/24、项目/3、数藏项目/7、关键技术/13、缓存与数据库的一致性方案.md)


