支付模块，承担了我们的项目中的和支付相关的功能，是我们项目中非常重要的模块。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411172323818.png)

## 模型设计

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411172324395.png)

为了让支付更加具有通用性，我们在支付单这张表中没有任何和订单有关的信息，我们的付款方没有叫buyer_id，存订单号也没有用 order_id。而是定义了支付单领域自己的属性，如付款方、收款方、业务单号等等。目的就是更具有通用性，模型更加内聚。

同时，为了支持多付退款，我们还有一张退款单的表。

## 状态机

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411172330867.png)

## 业务流程

### 下单支付

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411172331678.png)

关于支付成功后的具体操作，详见：
[1、基于Seata分布式事务实现支付环节的数据一致性](2、相关技术/24、项目/3、数藏项目/8、最佳实践/6、数据一致性（分布式事务）/1、基于Seata分布式事务实现支付环节的数据一致性.md)

### 多付退款

在支付环节，是有一种特殊情况，那就是多付的情况，就是一笔订单，重复支付了。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202412292205759.png)

在支付成功的处理中，我们会检查订单的状态，如果支付单对应的订单未支付成功，说明当前是第一次支付成功，则执行上面的支付成功逻辑即可。

如果支付单对应的订单已经支付成功了，那么就有2种可能：
1. 同一个支付成功回调，支付渠道消息重投了。
2. 不同的支付成功回调，用户多付了。

如果是第一种情况，那么直接幂等掉，返回成功即可，如果是第二种情况，那么则需要进行退款了。

具体的关于为什么会重复支付、如何解决，详见：
[16.1、重复支付问题如何解决？](2、相关技术/24、项目/3、数藏项目/5、业务功能/16.1、重复支付问题如何解决？.md)

