模板方法模式是一种在软件工程中用来定义程序框架的设计模式，它通过把不变的行为搬移到超类，去除子类中的重复代码来体现软件工程的"不要重复你自己"（DRY）的原则。

模板方法模式通常涉及一个抽象类，该抽象类声明了一系列的步骤用以执行一个算法。具体子类可以重写算法实现的某些步骤而不改变算法的结构，即"模板"的框架。重点在于，模板（即算法的框架）已经在父类中定义好，子类的实现只需关注那些可变或必须被自定义的步骤。

### 示例

```java
protected ChainProcessResponse doPostExecute(ChainProcessRequest chainProcessRequest, Consumer<ChainRequest> consumer) {  
    return handle(chainProcessRequest, request -> {  
          
        Boolean rateLimitResult = slidingWindowRateLimiter.tryAcquire(  
                "limit#" + chainProcessRequest.getBizType() + chainProcessRequest.getIdentifier(), 1, 60);  
        if (!rateLimitResult) {  
            return new ChainProcessResponse.Builder().responseCode(ChainCodeEnum.PROCESSING.name()).data(  
                    new ChainOperationData(chainProcessRequest.getIdentifier())).buildSuccess();  
        }  
        ChainOperateInfo chainOperateInfo = chainOperateInfoService.queryByOutBizId(  
                chainProcessRequest.getIdentifier());  
        if (null != chainOperateInfo) {  
            if (StringUtils.equals(chainProcessRequest.getBizType(), ChainOperateBizTypeEnum.USER_CREATE.name())) {  
                JSONObject jsonObject = JSON.parseObject(chainOperateInfo.getResult(), JSONObject.class);  
                String blockChainAddr = (String) jsonObject.get("native_address");  
                String blockChainName = chainProcessRequest.getUserId();  
                return new ChainProcessResponse.Builder().responseCode(ChainCodeEnum.SUCCESS.name()).data(  
                        new ChainCreateData(chainProcessRequest.getIdentifier(), blockChainAddr, blockChainName,  
                                chainType)).buildSuccess();  
            } else {  
                return new ChainProcessResponse.Builder().responseCode(ChainCodeEnum.PROCESSING.name()).data(  
                        new ChainOperationData(chainProcessRequest.getIdentifier())).buildSuccess();  
            }  
        }  
          
        ChainRequest chainRequest = new ChainRequest();  
          
        var operateInfoId = chainOperateInfoService.insertInfo(chainType,  
                chainProcessRequest.getBizId(), chainProcessRequest.getBizType(),  
                JSON.toJSONString(chainProcessRequest), chainProcessRequest.getIdentifier());  
        //核心逻辑执行  
        consumer.accept(chainRequest);  
          
        ChainResponse result = doPost(chainRequest, operateInfoId);  
          
        return buildResult(result, chainProcessRequest);  
    });  
}
```

在doPostExecute方法中，通过提供一个固定的操作流程（模板），在其中插入特定的自定义行为。

该方法执行以下固定的操作流程：
1. 流量控制: 首先，尝试通过slidingWindowRateLimiter获取执行权限。如果获取失败（表示达到流量上限），则返回一个标记为“处理中”的响应。
2. 查询操作信息: 查询与请求标识符相关的操作信息。如果找到了对应的操作结果，并且业务类型是用户创建，则解析结果并返回。否则，也返回一个标记为“处理中”的响应。
3. **构建ChainRequest并执行：如果没有找到对应的操作结果，就构建一个新的ChainRequest对象，并执行特定的业务逻辑。这个业务逻辑通过`Consumer<ChainRequest> consumer`参数传入，它代表了外部定义的、可自定义的具体执行步骤。**
4. **处理结果：最后，通过doPost方法处理chainRequest，并通过buildResult方法构建最终的响应对象。**

这个方法的“模板”在于：它定义了处理链式请求的基本步骤，这些步骤构成了处理请求的固定框架。而**通过`Consumer<ChainRequest> consumer`参数，调用者可以插入自定义的处理逻辑**，在这个固定框架中执行特定的操作。这种结构允许调用者在不改变基本处理流程的前提下，处理各种链式请求的不同需求，体现了模板方法模式的“个性化定制步骤”的精神。

这种设计确实利用了模板方法模式的核心理念：定义算法的框架，并允许子类或用户代码在不改变框架的情况下添加或修改某些步骤的实现。**在这个示例中，通过委托（`Consumer<ChainRequest>`）实现了这种灵活性。**





















