
**说明**
不知道有没有小伙伴注意到，一般的项目中，配置相关信息都是放在application.yml配置文件中的，但是技术派不一样，它除了这个配置文件之外，还有好几个其他的配置文件如 application-dal.yml、application-image.yml， application-web.yml

# 1、spring.profiles.active配置

这里主要是利用配置spring.profiles.active，表示那些配置可以被激活

```yml
// 来自项目
spring:  
  #  Spring Boot 2.4为了提升对Kubernetes的支持 将 spring.profiles 作废了 
  #  profiles:  
  #    active: dal,web,config,image  # 替换上面作废的spring.profiels.actice配置参数  
  config:  
    import: application-dal.yml,application-web.yml,application-config.yml,application-image.yml,application-email.yml,application-rabbitmq.yml,application-ai.yml
```

我们首先来看一下spring.profiles.active的使用姿势

## 1.1、命令规则
配置文件，一般要求是以 application 开头，可以是yml文件也可以是properties文件

## 1.2、配置选择
当有多个配置文件，指向选择其中某一个时（如用于选择不同环境的对应的配置文件时 ：application-dev.yml 与 application-prod.yml，哪一个生效？）
通过配置信息 spring.profile.active 来指定需要加载的配置文件：
```yml
spring:
  profiles:
    active: dev
```

上面这个表示，当前的配置信息，会从 application.yml 和 application-dev.yml 文件中获取；且-dev文件中定义的配置信息，会覆盖前面的配置信息。

注意：
1. 上面这个配置的value，可以指定多个配置文件，用英文逗号分隔
2. 其中最右的优先级最高，覆盖左边配置文件中重名的配置信息

## 1.3、demo验证
主要是为了验证下优先级的情况，我们整一个简单的demo来验证一下
配置文件内容如下

application.yml
```yml
# 端口号
server:
	port: 8081

spring:
	profiles:
		active: dev,biz

biz:
	total: application
```

application-dev.yml
```yml
biz:
	env: dev-environment
	profile: dev-profile
```

application-pro.yml
```yml
biz:
	env: pro-environment
	profile: pro-profile
```

application-biz.yml
```yml
biz:
	whitelist: a,b,c,d,e,f,g
	ratelimit: 1,2,3
	total: application-biz
	profile: biz-profile
```

通过前面的规则进行分析，当前选中生效的配置文件为
1. application.yml, application-dev.yml, application-biz.yml
2. 优先级为：biz文件的配置覆盖dev文件，dev文件的覆盖application的配置

代码验证如下：
```java
@SpringBootApplication
public class Application {
	public Application(Environment environment) {
		String env = environment.getProperty("biz.env");
		
		String whitelist = environment.getProperty("biz.whitelist");
        String ratelimit = environment.getProperty("biz.ratelimit");
        String total = environment.getProperty("biz.total");
        String profile = environment.getProperty("biz.profile");
        
        // application.yml文件中的配置 spring.profile.active指定具体选中的配置文件，为 application-dev 和 application-biz
        // read from application-dev.yml
        System.out.println("env: " + env);
        
        // read from application-biz.yml
        System.out.println("whitelist: " + whitelist);
        System.out.println("ratelimit: " + ratelimit);
        
        // 当配置文件 application.yml, application-dev.yml, application-biz.yml 三个文件都存在时，覆盖规则为
        // biz > dev > application.yml  （其中 biz>dev的原则是根据 spring.profile.active 中定义的顺序来的，最右边的优先级最高）
        // read from application-biz.yml
        System.out.println("total: " + total);
        
        // read from application-biz.yml
        System.out.println("profile: " + profile);
    }
    public static void main(String[] args) {
        SpringApplication.run(Application.class);
    }
}
```

输出结果为：
```txt
env: dev-environment
whitelist: a,b,c,d,e,f,g
ratelimit: 1,2,3
total: application-biz
profile: biz-profile
```


# 2、spring.config.import配置方式
请注意上面的截图，这个配置文件已经被标记删除了，主要原因在于spring boot 2.4之后为了提升对kubernetes的支持，整个spring.profiles作废了；
因此我们可以通过spring.config.import来替代它

```yml
spring
  config:  
    import: application-dal.yml,application-web.yml,application-config.yml,application-image.yml,application-email.yml,application-rabbitmq.yml,application-ai.yml
```

# 3、使用active作环境区分场景

使用前面介绍的两个配置，除了用于加载多个配置文件之外，还有一个功能，就是利用它来做环境区分，以 spring.profile.active 为例，每个不同环境的配置信息都放在一个配置文件中，通过这个配置来选择具体执行的环境

如当前有三个配置文件：
1. application.yml
2. application-dev.yml
3. application-prod.yml
<font color = "red">此时jar在运行时，通过 spring.profile.active 来选择具体应该加载dev还是prod的配置文件；</font>

这种方式虽然简单，但是有一个问题，这个配置值，直接写在application.yml中，大家共用一份，总不能在部署dev的时候将这个参数值改成dev，在不是prod时，再改成prod吧。。。
如果是这样的话，也太容易出问题了吧。。。
那么如何解决这个问题呢，常见的一种方式是通过启动脚本，传入当前环境的参数，来覆盖选中的环境。

那么如何解决这个问题呢，常见的一种方式是通过启动脚本，传入当前环境的参数，来覆盖选中的环境.

## 3.1、配置文件优先级
官网：[外部的 Application Properties](https://springdoc.cn/spring-boot/features.html#features.external-config.files)
默认的配置文件是放在 src/main/resources 目录下，当然也是可以放其他位置的：（优先级从上到下降低）
1.第一类： 外置，在相对于应用程序运行目录的 `/config` 子目录中；
2. 第二类：外置，在应用程序运行的目录的 `/` 中；
3. 第三类：内置，放在config包下(即 `src/main/resources/config` )目录下；
4. 第四类：内置，放在classpath根目录下（即默认的 `src/main/resources/` 目录下)。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307201934041.png)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307202310727.png)

当执行mvn package命令打成jar包后，jar包中没有第一类、第二类配置文件（也就是./config/application.yml和./application.yml），有两种方式解决这个问题：
1. 可以在pom.xml文件中添加以下内容：
   ```xml
<build>  
	<resources>  
	    <!-- 第一/二类配置文件 -->  
	    <resource>  
	        <directory>./</directory>  
	        <includes>
				<include>**/*.yml</include>  
	        </includes>    
		</resource>    
		
		<!-- 第三/四类配置文件 -->  
	    <resource>  
			<directory>src/main/resources</directory>  
	        <includes>
		        <include>**/*.yml</include>  
	            <include>**/*.html</include>  
	            <include>**/*.xml</include>  
	            <!-- ………… -->  
	        </includes>  
	    </resource>
    </resources>
</buile>
   ```
   执行mvn clean package后，jar包中就包含这两个配置文件了。
   添加resources标签和不添加resources标签打包后的结构对比：
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307210055844.png)
2. 将第一/二类配置文件放在jar文件的同级目录下，执行java -jar xxx.jar时自动扫描第一/二类配置文件
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307210208842.png)



## 3.2、配置信息来源
官网：[2. 外部化的配置](https://springdoc.cn/spring-boot/features.html#features.external-config)
一个springboot应用，除了从上面的配置文件获取配置之外，还有下面的配置获取方式，根据优先级对属性来源进行排序，如下：（从上到下优先级依次降低）
1. 根目录下的开发工具全局设置属性(当开发工具激活时为~/.spring-boot-devtools.properties)。
2. 测试中的@TestPropertySource注解。
3. 测试中的@TestPropertySource注解。
4. 命令行参数
5. SPRING_APPLICATION_JSON中的属性(环境变量或系统属性中的内联JSON嵌入)。
6. ServletConfig初始化参数。
7. ServletContext初始化参数。
8. java:comp/env里的JNDI属性
9. JVM系统属性
10. 操作系统环境变量
11. 随机生成的带random.* 前缀的属性（在设置其他属性时，可以应用他们，比如${random.long}）
12. 应用程序以外的application.properties或者appliaction.yml文件
13. 打包在应用程序内的application.properties或者appliaction.yml文件
14. 通过@PropertySource标注的属性源
15. 默认属性(通过SpringApplication.setDefaultProperties指定).


## 3.3、环境选择的几种方式

看了上面的配置信息来源，我们可以如何优雅的实现不同环境选择不同的配置文件呢？有下面两个容易想到和实现的方式了
1. 命令行参数
2. 应用程序外的配置文件

### 3.3.1、命令行参数方式

这种实现思路就是在启动脚本中，传入当前环境，然后覆盖掉属性 --spring.profiles.active，对业务来说，就不需要做任何的改动了，只要启动脚本本身区分环境即可，唯一的要求就是遵循统一的规范，一个简单的实现如下：
假定命令行的第一个参数就是环境，去除这个参数，传入即可
```java
public static void main(String[] args) {
	if (args.length > 0) {
		SpringApplication.run(Application.class, "--spring.profiles.active=" + args[0] + ",biz");
	} else {
		SpringApplication.run(Application.class);
	}
	
```

实测结果，注意下面红框内的pro，覆盖了配置文件中的dev
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307202004523.png)

**说明**
当然可以直接传入完整的命令行参数 --spring.profiles.active=pro,biz，这样代码内部就不需要进行特殊处理
例如：
```java
java -jar xxx.jar --spring.profiles.active = prod
```

### 3.3.2、外置配置文件方式

当程序以独立的jar运行时，我个人的感觉是外置的配置文件是优于内置的配置文件的；因为修改配置的话，不需要重新打包部署，直接改即可。

这种实现方式也没啥好多说的，相当于把配置文件拉出来放在外面而已，再根据环境写具体的spring.profiles.active的值。

# 4、小结
这一篇教程的知识点虽然比较简单，但是有很多非常有意思的东西需要大家去挖掘
1. 比如如何实现多环境的配置管理
	1. 除了文中介绍的配置参数方式之外，还可以考虑下技术派中的maven实现姿势，两者可以对比一下
2. 如何获取配置参数
3. 配置参数除了放置在配置文件之外，还可以设置系统、容器、启动参数等
4. 不同参数配置来源，也有对应的优先级，比如应用外部的配置文件是优先与应用内部的配置文件的。




