在java的生态体系中，我们会发现常见的实体类有各种命名习惯，比如do,dto,bo,vo,po,entity,rsp,req等

同样在技术派中的实体类，也有很多不同的叫法，那么它们之间到底有什么区别？这些命名又适用于哪些场景呢？

# 1、概念
![](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212220690.png)


## 1.1、do领域对象
#do
> 相关文档2
> 
> 对于DO的介绍主要有两种：
> 1. 一个是阿里巴巴的开发手册中的定义
>    DO（ Data Object）这个等同于上面的PO  
> 2. 另一个是在DDD（Domain-Driven Design）领域驱动设计中
>    DO（Domain Object）这个等同于上面的BO

domain object: 从现实世界中抽象出来的有形或无形的业务实体

## 1.2、dto数据传输对象
#dto
> 相关文档2：
> 
> 这个传输通常指的前后端之间的传输。
> DTO是一个比较特殊的对象，他有两种存在形式：
> 1. 在后端，他的存在形式是java对象，也就是在controller里面定义的那个东东，通常在后端不需要关心怎么从json转成java对象的，这个都是由一些成熟的框架帮你完成啦，比如spring框架
> 2. 在前端，他的存在形式通常是js里面的对象（也可以简单理解成json），也就是通过ajax请求的那个数据体
> 这也是为什么把他画成横跨两层的原因
> 
> > 这里可能会遇到个问题，现在微服务盛行，服务和服务之间调用的传输对象能叫DTO吗？  
> > 我的理解是看情况，DTO本身的一个隐含的意义是要能够完整的表达一个业务模块的输出，
> > 如果服务和服务之间相对独立，那就可以叫DTO  
> > 如果服务和服务之间不独立，每个都不是一个完整的业务模块，拆开可能仅仅是因为计算复杂度或者性能的问题，那这就不能够叫做DTO，只能是BO
> 

data transfer object:  数据传输对象，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载

通常适用于展示层与服务层之间、服务层与服务层之间的数据传输对象

## 1.3、bo业务对象
#bo
> 相关文档2：
> 
> BO就是PO的组合  
> 简单的例子比如说PO是一条交易记录，BO是一个人全部的交易记录集合对象；
> 复杂点儿的例子PO1是交易记录，PO2是登录记录，PO3是商品浏览记录，PO4是添加购物车记录，PO5是搜索记录，BO是个人网站行为对象。
> 
> BO是一个业务对象，一类业务就会对应一个BO，数量上没有限制，而且BO会有很多业务操作，也就是说除了get，set方法以外，BO会有很多针对自身数据进行计算的方法  
> 
> 为什么BO也画成横跨两层呢？原因是现在很多持久层框架自身就提供了数据组合的功能，因此BO有可能是在业务层由业务来拼装PO而成，也有可能是在数据库访问层由框架直接生成。
> 很多情况下为了追求查询的效率，框架跳过PO直接生成BO的情况非常普遍，PO只是用来增删改使用。

Business Object：业务对象，通常是服务内的业务相关属性对象

## 1.4、po持久化对象
#po
> 相关文档2：
> 
> 简单说PO就是数据库中的记录，一个PO的数据结构对应着库中表的结构，表中的一条记录就是一个PO对象。
> 通常PO里面除了get，set之外没有别的方法。
> 对于PO来说，属性的数量是相对固定的，一定不会超过数据库表的数量，等同于Entity，这俩概念是一致的。

Persistant Object：持久化对象，通常对应数据库中的实体

另一个常见的命名规范为 Entity

## 1.5、vo视图对象
#vo
> 相关文档2：
> 
> VO就是展示用的数据，不管展示方式是网页，还是客户端，还是APP，只要是这个东西是让人看到的，这就叫VO。
> VO主要的存在形式就是js里面的对象（也可以简单理解成json）。

view object: 视图对象，通常可以理解为展示的对象，展示的对象可以是网页、客户端、app

## 1.6、req请求参数对象
#req
request: 请求参数封装对象类，通常专指接口的传参对象

## 1.7、rsp返回结果对象
#rsp
response: 返回结果封装类，通常用于将返回给展示层的对象格式化统一返回的场景

# 2、差异性
## 2.1、vo与dto
> 相关文档2：
> 
> 主要有两个区别：
> 1. 一个是字段不一样，VO根据需要会删减一些字段  
> 2. 另一个是值不一样，VO会根据需要对DTO中的值进行展示业务的解释
> 示例：
> DTO可能是这样的
> ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212325879.png)
> 对于业务一来说只需要性别，而且因为是一个古风聊天室，也不能直接展示男，因此经过业务解释业务一的VO是
> ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212325953.png)
> 对于业务二来说只需要年龄，而且不需要精确的年龄，因此经过业务解释业务二的VO是
> ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212326628.png)
> 




对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，但是从概念上两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据

如果对上面的描述还不太懂，那么有一个简单的区分方式（不保证完全准确）
1. 后端与前端进行交互的数据对象，返回vo
2. 后端服务与服务之间的交互数据对象，返回dto

## 2.2、dto与do
在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。

对于DO来说，还有一点需要说明：为什么不在服务层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下：
1. 两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。
2. DO具有一些不应该让展示层知道的数据
3. DO具有业务方法，如果直接把DO传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于AOP拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用DO的业务方法也会因为事务的问题，让事务难以控制。
4. 对于某些ORM框架（如Hibernate）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。
5. 从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把DO暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。
6. 对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”，举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？

如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”，笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。

## 2.3、do与po
DO和PO在绝大部分情况下是一一对应的，但从应用场景上来看有明显的区别：
1. DO在某些场景下不需要进行显式的持久化，不存在PO
2. 同样的道理，某些场景下，PO也没有对应的DO
3. 某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。
4. PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。


## 2.4、po与entity

说实话没啥本质区别，看项目规范，通常都对应的是数据库持久化对象

## 2.5、dto与bo

> 相关文档2：
> 这两个的区别主要是就是字段的删减
> BO对内，是为了进行业务计算你需要辅助数据，或者是一个业务有多个对外的接口，BO可能会含有很多接口对外所不需要的数据，因此DTO需要在BO的基础上，只要自己需要的数据，然后对外提供；
> 在这个关系上，通常不会有数据内容的变化，内容变化要么在BO内部业务计算的时候完成，要么在解释VO的时候完成。
> 

bo通常是保存业务相关对象，不与外部交互，通常当我们调用了外部服务接口，一个比较好的方案是并不直接使用对方返回的DTO对象，而是按照实际业务需求，将dto对象转换为内部的bo对象，然后再内部使用

为什么这么干？
1. 比如对方api升级，然后改了dto对象的包路径，那么我这里需要改动的点就很多
2. 对方返回的dto对象，命名规则可能和我的项目差异性较大，而且大部分场景下我不会关系它的全量数据，最好似乎按需取用

# 3、技术派的实体类

在技术派中，并没有把上面所有的都引进来，主要可以看到
1. do: 数据库实体 （这个其实叫做po或entity更合适，我们这里直接干掉了po/entity，减少转换，适用于小型的项目，大型、分布式项目不要这么干）
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212259317.png)

2. dto: 返回给前端的数据实体
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212300778.png)

3. vo: 封装返回给前端的数据实体
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212300120.png)

4. req：前端传递给后端的请求参数
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307212301169.png)


# 4、相关文档
说明：以上内容部分原创、部分来自下面这些优秀的文章，有兴趣的小伙伴可以翻下
1. [补0_浅析 VO、DTO、DO、PO 的概念、区别和用处！](2、相关技术/24、项目/1、技术派/4、补充/补0_浅析%20VO、DTO、DO、PO%20的概念、区别和用处！.md)
2. [一篇文章讲清楚VO，BO，PO，DO，DTO的区别 - 知乎](https://zhuanlan.zhihu.com/p/102389552)
>    相关文档2
>    这几个概念很完整，我们在用的时候是必须按这个来做吗？  
>    当然不是的，系统和系统的复杂度不同，协作水平不同，完全没有必要教条主义，这些概念全上上哪些概念，省哪些，我给一些实际建议：
>    1. PO这个没法省，不管叫PO还是Entity，怎么着都得有
>    2. 一些工具类的系统和一些业务不是很复杂的系统DTO是可以和BO合并成一个，当业务扩展的时候注意拆分就行
>    3. VO是可以第一个优化掉的，展示业务不复杂的可以压根儿不要，直接用DTO
>    4. 这也是最重要的一条，概念是给人用的，多人协作的时候一定要保证大家的概念一致，赶紧把这篇文章转发给跟你协作的人吧
>    



