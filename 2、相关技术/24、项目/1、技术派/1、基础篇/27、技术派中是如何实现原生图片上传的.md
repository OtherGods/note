今天由我来给大家讲一下技术派中是如何实现原生图片上传的，这个功能说起来很简单，但是很考验技术实力，因为图片上传涉及到IO读写，可以说，一个文件上传的功能，就可以把IO流涉及到的知识全部覆盖到，比如说字节流ByteArrayInputStream、缓存流BufferedOutputStream、文件File的读写权限、文件魔数等等。

想要完全搞清楚，甚至想要手写一个属于自己的文件读写Util类，是需要下一番功夫的，因为考虑的细节还是蛮多的，比如说静态资源配置、图片大小限制、前端图片上传组件、后端图片接收参数MultipartHttpServletRequest等等。

技术派中对图片的上传，是做了充份准备的，当你在本地拉取技术派源码跑起来的时候，我们默认会把图片保存到本地；当你需要在生产环境部署的话，我们默认会采用OSS配合CDN的方式来完成。这篇内容主要介绍本地上传图片的方式。

# 1、业务介绍

技术派中关于图片上传的入口有三处：
1. 发表文章时
2. 上传文章封面时
3. 上传用户头像时

先来看发表文章，这里涉及到四种方式：
1. 通过编辑器的菜单添加图片
2. 直接复制一张图片黏贴到编辑器中
3. 复制外部的图片链接（markdown格式），到编辑器中
4. 导入MD文件到编辑器中（如果有图片链接时）

这四种方式都会触发图片上传功能（严格一点的话，后面两个还涉及到图片转链，后面会讲），后台的接口是一样的，都调用的是ImageRestController，上传图片调用的是upload方法，请求参数为HttpServletRequest；转存图片链接调用的是save方法，参数为图片的外部链接。响应结果为 `ResVo<ImageVo>` ，其中包含最关键的信息——图片路径。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272131860.png)

搞清楚业务的话，就很容易去看懂技术派的源码，然后学习和模仿了。


# 2、代码实现
## 2.1、第一步，在dev/application-image.yml文件中添加图片的配置
```java
image:  
  abs-tmp-path: /tmp/storage/  
  web-img-path: /forum/image/  
  tmp-upload-path: /tmp/forum/  
  cdn-host:  
  oss:  
    type: local  
    prefix: paicoding/  
    endpoint:  
    ak:  
    sk:  
    bucket:  
    host: https://cdn.tobebetterjavaer.com  
  
spring:  
  web:  
    resources:  
      # 支持本地图片上传之后的链接，其中 file:///d的用于win系统，后面的file: 适用于mac/linux系统  
      static-locations:  
        - classpath:/static/  
        - file:///d:${image.abs-tmp-path}  
        - file:${image.abs-tmp-path}
```

来解释一下参数的含义：
1. `abs-tmp-path`：存储的绝对路径
2. `web-img-path`：图片在Web应用中的相对路径
3. `tmp-upload-path`：上传文件的临时存储目录
4. `cdn-host`：图片的CDN访问域名（本地不需要）
5. `oss`：图片上传到阿里云OSS时的配置（讲OSS上传的时候再细说）
6. `spring.web.resources.static-locations`：是 Spring Boot 提供的一种加载静态资源的机制。
静态资源包括CSS、JavaScript、图片等文件，通过设置 `spring.web.resources.static-locations` ，我们可以告诉Spring Boot在那些位置查找静态资源。Spring Boot的默认静态资源位置包括：
- classpath:/static
- classpath:/public
- classpath:/resources
- classpath:/META-INF/resources
当我们为 `spring.web.resources.static-locations` 提供自定义的值时，Spring Boot会覆盖这些默认值。在技术派的项目结构中，我们将CSS和JavaScript，以及一些图片资源放在了paicoding-ui模块的static目录下。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272148934.png)

也就意味着，在我们的前端页面中，如果遇到类似这样的 `<link href="/css/views/home.css" rel="stylesheet" />` 请求时，SpringBoot将会从 `classpath:/static/` 目录下去找
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272157215.png)

注意，我们海指定了另外两个静态资源位置：`file:///d:${image.abs-tmp-path} 和 file:${image.abs-tmp-path}` ，前者用于Windows系统，后者用于macOS和Linux系统。

拿macOS举例，我们会把图片保存在 `/tmp/storage/forum/image` 目录下。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272208854.png)

也就是说我们可以通过 `http://127.0.0.1:8080/forum/image/20230423060009676_69.jpg` 这种形式访问图片。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272211630.png)

还可以通过 `file:/tmp/storage/forum/image/20230423060009676_69.jpg` 的形式访问图片。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272212614.png)

`file:/` 是一个URI（统一资源标识符）的方式，表示在本地文件系统上的资源。例如，如果你想引用本地文件系统上的一个文件，可以使用 `file:/` 。以下是一些示例：
- `file:/C:/path/to/your/file.txt`：表示在 Windows 系统上的 C:/path/to/your/file.txt 文件。
- `file:/Users/username/path/to/your/file.txt`：表示在 macOS 或 Linux 系统上的 /Users/username/path/to/your/file.txt 文件。


## 2.2、第二步，新建ImageProperties.java类

使用 `@configurationProperties` 注解使其和配置文件中的图片关联起来。
```java
/**  
 * 图片配置文件  
 *  
 * @author LouZai  
 * @since 2022/9/7  
 */@Setter  
@Getter  
@Component  
@ConfigurationProperties(prefix = "image")  
public class ImageProperties {  
  
    /**  
     * 存储绝对路径  
     */  
    private String absTmpPath;  
  
    /**  
     * 存储相对路径  
     */  
    private String webImgPath;  
  
    /**  
     * 上传文件的临时存储目录  
     */  
    private String tmpUploadPath;  
  
    /**  
     * 访问图片的host  
     */    
	private String cdnHost;  
  
    private OssProperties oss;  
  
    public String buildImgUrl(String url) {  
        if (!url.startsWith(cdnHost)) {  
            return cdnHost + url;  
        }  
        return url;  
    }  
}
```

1. @Setter 和 @Getter 是 lombok 提供的注解，这样我们就不用写冗长的 getter 和 setter。
2. @Component 表示这个类是一个 Spring 管理的 Bean。
3. @ConfigurationProperties 是 Spring Boot 中用于将外部配置文件（如 application.properties 或 application.yml）中的属性绑定到 Java 类的一个注解。通过使用这个注解，我们可以将配置文件中的值自动映射到有相应字段的 Java 类种。参数 prefix = "image" 表示将配置文件中以 image 作为前缀的属性绑定到该类中。

## 2.3、第三步，构建前端上传组件和发起上传请求

我们先来看比较简单的一种，上传文章封面。在发表文章的页面，点击保存按钮，会弹出文章封面的上传模态框。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308272235860.png)

代码非常简单，用了一个 input 组件，type 为 file，接收的文件类型为 image。
```html
<input
  type="file"
  accept="image/*"
  id="upload"
  class="click-input"
/>
```

当选择了图片后，会触发 change 事件。
```JavaScript
upload.on("change", function (e) {
  let objUrl = getObjectURL(this.files[0]) //获取图片的路径，该路径不是图片在本地的路径

  if (objUrl) {
    console.log("uploadImg", this.value)
    uploadImg(() => (this.value = null), objUrl)
  }
})
```

在事件回调函数中，代码会执行以下操作。
- 使用 getObjectURL 函数（稍后会讲）获取选中文件（this.files[0]）的临时 URL。注意，这里的 this 指向触发事件的文件输入元素。
- 检查objUrl是否存在。如果存在，继续。
- 输出 this.value 到控制台。这里的 this.value 是选中文件的本地路径（例如 Windows 下是：`C:\fakepath\file.jpg`，macOS 下是 `/Users/itwanger/Pictures/file.jpg`）。
- 调用 uploadImg 函数，并将一个回调函数和 objUrl 作为参数传递。这个回调函数将在 uploadImg 函数内部执行（图片上传完成后）。在回调函数中，将文件输入元素的 value 属性设置为 null，以清除选中的文件。

来看 getObjectURL 函数（创建一个临时 URL，用于访问本地文件）：
```JavaScript
const getObjectURL = function (file) {
  let url = null

  if (window.createObjectURL != undefined) {
    // basic
    url = window.createObjectURL(file)
  } else if (window.URL != undefined) {
    // mozilla(firefox)
    url = window.URL.createObjectURL(file)
  } else if (window.webkitURL != undefined) {
    // webkit or chrome
    url = window.webkitURL.createObjectURL(file)
  }
  return url
}
```

这段代码使用了三种不同的方式来创建临时URL，以确保兼容性：
- `window.createObjectURL(file)`: 这是一个较旧的方法，用于创建临时 URL。在现代浏览器中，这个方法可能已被废弃。
- `window.URL.createObjectURL(file)`: 这是一个较新的方法，用于创建临时 URL。在许多现代浏览器中（如 Firefox、Chrome、Edge 等），这个方法已经取代了 window.createObjectURL。
- `window.webkitURL.createObjectURL(file)`: 这是一个 WebKit 特定的方法，用于创建临时 URL。在基于 WebKit 的浏览器中（如旧版本的 Chrome 和 Safari），这个方法可能是唯一可用的方法。

再来看uploadImg方法（使用jQuery的Ajax实现图片上传）：
```JavaScript
function uploadImg(callback, objUrl) {
  let uploadPic = upload[0].files[0]
  console.log("准备上传", uploadPic)

  if (!checkFileSize(uploadPic)) {
    return;
  }
  
  let file = new FormData()
  file.append("image", uploadPic)
  $.ajax({
    url: "/image/upload",
    type: "post",
    data: file,
    cache: false,
    contentType: false,
    processData: false,
    success: function (data) {
      console.log("response data", data);
      if (data.status.code > 0) {
        // 图片上传失败
        toastr.error(data.status.msg, "图片上传失败!");
        return;
      }
      
      const {result: { imagePath },} = data || {}
      defaults['cover'] = imagePath;
      
      //将图片路径存入src中，显示出图片
      pic.attr("src", objUrl).css('visibility', 'visible') // 展示图片
      callback();
      toastr.info("图片上传成功!");
    },
    error : function(jqXHR, textStatus, errorThrown) {
      toastr.error(jqXHR.responseText, "图片上传失败!");
    },
  })
}
```

解释一下这段代码：
- 函数 uploadImg 接受两个参数：一个回调函数callback和一个对象URLobjUrl。
- 从文件输入框 upload 中获取要上传的图片文件（uploadPic）
- 使用checkFileSize函数检查文件大小，如果文件大小不符合要求，则终止执行。
- 创建一个新的FormData对象，并将图片添加到其中。FormData是一个Web API，它提供了一种在浏览器中方便地构造、发送表单数据的方法。它主要用于发送包含二进制文件和键值对的数据，如图片、视频、文档等。FormData对象可以与Ajax一起使用，以便在不刷新页面的情况下将表单数据发送到服务器。当使用FormData时，浏览器会自动将数据编码为multipart/form-data格式，这是一种特殊的格式，允许在表单中包含二进制文件数据，如图片或视频。
- 使用jQuery的$.ajax方法发起一个异步的POST请求，将图片文件发送到服务器的/image/upload接口。
- 在ajax方法中，设置一些关键的参数，如：cache: false表示禁用浏览器缓存；contentType: false表示不设置内容类型（让浏览器自动设置）；processData: false表示不对数据进行预处理。
- 定义一个success回调函数，当服务器成功响应时触发。检查响应数据中的状态码（data.status.code）。如果大于0，表示图片上传失败，显示错误消息。否则，从响应数据中获取图片路径（imagePath），将图片路径设置为pic元素的src属性，使图片可见。调用回调函数callback。显示图片上传成功的提示信息。
- 定义一个error回调函数，当请求发生错误时触发。在这个回调函数中，显示错误消息。


## 2.4、第四步，在ImageRestController接收图片并处理

```java
/**  
 * 返回json格式数据  
 *  
 * @author LouZai  
 * @date 2022/9/7  
 */
@RequestMapping(path = {"image/", "admin/image/", "api/admin/image/",})  
@RestController  
@Slf4j  
public class ImageRestController {  
  
    @Autowired  
    private ImageService imageService;  
  
    /**  
     * 图片上传  
     *  
     * @return  
     */  
    @RequestMapping(path = "upload")  
    public ResVo<ImageVo> upload(HttpServletRequest request) {  
        ImageVo imageVo = new ImageVo();  
        try {  
            String imagePath = imageService.saveImg(request);  
            imageVo.setImagePath(imagePath);  
        } catch (Exception e) {  
            log.error("save upload file error!", e);  
            return ResVo.fail(StatusEnum.UPLOAD_PIC_FAILED);  
        }  
        return ResVo.ok(imageVo);  
    }  
  
    /**  
     * 转存图片  
     *  
     * @param imgUrl  
     * @return  
     */  
    @RequestMapping(path = "save")  
    public ResVo<ImageVo> save(@RequestParam(name = "img", defaultValue = "") String imgUrl) {  
        ImageVo imageVo = new ImageVo();  
        if (StringUtils.isBlank(imgUrl)) {  
            return ResVo.ok(imageVo);  
        }  
  
        String url = imageService.saveImg(imgUrl);  
        imageVo.setImagePath(url);  
        return ResVo.ok(imageVo);  
    }  
}
```

来详细解释下：
- `@RequestMapping(path = "image/")` 注解用于指定控制器处理的请求路径为 "image"。
- `@RestController` 注解表示这是一个用于处理RESTFUL风格请求的控制器。
- `@Slfj` 注解用于自动注入一个SLF4J的日志对象
- 使用 `@Autowired` 注解将ImageService（用于处理图片保存和转链的关键类）自动注入到控制器中

接下来，让我们看看这个控制器中的upload方法，这个方法用于处理图片上传请求
- 使用 `@RequestMapping(path = "upload")` 注解将此方法映射到 `image/upload` 路径。
- 该方法接收一个HttpServletRequest参数，该参数代表客户端发送的HTTP请求
- 在该方法内部，调用 `imageService.saveImg(request)` 方法将图片保存到服务器，并获取图片路径。
- 将图片路径设置到ImageVo对象中，然后将ImageVo对象作为响应数据返回给客户端。

## 2.5、第五步

很简单，就不再解释了，看注释就懂
```java
public interface ImageService {
    /**
     * 保存图片
     *
     * @param request
     * @return
     */
    String saveImg(HttpServletRequest request);
}
```

## 2.6、第六步，实现ImageService接口

```java
@Override  
public String saveImg(HttpServletRequest request) {  
    MultipartFile file = null;  
    if (request instanceof MultipartHttpServletRequest) {  
        file = ((MultipartHttpServletRequest) request).getFile("image");  
    }  
    if (file == null) {  
        throw ExceptionUtil.of(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "缺少需要上传的图片");  
    }  
  
    // 目前只支持 jpg, png, webp 等静态图片格式  
    String fileType = validateStaticImg(file.getContentType());  
    if (fileType == null) {  
        throw ExceptionUtil.of(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "图片只支持png,jpg,gif");  
    }  
  
    try {  
        return imageUploader.upload(file.getInputStream(), fileType);  
    } catch (IOException e) {  
        log.error("Parse img from httpRequest to BufferedImage error! e:", e);  
        throw ExceptionUtil.of(StatusEnum.UPLOAD_PIC_FAILED);  
    }  
}
```

这个方法的主要功能是从HTTP请求中提取图片并保存。
- 首先，检查HttpServletRequest是否为MultipartHttpServletRequest。如果是，则从请求中获取名为“image”的文件并将其保存到MultipartFile对象中。MultipartHttpServletRequest是一个Java接口，它继承自HttpServletRequest接口。在Spring框架中，这个接口用于处理包含文件上传的HTTP请求，即请求的内容类型为multipart/form-data。在这种请求类型中，表单数据可以包含文本字段和二进制文件，如图片、视频或文档。
- 如果file为空（即未上传任何文件），则抛出一个异常，表示请求中缺少需要上传的图片。
- 接下来，验证图片文件的类型。当前方法只支持jpg、png和webp等静态图片格式。validateStaticImg方法检查传入的内容类型是否属于这些支持的类型，并返回相应的文件类型。如果文件类型不支持，则抛出一个异常。
- 从MultipartFile对象中获取输入流，然后传递给upload方法，如果在上传过程中发生任何错误，例如将图片转换为BufferedImage时出现问题，将抛出一个异常。

## 2.7、第七步，定义ImageUploader接口

```java
public interface ImageUploader {  
    String DEFAULT_FILE_TYPE = "txt";  
    Set<MediaType> STATIC_IMG_TYPE = new HashSet<>(Arrays.asList(MediaType.ImagePng, MediaType.ImageJpg, MediaType.ImageWebp, MediaType.ImageGif));  
  
    /**  
     * 文件上传  
     *  
     * @param input  
     * @param fileType  
     * @return  
     */  
    String upload(InputStream input, String fileType);  
  
    /**  
     * 判断外网图片是否依然需要处理  
     *  
     * @param fileUrl  
     * @return true 表示忽略，不需要转存  
     */  
    boolean uploadIgnore(String fileUrl);  
  
    /**  
     * 获取文件类型  
     *  
     * @param input  
     * @param fileType  
     * @return  
     */  
    default String getFileType(ByteArrayInputStream input, String fileType) {  
        if (StringUtils.isNotBlank(fileType)) {  
            return fileType;  
        }  
  
        MediaType type = MediaType.typeOfMagicNum(FileReadUtil.getMagicNum(input));  
        if (STATIC_IMG_TYPE.contains(type)) {  
            return type.getExt();  
        }  
        return DEFAULT_FILE_TYPE;  
    }  
}
```

来解释一下这段代码：
- DEFAULT_FILE_TYPE：一个默认的文件类型，用于表示当文件类型无法识别时的默认值。在这个接口中，它被设置为"txt"。
- STATIC_IMG_TYPE：一个包含支持的静态图片类型的集合。它包括PNG、JPG、WebP和GIF等类型。
- upload(InputStream input, String fileType)：这是一个需要实现的抽象方法，用于将输入流中的文件保存。
- getFileType(ByteArrayInputStream input, String fileType)：这是一个默认的实现方法，用于根据输入流中的文件内容和给定的文件类型获取最终的文件类型。首先检查fileType是否为空，如果不为空则直接返回。然后使用MediaType.typeOfMagicNum方法通过文件的魔数（magic number）来判断文件类型。如果文件类型属于支持的静态图片类型集合，则返回对应的扩展名。否则，返回默认的文件类型。

来看一下获取文件魔数的静态方法 getMagicNum：
```java
public static String getMagicNum(ByteArrayInputStream inputStream) {
    byte[] bytes = new byte[28];
    inputStream.read(bytes, 0, 28);
    inputStream.reset();
    return bytesToHex(bytes);
}
```

假如是一张jpg的文件，我们来看一下魔数是多少
```java
FileInputStream fileInputStream = new FileInputStream("docs/imgs/init_00.jpg");
ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

byte[] buffer = new byte[4096];
int bytesRead;

while ((bytesRead = fileInputStream.read(buffer)) != -1) {
    byteArrayOutputStream.write(buffer, 0, bytesRead);
}

ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
String magicNum = FileReadUtil.getMagicNum(byteArrayInputStream);
System.out.println("文件魔数 " + magicNum);

// 根据魔数判断文件类型
MediaType type = MediaType.typeOfMagicNum(magicNum);
System.out.println("文件类型 " + type);
```

来看输出结果：
```java
文件魔数 ffd8ffe000104a46494600010100000100010000ffdb008400080808
文件类型 ImageJpg
```

Java 字节码文件（即 .class 文件）的魔数是一个 4 字节的十六进制数：0xCAFEBABE。

**魔数是文件格式的标识符，用于表示文件的类型。**

## 2.8、第八步，新建 LocalStorageWrapper 类实现ImageUploader接口

```java
@Slf4j  
@ConditionalOnExpression(value = "#{'local'.equals(environment.getProperty('image.oss.type'))}")  
@Component  
public class LocalStorageWrapper implements ImageUploader {  
    @Autowired  
    private ImageProperties imageProperties;  
    private Random random;  
  
    public LocalStorageWrapper() {  
        random = new Random();  
    }  
  
    @Override  
    public String upload(InputStream input, String fileType) {  
        try {  
            if (fileType == null) {  
                // 根据魔数判断文件类型  
                byte[] bytes = StreamUtils.copyToByteArray(input);  
                input = new ByteArrayInputStream(bytes);  
                fileType = getFileType((ByteArrayInputStream) input, fileType);  
            }  
  
            String path = imageProperties.getAbsTmpPath() + imageProperties.getWebImgPath();  
            String fileName = genTmpFileName();  
  
            FileWriteUtil.FileInfo file = FileWriteUtil.saveFileByStream(input, path, fileName, fileType);  
            return imageProperties.buildImgUrl(imageProperties.getWebImgPath() + file.getFilename() + "." + file.getFileType());  
        } catch (Exception e) {  
            log.error("Parse img from httpRequest to BufferedImage error! e:", e);  
            throw ExceptionUtil.of(StatusEnum.UPLOAD_PIC_FAILED);  
        }  
    }  
  
    /**  
     * 获取文件临时名称  
     *  
     * @return  
     */  
    private String genTmpFileName() {  
        return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddhhmmssSSS")) + "_" + random.nextInt(100);  
    }
}
```

该类使用了 @ConditionalOnExpression 注解，表示只有在配置文件中的 image.oss.type 属性值为 "local" 时才会实例化该类。
- imageProperties：一个 ImageProperties 类型的对象，用于获取图片相关的配置信息。前面介绍过了。
- random：一个 Random 类型的对象，用于生成随机数。
- upload(InputStream input, String fileType)：实现 ImageUploader 接口中的 upload 方法，用于将给定的输入流保存到本地文件系统。首先检查 fileType 是否为 null，如果是，则根据输入流中的字节数据的魔数确定文件类型。然后，根据配置文件中的路径设置和文件类型，将文件保存到本地文件系统，并返回文件的 URL。
- genTmpFileName()：一个辅助方法，用于生成临时文件名。它使用当前日期时间和一个随机数生成文件名。

其中调用了 FileWriteUtil.saveFileByStream 方法，用来对图片进行保存。
```java
public static FileInfo saveFileByStream(InputStream stream, FileInfo fileInfo) throws FileNotFoundException {  
    if (!StringUtils.isBlank(fileInfo.getPath())) {  
        mkDir(new File(fileInfo.getPath()));  
    }  
  
    String tempAbsFile = fileInfo.getPath() + "/" + fileInfo.getFilename() + "." + fileInfo.getFileType();  
    BufferedOutputStream outputStream = null;  
    InputStream inputStream = null;  
    try {  
        inputStream = new BufferedInputStream(stream);  
        outputStream = new BufferedOutputStream(new FileOutputStream(tempAbsFile));  
        int len = inputStream.available();  
        //判断长度是否大于4k  
        if (len <= 4096) {  
            byte[] bytes = new byte[len];  
            inputStream.read(bytes);  
            outputStream.write(bytes);  
        } else {  
            int byteCount = 0;  
            //1M逐个读取  
            byte[] bytes = new byte[4096];  
            while ((byteCount = inputStream.read(bytes)) != -1) {  
                outputStream.write(bytes, 0, byteCount);  
            }  
        }  
  
        return fileInfo;  
    } catch (Exception e) {  
        log.error("save stream into file error! filename: {} e: {}", tempAbsFile, e);  
        return null;    } finally {  
        try {  
            if (outputStream != null) {  
                outputStream.flush();  
                outputStream.close();  
            }  
  
            if (inputStream != null) {  
                inputStream.close();  
            }  
        } catch (IOException e) {  
            log.error("close stream error!", e);  
        }  
    }  
}
```

该方法的参数包括输入流和一个FileInfo对象，其中FileInfo对象博阿寒了文件的路径、文件名和文件类型。

代码实现了以下功能：
- 检查文件路径是否存在，如果不存在则创建文件夹。
- 根据文件路径、文件名和文件类型创建一个临时的绝对文件路径。
- 使用 BufferedInputStream 和 BufferedOutputStream 对输入流和输出流进行缓冲处理，以提高文件读写性能。
- 判断输入流的长度是否大于 4 KB。如果小于等于 4 KB，就一次性读取所有字节并写入输出流；否则，以 4 KB 的块逐步读取输入流并写入输出流，直到所有内容都被处理。
- 在操作完成后，返回 FileInfo 对象。

# 3、小结

简单总结一下，本地图片上传和保存的逻辑可以分为前端和后端两个部分：
1. 前端（使用Ajax上传）：
	1. 用户选择一张图片并上传
	2. 使用FormData对象封装图片数据。FormData对象能够让你通过XMLHttpRequest发送表达数据
	3. 利用jQuery的 `$.ajax` 方法发送一个POST请求，将FormData对象传递给后端服务器
2. 后端（Java代码处理上传和保存）：
	1. 从HttpServletRequest对象中提取出MultipartFile对象，该对象包含了上传的图片数据
	2. 验证图片类型，确保上传的文件是支持的图片格式
	3. 将MultipartFile对象转换为InputStream，以便后续处理
	4. 调用一个专门负责处理图片上传的方法（如：upload（）），该方法可能还需要处理文件类型和文件名等逻辑
	5. 保存图片到本地文件系统。这里可以使用一个方法（如：saveFileByStream（）），将InputStream保存为文件。在保存过程中，可以使用BufferedInputStream和BufferedOutputStream来提高文件读写性能。
	6. 将图片的存储路径返回给前端，前端可以使用这个路径来显示上传成功的图片。
这样一来，前端通过 Ajax 发送图片数据到后端，后端处理上传请求并将图片保存到本地文件系统，最后将图片路径返回给前端进行展示。