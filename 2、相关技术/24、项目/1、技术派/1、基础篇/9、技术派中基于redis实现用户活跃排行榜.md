排行榜是一个很常见的需求场景，当然对应的技术选型方案也可以说非常成熟，在技术派项目中，我们也引入了一个用户活跃度的排行榜，主要是基于redis的zset数据结构来实现，给大家实例演示一下，如何实现一个生产可用的排行榜

# 1、方案设计

在具体的代码介绍之前，先来了解一下业务场景
## 1.1、场景说明

技术派中，提供了一个用户的活跃排行榜，当然作为一个博客社区，更应该实现的是作者排行榜；出于让大家更有参与感的目的，我们以用户活跃度来设计一个排行榜，区分日/月两个榜单

用户活跃度计算方式：
1. 用户每访问一个新的页面 +1 分
2. 对于每一篇文章，点赞、收藏 +2 分；取消点赞、收藏，将之前活跃分数收回
3. 文章评论 +3 分
4. 发布一篇审核通过的文章 +10 分

榜单：
1. 展示活跃度最高的前三十名用户

实际的榜单效果如下（可以在首页活跃排行榜侧边栏点击进入）
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031325400.png)

## 1.2、方案设计

排行榜的业务属性比较清晰简单，对应的数据结构也可以很容易的设计出来，核心的信息如下：

**存储单元**
表示排行榜中每一位上应该持有的信息如下：

```java
// 用来表明具体的用户
long userId;
// 用户在排行榜上的排名
long rank;
// 用户的历史最高积分，也就是排行榜上的积分
long score;
```

**数据结构**
排行榜，一般而言都是连续的，借此我们可以联想到一个合适的数据结构LinkedList，好处在于排名变动时，不需要数组的拷贝
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031336689.png)

上图演示，当一个用户活跃度改变时，需要向前遍历找到合适的位置，插入并获取新的排名，在更新和插入时，相比ArrayList要好很多，但依然有以下几个缺陷
1. **问题1：用户如何获取自己的排名？**
   使用LinkedList在更新插入和删除带来的优势之外，在随机获取元素的支持会差一点，最差的情况是从头到尾进行扫描
2. **问题2：并发支持的问题？**
   当有多个用户同时更新score时，并发的更新排名问题就比较突出了，当然可以使用jdk中类似写时复制数组的方案
   
   上面是我们自己来实现这个数据结构时，会遇到的一些问题，当然我们是借助redis来实现排行榜，下面则来看下，利用redis可以怎么简单的支持我们的需求场景
3. **redis使用方案**
   这里主要使用的是redis的ZSET数据结构，带权重的集合，下面分析一下可能性
	1. set：集合确保里面元素的唯一性
	2. 权重：这个可以看作我们的score，这样每个元素都有一个score
	3. zset：根据score进行排序的集合
从zset的特性来看，我们每个用户的积分，丢到zset中，就是一个带权重的元素，而且是已经排好序的了，只需要获取元素对应的index，就是我们预期的排名

## 1.3、redis使用方案

接下来我们看一下技术派中的活跃排行榜单是如何实现的

核心包路径：`com.github.paicoding.forum.service.rank`

核心代码实现：`com.github.paicoding.forum.service.rank.service.impl.UserActivityRankServiceImpl`

# 2、排行榜实现
## 2.1、更新用户活跃积分

我们先实现一个更新用户活跃的方法，首先定义一个涵盖上面业务场景的参数传递实体 `ActivityScoreBo`

接下来我们先思考一下，这个具体的应该怎么实现，先梳理实现的业务流程
1. 根据业务实体，计算需要增加/减少的活跃度
2. 对于增加活跃度时：
	1. 做一个幂等，防止重复添加，因此需要判断下之前没有重复添加过相关的活跃度
	2. 若幂等了，则直接返回；否则执行更新，并做好幂等保存
3. 对于减少活跃度时：
	1. 判断之间有没有加过活跃度，防止扣减为负数
	2. 之前没有扣减过，则直接返回；否则执行扣减，并移除幂等判定（这一步没看懂，感觉应该是之前没有增加过活跃度才。。。）

上面的业务逻辑清晰之后，在看一下我们实现的关键要素
1. 怎么做幂等？
2. 如何更新榜单的评分？

### 2.1.1、幂等策略

为了防止重复增加活跃度，怎么做幂等呢？一个简单的方案是将用户的每个加分项，都直接记录下来，在执行具体加分时，基于此来做幂等判定

基于上面这个思路，很容易想到的一个方案就是，每个用户维护一个活跃更新操作历史记录表，我们尽量设计的轻量级一点

直接将用户的历史记录，保存在redis的hash数据结构中，每天一个记录
1. key：`activity_rank_{user_id}_{年月日}`
2. field：活跃度更新key
3. value：添加的活跃度

### 2.1.2、榜单评分更新

这个就相对而言比较简单了，直接基于zset的incr即可

我们同样是扩展了一下RedisClient的工具类，增加上了zset的相关操作
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031646423.png)

### 2.1.3、具体实现

接下来我们看一下具体的实现代码：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031653966.png)

基本上，前面的业务逻辑清楚之后，再看上面的实现，应该没什么太大的难度，但是请注意，上面的整个实现，无懈可击么？
> 1.事务问题：多次的redis操作，存在事务问题
> 2.并发问题：没有做并发，幂等无法100%生效，依然可能存在重复添加/扣减活跃度的情况

上面抛出了两个问题，是我们再做真实的排行榜时，需要重点考虑的，我们这里先不进行扩散，提几个关键知识点（并发通过加锁，事务通过最终一致性来保障）

### 2.1.4、触发活跃度更新

前面只是提供了一个增加活跃度的方法，但是什么时候调用它呢？我们这里借助之前实现的Event/Listenter方式来处理活跃度更新

- 文章/用户的相关操作事件监听，并更新对应的活跃度
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031716960.png)
- 发布文章事件
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031717375.png)

然后就是基于用户浏览行为的活跃度更新，这个就可以再Filte/Inteceptor层来实现了
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031718743.png)

## 2.2、排行榜查询

前面的实现，我们的数据层，一个完整的排行榜就已经存储下来了，接下来就是将这个榜单展示给用户看

基本流程如下：
1. 从redis中获取topN的用户+评分
2. 查询用户的信息
3. 根据用户评分进行排序，并更新每个用户的排名
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031720237.png)

核心的redis实现如下,直接基于 zRangeWithScores 获取指定排名的用户+对应分数，其中topN的写法如下
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309031720566.png)


## 2.3、小结

基于此，后端测的排行榜单的功能就已经全部实现；至于前端展示，前后端交互的细节，我们这里就不详细展开；整体来讲，我们提供了一个基础、简单可用的排行榜的设计以及实现全流程

当我们的项目足够大，用户体量也很大时，上面还是有不少点需要我们进一步进行完善

如：
- 如何做防刷？
- 并发问题怎么规避？
- 由非原子的redis操作，引入的事务问题怎么避免？
- 性能测试可以怎么进行？
- 数据量大时，存储的用户操作记录导致的庞大存储压力有解决方案么?

欢迎有想法的小伙伴，在评论区/知识星球，给出你的答案，我是你们的老朋友一灰灰，觉得不错的点个赞呗