虽然技术派没有支持邮箱的方式进行登录，但是它还是整合了邮箱服务的，主要用于异常的报警；基于error日志，来实现异常日志输出时，触发邮箱报警的钩子，从而将异常堆栈推送给管理人员，基于此搭建了一个零成本的报警服务。

在具体的学习上面这个日志报警的设计实现之前，我们有必要先补一下课，如何给自己的服务接入邮箱服务，如何使用邮箱来发送邮件
# 1、使用实例
## 1.1、邮箱服务封装类

首先在技术派项目中，全局搜索关键字Email，来定位具体的使用地方
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308132053897.png)

找到EmailUtil类，详细代码如下：
```java
package com.github.paicoding.forum.core.util;  
  
import lombok.extern.slf4j.Slf4j;  
import org.springframework.mail.javamail.JavaMailSender;  
import org.springframework.mail.javamail.MimeMessageHelper;  
  
import javax.mail.internet.MimeMessage;  
  
/**  
 * @author YiHui * @date 2023/3/19 
*/
@Slf4j  
public class EmailUtil {  
    private static volatile String from;  
  
    public static String getFrom() {  
        if (from == null) {  
            synchronized (EmailUtil.class) {  
                if (from == null) {  
                    from = SpringUtil.getConfig("spring.mail.from", "xhhuiblog@163.com");  
                }  
            }  
        }  
        return from;  
    }  
  
    /**  
     * springboot-email封装的发送邮件  
     *  
     * @param title  
     * @param to  
     * @param content  
     * @return  
     */    
     public static boolean sendMail(String title, String to, String content) {  
        try {  
            JavaMailSender javaMailSender = SpringUtil.getBean(JavaMailSender.class);  
            MimeMessage mimeMailMessage = javaMailSender.createMimeMessage();  
            MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMailMessage, true);  
            mimeMessageHelper.setFrom(getFrom());  
            mimeMessageHelper.setTo(to);  
            mimeMessageHelper.setSubject(title);  
            //邮件内容，第二个参数设置为true，支持html模板  
            mimeMessageHelper.setText(content, true);  
            // 解决 JavaMailSender no object DCH for MIME type multipart/mixed 问题  
            // 详情参考：[Email发送失败问题记录 - 一灰灰Blog](https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/)  
            // 已整理到第三小节：3、Email发送失败问题记录
            Thread.currentThread().setContextClassLoader(EmailUtil.class.getClassLoader());  
            javaMailSender.send(mimeMailMessage);  
            return true;  
        } catch (Exception e) {  
            log.warn("sendEmail error {}@{}, {}", title, to, e);  
            return false;  
        }  
    }  
  
}
```

上面的具体实现不用care，先看一下效果

## 1.2、使用示例

在技术派项目中，特意加了一个TestController，给大家体验一些基础功能，比如我们基于邮箱服务提供一个测试接口
```java
@Slf4j
@RestController
@RequestMapping(path = "test")
public class TestController {  
    private AtomicInteger cnt = new AtomicInteger(1);  
  
    /**  
     * 测试邮件发送  
     *  
     * @param req  
     * @return  
     */  
    @RequestMapping(path = "email")  
    public ResVo<String> email(EmailReqVo req) {  
        if (StringUtils.isBlank(req.getTo()) || req.getTo().indexOf("@") <= 0) {  
            return ResVo.fail(Status.newStatus(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "非法的邮箱接收人"));  
        }  
        if (StringUtils.isBlank(req.getTitle())) {  
            req.setTitle("技术派的测试邮件发送");  
        }  
        if (StringUtils.isBlank(req.getContent())) {  
            req.setContent("技术派的测试发送内容");  
        } else {  
            // 测试邮件内容，不支持发送邮件正文，避免出现垃圾情况  
            req.setContent(StringEscapeUtils.escapeHtml4(req.getContent()));  
        }  
  
        boolean ans = EmailUtil.sendMail(req.getTitle(), req.getTo(), req.getContent());  
        log.info("测试邮件发送，计数：{}，发送内容：{}", cnt.addAndGet(1), req);  
        return ResVo.ok(String.valueOf(ans));  
    }
```

然后测试一下效果：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308132102071.png)

说明：
1. 线上的接口请慎重测试，我会不定期的查看实际使用情况，如果发现被用于搞其他的事情，会考虑关闭这个测试接口

# 2、邮箱服务整合

看了上面的实际使用场景，接下来给大家介绍一下如何给字节的项目集成邮箱服务

## 2.1、配置

在pom.xml配置文件中引入依赖：
```xml
<dependencies>
	<!-- 邮件发送的核心依赖 -->
	<dependency>  
	    <groupId>org.springframework.boot</groupId>  
	    <artifactId>spring-boot-starter-mail</artifactId>  
	</dependency>

	<!-- 适用于html模板形式的邮件发送，借助freemaker来实现html模板渲染 -->
	<!-- 虽然技术派主要是基于thymeleaf进行模板渲染，为了给大家多加点知识点，这里改用freemaker进行邮箱的模板渲染 -->
	<dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-freemaker</artifactId>
    </dependency>
</dependencies>
```

接下来就是需要在配置文件中，添加邮箱相关的配置；技术派中的邮箱相关配置放在 `application-email.yml` 配置文件名中

我这里使用的是163的邮箱进行发送邮件，如果是其他的邮箱请调整相关的配置

这里简单介绍下网易邮箱的获取方式
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308132115690.png)

```yml
#邮箱配置  
spring:  
  mail:  
    host: smtp.163.com  
    from: xhhuiblog@163.com  
    # 使用自己的发送方用户名 + 授权码填充  
    username:  
    password:  
    default-encoding: UTF-8  
    port: 465  
    properties:  
      mail:  
        smtp:  
          socketFactory:  
            port: 465  
            class: javax.net.ssl.SSLSocketFactory  
            fallback: false  
          auth: true  
          starttls:  
            enable: true  
            required: true  
```

## 2.2、邮件发送

接下来介绍下邮件发送的几种姿势
### 2.2.1、简单文本邮件发送

我们这里直接使用JavaMailSender来发送一个基础的文件邮件
```java
@Service
public class MailDemo {
    @Autowired
    private JavaMailSender javaMailSender;

    @Value("${spring.mail.from:xhhuiblog@163.com}")
    private String from;
    
    private void basicSend() {
        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
        //邮件发送人
        simpleMailMessage.setFrom(from);
        //邮件接收人，可以是多个，参数为可变参数
        simpleMailMessage.setTo("bangzewu@126.com");
        //邮件主题，也就是标题
        simpleMailMessage.setSubject("SpringBoot测试邮件发送");
        //邮件内容
        simpleMailMessage.setText("简单的邮件正文");
        
        javaMailSender.send(simpleMailMessage);
    }
}
```

1. JavaMailSender：直接作为一个Spring的bean对象使用
2. SimpleMailMessage：简单的邮件对象，里面有一些邮件发送，关联的基础信息
	1. from：发送方
	2. replyTo：邮件回复的收件人
	3. to：收件人
	4. cc：抄送
	5. bcc：密送
	6. subject：主题，也就是邮件标题
	7. text：邮件正文，文本格式
	8. date：邮件发送时间
### 2.2.2、html发送

对于简单的文本邮件发送，用上面的基本够了，如果我们希望邮件的内容更美观一点的话，可以借助HTML来实现排版

区别于上面的SimpleMailMessage，这里使用的是MimeMessage，来实现html内容发送

使用姿势与上面享比差不多，无非就是正文编程了html文本罢了
```java
/**
发送html
*/
public void sendHtml() throws MessagingException {
    MimeMessage mimeMailMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMailMessage, true);
    mimeMessageHelper.setFrom(from);
    mimeMessageHelper.setTo("bangzewu@126.com");
    mimeMessageHelper.setSubject("SpringBoot测试邮件发送");

    //邮件内容
    mimeMessageHelper.setText("<h1>Hello World</h1> <br/> " +
	    "<div> 欢迎点击 <a href=\"https://blog.hhui.top\">一灰灰博文地址</a><br/>" +
	    " <img width=\"200px\" height=\"200px\" src=\"https://blog.hhui.top/hexblog/imgs/info/wx.jpg\"/>" +
	    "</div>", true);
    javaMailSender.send(mimeMailMessage);
}
```

**重点注意：**
- 注意上面的 `setText` 方法的第二个参数，必须有，且为true，否则会当成文本内容发送

### 2.2.3、添加附件

邮件中添加附件，我们自己写邮件的时候可以直接选择附件上传，那么代码的实现方式又有什么区别呢？
```java
/**
发送附件
*/
public void sendWithFile() throws MessagingException, IOException {
	MimeMessage mimeMailMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMailMessage, true);
    mimeMessageHelper.setFrom(from);
    mimeMessageHelper.setTo("bangzewu@126.com");
    mimeMessageHelper.setSubject("SpringBoot测试邮件发送");
    mimeMessageHelper.setText("<h1>Hello World</h1> <br/> " +
	    "<div> 欢迎点击 <a href=\"https://blog.hhui.top\">一灰灰博文地址</a><br/>" +
	    " <img width=\"200px\" height=\"200px\" src=\"https://blog.hhui.top/hexblog/imgs/info/wx.jpg\"/>" +
	    "</div>");
	String url = "https://blog.hhui.top/hexblog/imgs/info/wx.jpg";
	URL imgUrl = new URL(url);
	mimeMessageHelper.addAttachment("img.jpg", imgUrl::openStream);
	javaMailSender.send(mimeMailMessage);
}
```

注意上面的实现，与前面差别不大，关键点在于attachment附件，上面的实现是在附件中添加一个照片，为了简单起见，图片是直接从网络下载的，然后将Stream作为传参。

### 2.2.4、Freemaker模板

上面的html发送，会发现需要我们自己来组装html正文，这个操作可能就不是很美好了，借助页面渲染殷勤来实现邮件模板支持，可以说是一个比较常见的方案了，这里简单介绍下Freemaker的实现姿势，至于thymeleaf、beef或jsp啥的，都没有太大的区别。

首先写一个邮件模板 `resources/template/mail.ftl`

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="SpringBoot thymeleaf"/>
    <meta name="author" content="YiHui"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>邮件模板</title>
</head>
<style>
    .title {
        color: #c00;
        font-weight: normal;
        font-size: 2em;
    }
    
    .content {
        color: darkblue;
        font-size: 1.2em;
    }
    
    .sign {
        color: lightgray;
        font-size: 0.8em;
        font-style: italic;
    }
</style>
<body>
<div>
    <div class="title">${title}</div>
    <div class="content">${content}</div>
</div>
</body>
</html>
```

上面的模板中，定义了两个变量，一个title，一个content，这个就是我们需要替换的值

接下来是邮件发送实例：
```java
import freemarker.template.Configuration;

@Autowired
private Configuration configuration;

/**
freemarker 模板
*/
public void freeMakerTemplate() throws MessagingException, IOException, TemplateException {
	MimeMessage mimeMailMessage = javaMailSender.createMimeMessage();
    MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMailMessage, true);
    mimeMessageHelper.setFrom(from);
    mimeMessageHelper.setTo("bangzewu@126.com");
    mimeMessageHelper.setSubject("SpringBoot测试邮件发送");
    
    Map<String, Object> map = new HashMap<>();
    map.put("title", "邮件标题");
    map.put("content", "邮件正文");
    String text = FreeMarkerTemplateUtils.processTemplateIntoString(configuration.getTemplate("mail.ftl"), map);
    mimeMessageHelper.setText(text, true);
    
    String text = FreeMarkerTemplateUtils.processTemplateIntoString(configuration.getTemplate("mail.ftl"), map);
    mimeMessageHelper.setText(text, true);
    
    javaMailSender.send(mimeMailMessage);
}
```

注意上面的实现，关键点就利用FreeMarkTemplateUtils来实现模板的渲染，输出html正文，因此如果想使用其他的模板渲染引擎，就是改这里即可。

## 2.3、小结

这篇教程主要介绍了如何整合邮箱服务，如何发送邮件，并针对简单的文本邮件，html正文，附件等不同的给出了实例；整体看下来使用姿势不难，不过邮件的几个术语可以了解一下
1. to：接收人，就是邮件发送的目标群众
2. cc：抄送，一般来讲抄送的名单，只是让它感知到有这封邮件，属于周知对象
3. bcc：秘送，与上面这两个不同，接收人和抄手人不知道秘送给谁了，这就是最大的区别，一灰没用过

在阿里云的服务器上部署的项目，使用邮箱服务时，有可能会遇到两个诡异的问题（当然完全抄上面的实现姿势就不会遇到问题了），如果想了解详情的可以看下面这篇文章
- [Email发送失败问题记录 - 一灰灰Blog](https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/)

# 3、Email发送失败问题记录

最近升级了一下SpringBoot的版本，结果发现之前工作的好好的邮件突然罢工了，罢工的原因还不止一个，接下来记录一下解决方案

## 3.1、Couldn’t connect to host, port: smtp.163.com, 25; timeout -1

这个异常提示就有点搞人了，连接超时，之前可以现在居然不行，感觉是被针对了啊

上面这个问题，主要原因在于端口号的限制，如果项目中是使用SpringBoot封装的email客户端，可以调整一下配置参数
```yml
spring:  
  #邮箱配置  
  mail:  
    host: smtp.163.com  
    from: xhhuiblog@163.com  
    # 使用自己的发送方用户名 + 授权码填充  
    username:   
    password:   
    default-encoding: UTF-8  
    port: 465  
    properties:  
      mail:  
        smtp:  
          socketFactory:  
            port: 465  
            class: javax.net.ssl.SSLSocketFactory  
            fallback: false  
          auth: true  
          starttls:  
            enable: true  
            required: true
```

重点注意几个新增的配置
```yml
spring:  
	mail:  
		port: 465  
		properties:  
			mail:  
				smtp:  
					socketFactory:  
                        port: 465  
                        class: javax.net.ssl.SSLSocketFactory  
                        fallback: false
```

## 3.2、JavaMailSender no object DCH for MIME type multipart/mixed

从堆栈信息上来看，主要问题貌似是MIME不合法，从网上检索来的结果来看，大概是因为版本的问题，导致`META-INF`下的数据加载异常

参考 [https://stackoverflow.com/questions/21856211/javax-activation-unsupporteddatatypeexception-no-object-dch-for-mime-type-multi](https://stackoverflow.com/questions/21856211/javax-activation-unsupporteddatatypeexception-no-object-dch-for-mime-type-multi) 这个问答里的解决方案

#### 3.2.1、方案一：设置MailcapCommandMap

在具体的发送之前，添加下面这段代码
```java
// Original answer from Som:  
MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap();  
mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html");  
mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml");  
mc.addMailcap("text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain");  
mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed");  
mc.addMailcap("message/rfc822;; x-java-content-handler=com.sun.mail.handlers.message_rfc822");  
  
// Additional elements to make DSN work   
mc.addMailcap("multipart/report;;  x-java-content-handler=com.sun.mail.dsn.multipart_report");  
mc.addMailcap("message/delivery-status;; x-java-content-handler=com.sun.mail.dsn.message_deliverystatus");  
mc.addMailcap("message/disposition-notification;; x-java-content-handler=com.sun.mail.dsn.message_dispositionnotification");  
mc.addMailcap("text/rfc822-headers;;   x-java-content-handler=com.sun.mail.dsn.text_rfc822headers");
```

实测结果：依然没有解决问题

### 3.2.2、方案二： 指定activation版本

```xml
<dependency>  
    <groupId>com.sun.mail</groupId>  
    <artifactId>javax.mail</artifactId>  
    <version>1.6.1</version>  
</dependency>  
  
<dependency>  
    <groupId>javax.activation</groupId>  
    <artifactId>activation</artifactId>  
    <version>1.1.1</version>  
 </dependency>
```

基于上面这种方案，要求我们使用的客户端是`javax.mail`，然而SpringBoot-Email封装是`jakarta,.mail`它做的
```xml
<dependency>  
	<groupId>org.springframework.boot</groupId>  
	<artifactId>spring-boot-starter-mail</artifactId>  
</dependency>
```

放弃了使用这种姿势进行尝试

### 3.2.3、方案三：setContextClassLoader

这种方式比较简单，在执行邮件发送前，添加下面这一行代码
```java
Thread.currentThread().setContextClassLoader(javax.mail.Message.class.getClassLoader());
```

实测结果：可行

根据描述结果来看，主要是通过这一个声明来允许加载`META-INF/mailcap`

> allow javax.activation bundle to load the “META-INF/mailcap” resource from the javax.mail bundle


转载自：[211028-Email发送失败问题记录](https://blog.hhui.top/hexblog/2021/10/28/211028-Email%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/)
