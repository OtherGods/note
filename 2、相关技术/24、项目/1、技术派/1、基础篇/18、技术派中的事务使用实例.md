当我们希望一组操作，要么都成功，要么都失败时，往往会考虑里利用事务来实现这一点；

在实际的工作过程中，事务这个知识点，无论是实际的项目需求场景，还是技术面试，基本上都很难避免；

我们的技术派项目当然也用到了事务，最能体现这一点就是发布文章，它包含：
- 文章表写入
- 文章详情表写入
- 文章标签
- 阅读记录

接下来我们以技术派的应用，来看一下事务的实际使用姿势
# 1、使用实例

直接在技术派中全局搜索 `@Transactional` 注解
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308151959514.png)


然后随意找到一个具体使用的地方，发现使用姿势非常简单，直接在需要的方法上添加 @Transactional注解就完事了
## 1.1、声明式事务使用姿势

以发布/保存文章的逻辑为例，来看一下具体的实现：
```java
/**
 * 保存文章，当articleId存在时，表示更新记录； 不存在时，表示插入
 *
 * @param req
 * @return
 */
 @Transactional(rollbackFor = Exception.class)
 @Override
 public Long saveArticle(ArticlePostReq req, Long author) {
	 ArticleDO article = ArticleConverter.toArticleDo(req, author);
	 String content = imageService.mdImgReplace(req.getContent());
	 if (NumUtil.nullOrZero(req.getArticleId())) {
		 return insertArticle(article, content, req.getTagIds());
	 } else {
		 return updateArticle(article, content, req.getTagIds());
	 }
```

上面这种以@Transactional注解修饰方法的方式，就是我们说的声明式事务方式，通常的使用姿势：
1. 修饰位置：
	1. 在方法上添加注解
	2. 在类上添加注解：===表示这个类的所有公共方法，都支持事务===
2. 注解内属性

| 属性名             | 说明                                                             |
| --------------- | -------------------------------------------------------------- |
| name            | 当在配置文件中有多个TransactionManager，可以用该属性指定选择那么事务管理器                 |
| propagation     | 事务的传播行为，默认值为REQUIRED                                           |
| isolation       | 事务的隔离度，默认值是DEFAULT                                             |
| timeout         | 事务的超时时间，默认值为-1；如果超过该事件限制，但是事务还未完成，则自动回滚事务                      |
| read-only       | 指定事务是否为只读事务，默认值为false；为了忽略那些不需要事务的方法，比如读取数据，可以设置read-only为true |
| rollback-for    | 用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔                  |
| no-rollback-for | 抛出no-rollback-for指定的异常类型，不回滚事务                                 |

**注意：**
1. rollback-for：不是指定具体的异常时，默认只有~~运行时异常~~检查型异常才会触发事务回滚。
2. read-only：指定事务的只读性质，默认值是 `false`，即事务是读写的；`readOnly` 属性用于指示当前事务是只读事务。设置为 `true` 时，Spring 将优化事务以提高性能和稳定性。
	1. **性能优化**：只读事务可以对数据库操作进行优化，例如在某些数据库系统中，可以使用不同的隔离级别，避免对数据进行锁定，减少数据库开销。
	2. **预防性措施**：将事务设置为只读，可以帮助防止意外的写操作（插入、更新、删除等），如果在只读事务中尝试进行写操作（如 `save`、`update`、`delete`），某些数据库（如Oracle）会抛出异常。
	3. **使用场景**：适用于仅进行读取操作的业务逻辑，如查询操作、不涉及数据修改的报告生成等。

举一个简单的例子：
```java
/**
 * 保存文章，当articleId存在时，表示更新记录； 不存在时，表示插入
 *
 * @param req
 * @return
 */
@Transactional
@Override
public Long saveArticle(ArticlePostReq req, Long author) throws Exception {
	ArticleDO article = ArticleConverter.toArticleDo(req, author);
    String content = imageService.mdImgReplace(req.getContent());
    Long ans;
    if (NumUtil.nullOrZero(req.getArticleId())) {
        ans = insertArticle(article, content, req.getTagIds());
    } else {
	    ans = updateArticle(article, content, req.getTagIds());
    }
    throw new Exception("声明异常");
}
```

===上面这个方法执行完毕后，必然会抛出异常，但是sql会正常落库，不会回滚，有兴趣的小伙伴可以自己修改之后实操一下。===

## 1.2、编程式事务使用姿势

上面声明式事务使用姿势，有一个最明显的约束，最小粒度为方法级别，当我们希望在一个方法内的部分代码块进行事务约束时，这个时候就可以使用编程式事务了。

所以上面的实现，有一个明显的可以改进点，String content = imageService.mdImgReplace(req.getContent()); 这一行的图片转存，存在外网图片下载并上传到oss，通常这个比较耗时，完全不需要加入事务中，一般在使用事务的时候，请牢记===最小范围使用原则===。

基于此我们进行编程式事务改造：
1. 首先注入依赖TransactionTemplate
   ```java
@Autowired
private TransactionTemplate transactionTemplate;
   ```
2. 将上面的逻辑改造为编程式事务
   ```java
/**  
 * 保存文章，当articleId存在时，表示更新记录； 不存在时，表示插入  
 *  
 * @param req  
 * @return  
 */  
@Override  
public Long saveArticle(ArticlePostReq req, Long author) {  
    ArticleDO article = ArticleConverter.toArticleDo(req, author);  
    String content = imageService.mdImgReplace(req.getContent());  
    return transactionTemplate.execute(new TransactionCallback<Long>() {  
        @Override  
        public Long doInTransaction(TransactionStatus status) {  
            if (NumUtil.nullOrZero(req.getArticleId())) {  
                Long articleId = insertArticle(article, content, req.getTagIds());  
                log.info("文章发布成功! title={}", req.getTitle());  
                return articleId;  
            } else {  
                Long articleId = updateArticle(article, content, req.getTagIds());  
                log.info("文章更新成功！ title={}", article.getTitle());  
                return articleId;  
            }  
        }  
    });
}
   ```

**说明：以上这段代码已经是编程式事务了**
# 2、小结
## 2.1、两种事务使用姿势对比

我将git的变更历史特意保存了下来，有兴趣的小伙伴可以翻一下：
- [https://github.com/itwanger/paicoding/commit/fbedc3ec83961f36a7dc5e44af06af7c9df5eef2](https://github.com/itwanger/paicoding/commit/fbedc3ec83961f36a7dc5e44af06af7c9df5eef2)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308152039202.png)

从上面的对照，可以更直观体现到两者的写法区别：
1. 声明式：基于AOP方式实现，代码更简介，使用更方便，理解更容易
2. 编程式：非常灵活，完全由用户自己控制，可以最小粒度的控制事务范围

## 2.2、事务使用时注意事项
### 2.2.1、使用场景

首先确定事务的使用场景，什么时候要用事务，不要瞎用，就比如非常简单的只读场景，那么什么场景需要用呢？
	1. 当一个基础的业务单元（如对外提供的http接口，service方法），存在>=2的数据变更时，就需要考虑，部分更新成功、部分更新、是该是否出现脏数据、是否会有影响
		1. 若是：则可以考虑引入事务
		2. 若否：不建议加入事务
	2. 只有一个数据变更，但是后续有更强依赖这个数据的逻辑，也需要加入事务
		1. 比如接到支付成功消息，我们需要做一个校对的后台任务
		2. 我们的业务逻辑是：先调用第三方校验是否属实，然后更新本地状态为成功，最后MQ方式通知订单状态变更
		3. 此时我们需要将第二步数据变更与第三步消息通知放在事务中，只要通知失败，我们还是不更新本地状态，避免出现我们校验成功了，但是订单该是未支付。

### 2.2.2、注意踩坑

特别的，对于声明式注解而言，有好几种使用姿势，会导致事务不生效，请格外注意；详情参考
https://www.yuque.com/itwanger/az7yww/zhf4eukc02tmoeq0

已经转载到：[19、技术派中使用事务的7条注意事项](2、相关技术/24、项目/1、技术派/1、基础篇/19、技术派中使用事务的7条注意事项.md)

### 2.2.3、使用建议

1. 避免大事务，只在需要的地方加事务
2. 注意分布式事务场景
3. 所有的操作走索引，避免出现锁表
4. 减少范围、大批量的数据处理场景
5. 如果业务支撑，可以降低隔离级别，一是减少隔离级别带来的附加成本，二则是可以避免某些场景下的死锁




事务相关系列文章：[https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/%E4%BA%8B%E5%8A%A1/](https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/%E4%BA%8B%E5%8A%A1/)



