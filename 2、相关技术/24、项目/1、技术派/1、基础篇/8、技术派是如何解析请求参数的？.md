这篇文章会介绍技术派中是如何解析请求参数的，这个主题乍一看很简单，其实不然，这个解析过程中会涉及到很多的坑点，比如说：
1. POST请求的参数为JSON字符串的时候，HttpServletRequest能正确获取到参数吗？
2. 如果在切面日志中通过InputStream中读取了参数打印，业务控制器中还能正确获取到参数吗吗？
3. 如果请求参数为文件（图片/视频/音频）时，应该如何正确解析呢？

我们带着这些问题来深入的探讨一下。我会结合技术派的源码以及业务，来带大家彻底搞清楚。

比如说ReqRecordFilter中就对请求参数进行了解析，输出到req-log中。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308121221283.png)

再比如说BodyReaderhttpServletRequestWrapper
会对请求参数的流进行封装，避免请求因为日志的打印提前消耗掉。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308121224707.png)

接下来我们九栋GET请求参数解析来说起，然后是POST请求，最后是我们动手亲自实现一个属于我们自己的参数解析器，相信对你手写小轮子的编码功底有一个较大的提升。

# 1、GET请求参数解析
GET请求是HTTP协议总的一种请求方法，通常用于请求访问指定的资源。很多初学者搞不清楚导师是该用GET还是POST，一般情况下，如果一个请求不会导致服务器上任何资源的状态变化，那么你就可以使用GET请求。
## 1.1、HttpServletRequest.getParameter（……）

我们来看技术派中的一个例子,INdexController
.index方法：
```java
@Controller  
public class IndexController extends BaseViewController {  
    @Autowired  
    private IndexRecommendHelper indexRecommendHelper;  
  
    @GetMapping(path = {"/", "", "/index"})  
    public String index(Model model, HttpServletRequest request) {  
        String activeTab = request.getParameter("category");  
        IndexVo vo = indexRecommendHelper.buildIndexVo(activeTab);  
        model.addAttribute("vo", vo);  
        return "views/home/index";  
    }  
}
```

对应的业务非常简单，单击首页中的分类，会按照分类查询对应的页面信息。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308121231979.png)

这种情况就非常适合GET请求，使用起来也是最简单的。
1. `@GetMapping` 来定义GET请求的路径
2. `HttpServletRequest.getParameter` 方法用来解析GET请求参数。这个方法接收一个字符串参数name，返回与之对应的请求参数的值。如果请求中没有名为name的参数，那么此方法返回null。如果请求中有多个名为name的参数，那么此方法返回其中的第一个值。
此时，请求的 URL 是这样的：`http://127.0.0.1:8080/?category=后端` ，实际上，后端会被编码为 `http://127.0.0.1:8080/?category=%E5%90%8E%E7%AB%AF`
## 1.2、@RequestParam

除了使用HttpServletRequest的getParameter方法，还可以使用@RequestParam注解，@RequestParam是Spring MVC框架中的一个注解，用于从请求中获取参数。它将请求参数绑定到你的控制器方法的参数上。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308121240111.png)

这个注解一共四个参数，最常用的是name（参数名）和required（是否必须），比如说ArticleSettingRestController的operate方法。
```java
@Permission(role = UserRole.ADMIN)  
@GetMapping(path = "operate")  
public ResVo<String> operate(@RequestParam(name = "articleId") Long articleId, @RequestParam(name = "operateType") Integer operateType) {  
    OperateArticleEnum operate = OperateArticleEnum.fromCode(operateType);  
    if (operate == OperateArticleEnum.EMPTY) {  
        return ResVo.fail(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, operateType + "非法");  
    }  
    articleSettingService.operateArticle(articleId, operate);  
    return ResVo.ok("ok");  
}
```

在pai-admin的前端，我们对GET请求进行了封装，主要是通过axios（Axios 是一个基于promise 的HTTP 库，简单的讲就是可以发送get、post请求）来完成，这块我们会放在前端篇中进行讲解，这里我们先记住有这么一件事情
```java
export const operateArticleApi = (params: object | undefined) => {
	return http.get<Login.ResAuthButtons>(`${PORT1}/article/operate`, params);
};
```

下面给出一些复杂类型的参数，比如说枚举、Map、List的实例，大家可以在自己本地实验一下：
```java
//枚举类
public enum TYPE{
	A,B,C;
}

//————————参数类型为枚举————————
@GetMapping(path = "enum")
public String enumParam(TYPE type) {
    return type.name();
}
@GetMapping(path = "enum2")
public String enumParam2(@RequestParam TYPE type) {
    return type.name();
}

//————————参数类型为Map————————
@GetMapping(path = "mapper")
public String mapperParam(@RequestParam Map<String, Object> params) {
    return params.toString();
}
// 注意下面这个写法，无法正常获取请求参数，这里用来对比列出
@GetMapping(path = "mapper2")
public String mapperParam2(Map<String, Object> params) {
    return params.toString();
}

//————————参数类型为List————————
@GetMapping(path = "ano1")
public String anoParam1(@RequestParam(name = "names") List<String> names) {
    return "name: " + names;
}
// 注意下面这个写法无法正常解析数组
@GetMapping(path = "arg3")
public String anoParam2(List<String> names) {
    return "names: " + names;
}
```

写一个控制器，请求路径为get，然后通过curl进行测试。

> curl是一个强大的命令行工具，用于获取或发送数据，支持多种协议，包括HTTP、HTTPS、FTP、FTPS、SFTP等。例如我们可以这样发送一个GET请求：curl http://paicoding.com

传递的方法如下所示：
```java
➜  ~ curl 'http://localhost:8080/get/enum?type=A'
A%

➜  ~ curl 'http://localhost:8080/get/enum2?type=A'
A%

➜  ~ curl 'http://localhost:8080/get/mapper?type=A&age=3'
{type=A, age=3}%

➜  ~ curl 'http://localhost:8080/get/mapper2?type=A&age=3'
{}%

➜  ~ curl 'http://localhost:8080/get/ano1?names=yi,hui,ha'
name: [yi, hui, ha]%

➜  ~ curl 'http://localhost:8080/get/arg3?names=yi,hui,ha' -i
HTTP/1.1 500
Content-Length: 0
Date: Sat, 24 Aug 2019 13:50:55 GMT
Connection: close
```

## 1.3、@PathVariable

@PathVariable是SpringMVC中的一个注解，可以将URL中的占位符参数绑定到控制器处理方法的参数上。

来看ArticleViewController的detail方法：
```java
/**  
 * 文章详情页  
 * - 参数解析知识点  
 * - fixme * [1.Get请求参数解析姿势汇总 | 一灰灰Learning](https://hhui.top/spring-web/01.request/01.190824-springboot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8Bweb%E7%AF%87%E4%B9%8Bget%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB/)  
 *  
 * @param articleId  
 * @return  
 */  
@GetMapping("detail/{articleId}")  
public String detail(@PathVariable(name = "articleId") Long articleId, Model model) {  
    ArticleDetailVo vo = new ArticleDetailVo();  
    // 文章相关信息  
    ArticleDTO articleDTO = articleService.queryTotalArticleInfo(articleId, ReqInfoContext.getReqInfo().getUserId());  
    // 返回给前端页面时，转换为html格式  
    articleDTO.setContent(MarkdownConverter.markdownToHtml(articleDTO.getContent()));  
    vo.setArticle(articleDTO);  
  
    // 评论信息  
    List<TopCommentDTO> comments = commentService.getArticleComments(articleId, PageParam.newPageInstance(1L, 10L));  
    vo.setComments(comments);  
  
    // 热门评论  
    TopCommentDTO hotComment = commentService.queryHotComment(articleId);  
    vo.setHotComment(hotComment);  
  
    // 作者信息  
    UserStatisticInfoDTO user = userService.queryUserInfoWithStatistic(articleDTO.getAuthor());  
    articleDTO.setAuthorName(user.getUserName());  
    articleDTO.setAuthorAvatar(user.getPhoto());  
    vo.setAuthor(user);  
  
    // 详情页的侧边推荐信息  
    List<SideBarDTO> sideBars = sidebarService.queryArticleDetailSidebarList(articleDTO.getAuthor(), articleDTO.getArticleId());  
    vo.setSideBarItems(sideBars);  
    model.addAttribute("vo", vo);  
  
    SpringUtil.getBean(SeoInjectService.class).initColumnSeo(vo);  
    return "views/article-detail/index";  
}
```

1.  `@GetMapping("detail/{articleId}")` 中的 `{articleId}` 是一个占位符，可以表示任何的文章ID
2.  `@PathVariable(name = "articleId") Long articleId` 获取这个文章ID，并将其值绑定到articleId参数上。

对应的业务访问任意一篇文章详情。

# 2、POST请求参数解析

与GET请求用于获取资源不同，POST请求主要用于提交数据到服务端。尤其是表单提交、文件上传等场景。

POST请求的数据通常放在请求体中，而不是向GET请求那样放在URL中。这意味着我们可以发送更大量的数据，数据类型也更加丰富，如文本、JSON、XML、二进制数据等。

## 2.1、HttpServletRequest.getParameter(……)

同样可以向GET请求那样使用HttpServletRequest获取POST的请求参数，我们在TestController中新增一个方法，内容如下所示：
```java
@PostMapping(path = "testPost")
public String testPost(HttpServletRequest request) {
    String name = request.getParameter("name");
    String age = request.getParameter("age");
    return "name=" + name + ", age=" + age;
}
```

1. @PostMapping(path = "testPost") 指定 POST 请求路径
2. HttpServletRequest.getParameter 方法获取 name 和 age 参数。
然后我们在IDEA中打开搜索对话框输入curl打开HTTP Client工具
![](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308121700205.png)

输入以下内容进行访问
```java
POST http://127.0.0.1:8080/test/testPost
Content-Type: application/x-www-form-urlencoded

name=沉默王二&age=18
```

可以看到参数正常解析出来了。
![](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308121701992.png)

回到教程一开头提到的问题：**POST请求的参数为JSON字符串的时候，HttpServletRequest能正确获取到参数吗？**

我们来验证一下，增加一个testPostJson的方法：
```java
@PostMapping(path = "testPostJson")
public String testPostJson(HttpServletRequest request) {
    return JsonUtil.toStr(request.getParameterMap());
}
```

通过JSON的方式传递参数：
```java
POST http://localhost:8080/test/testPostJson
Content-Type: application/json  
  
{  
  "name": "沉默王二",  
  "age": 18
}
```

执行Post请求，我们会发现结果没有输出出来
```java
POST http://localhost:8080/test/testPostJson

HTTP/1.1 200 
g-trace-id: c0a8ad22.1691842699892.173561005
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
Access-Control-Allow-Methods: POST, GET, OPTIONS, PUT, DELETE, HEAD
Access-Control-Max-Age: 3600
Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, X-Real-IP, X-Forwarded-For, d-uuid, User-Agent, x-zd-cs, Proxy-Client-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR
Content-Type: application/json
Content-Length: 2
Date: Sat, 12 Aug 2023 12:18:20 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{}

Response code: 200; Time: 1011ms; Content length: 2 bytes

Cookies are preserved between requests:
> D:\IntelliJ\java_code_doc_1\forumcoding\.idea\httpRequests\http-client.cookies
```

为什么呢？
request.getParameterMap(String name)方法可以用于获取HTTP请求中的参数，但是，这个方法通常用于获取GET请求中的参数或 `application/x-www-form-urlencoded` 编码的POST请求参数。

如果POST请求中的参数是JSON格式的，那么这些参数通常位于body中，getParameter()方法无法直接获取这些参数。

那怎么办呢？

如果非要使用HttpServletRequest来获取的话，我们需要读取整个请求体：
```java
// POST 请求，使用 HttpServletRequest 获取 JSON 请求参数  
@PostMapping(path = "testPostJson2")  
public String testPostJson2(HttpServletRequest request) {  
    StringBuilder sb = new StringBuilder();  
    try (BufferedReader reader = request.getReader()) {  
        String line;  
        while ((line = reader.readLine()) != null) {  
            sb.append(line);  
        }  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
  
    return sb.toString();  // body中即是JSON格式的请求参数  
}
```

此时就可以获取到参数了。
```java
POST http://localhost:8080/test/testPostJson2

HTTP/1.1 200 
Set-Cookie: JSESSIONID=A5C93D890D32B89B0BBFE228B9281553; Path=/; HttpOnly
g-trace-id: c0a8ad22.1691845647225.204361000
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
Access-Control-Allow-Methods: POST, GET, OPTIONS, PUT, DELETE, HEAD
Access-Control-Max-Age: 3600
Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, X-Real-IP, X-Forwarded-For, d-uuid, User-Agent, x-zd-cs, Proxy-Client-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR
Content-Type: application/json
Content-Length: 38
Date: Sat, 12 Aug 2023 13:07:28 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
  "name": "沉默王二",
  "age": 18
}

Response code: 200; Time: 1785ms; Content length: 30 bytes

Cookies are preserved between requests:
> D:\IntelliJ\java_code_doc_1\forumcoding\.idea\httpRequests\http-client.cookies

```

## 2.2、HttpServletRequestWrapper

回到教程一开头的问题：**如果在切面日志中通过InputStream中读取了参数打印，业务控制器中还能正确获得参数吗？**

答案是：如果不多处理的话，读取不到。

底层涉及到Java的输入输出流。当我们从输入流中读取数据时，实际上是在消耗数据，就是像我们把水喝入肚子里一样，一定那数据被读取出来，就不能再次读取了。

从技术角度来看，当我们从输入流中读取数据时，读取的位置（通常成为“游标”或者“指针”）会向前移动。当读取完所有数据后，游标机移动到流的末尾，所以不能再次读取到更多的数据了。

技术派已经做过这方面的处理了，答案就在BodyReaderHttpServletRequestWrapper类中，它继承了HttpServletRequestWrapper，该包装类会读取并缓存请求body。

为了验证上面提到的结论，我们可以这样做：
1. 第一步：ReqRecordFilter的initReqInfo方法中注释掉 `request = this.wrapperRequest(request, reqInfo)` 这行代码
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308130002741.png)

2. 第二步：在TestController中增加一个testPostJson3的方法，里面读取了两次request
   ```java
@PostMapping(path = "testPostJson3")  
public String testPostJson3(HttpServletRequest request) {  
    StringBuilder sb = new StringBuilder();  
    try (BufferedReader reader = request.getReader()) {  
        String line;  
        while ((line = reader.readLine()) != null) {  
            sb.append(line);  
        }  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
  
    log.info("testPostJson3 第一次: {}", sb);  
  
    StringBuilder sb1 = new StringBuilder();  
    try (BufferedReader reader = request.getReader()) {  
        String line;  
        while ((line = reader.readLine()) != null) {  
            sb1.append(line);  
        }  
    } catch (Exception e) {  
        e.printStackTrace();  
    }  
  
    log.info("testPostJson3 第二次: {}", sb1);  
  
    return sb1.toString();  // body中即是JSON格式的请求参数  
}
   ```
3. 第三步：再次请求testPostJson3接口
   ```java
POST http://localhost:8080/test/testPostJson3  
Content-Type: application/json  
  
{  
  "name": "沉默王二",  
  "age": 18
}
   ```
   可以看到结果如下：没有解析到请求参数
   ```java
POST http://localhost:8080/test/testPostJson3

HTTP/1.1 200 
g-trace-id: c0a8ad22.1691856546162.098641002
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: false
Access-Control-Allow-Methods: POST, GET, OPTIONS, PUT, DELETE, HEAD
Access-Control-Max-Age: 3600
Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, X-Real-IP, X-Forwarded-For, d-uuid, User-Agent, x-zd-cs, Proxy-Client-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR
Content-Type: application/json
Content-Length: 0
Date: Sat, 12 Aug 2023 16:09:06 GMT
Keep-Alive: timeout=60
Connection: keep-alive

<Response body is empty>

Response code: 200; Time: 982ms; Content length: 0 bytes

Cookies are preserved between requests:
> D:\IntelliJ\java_code_doc_1\forumcoding\.idea\httpRequests\http-client.cookies
   ```

   控制台打印的日志如下：打印出的结果可以验证这个结论，第一个可以读到，第二次读不到了，也就意味着当处理HTTP请求时，我们只能读取请求body一次，然后数据就会被清除——>
```java
2023-08-13 00:05:17,411 [http-nio-8080-exec-8] INFO |c0a8ad22.1691856316911.098641001||c.g.p.f.w.f.test.rest.TestController.testPostJson3(TestController.java:145) - testPostJson3 第一次: {  "name": "沉默王二",  "age": 18}
2023-08-13 00:05:17,412 [http-nio-8080-exec-8] INFO |c0a8ad22.1691856316911.098641001||c.g.p.f.w.f.test.rest.TestController.testPostJson3(TestController.java:157) - testPostJson3 第二次: 
Creating a new SqlSession
SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@32116175] was not registered for synchronization because synchronization is not active
java.io.IOException: Stream closed
	at org.apache.catalina.connector.InputBuffer.throwIfClosed(InputBuffer.java:526)
	at org.apache.catalina.connector.InputBuffer.mark(InputBuffer.java:488)
	at org.apache.catalina.connector.CoyoteReader.mark(CoyoteReader.java:135)
	at org.apache.catalina.connector.CoyoteReader.readLine(CoyoteReader.java:161)
	at com.github.paicoding.forum.web.front.test.rest.TestController.testPostJson3(TestController.java:150)
```



关于ReqRecordFilter（见本篇教程一开始），我们在AOP实现日志切面的教程里面提到过，它会把请求参数解析保存到req-log日志中。那么我们放开HtteServletRequestWrapper的处理（也就是打开第一步中的注释）。

再次请求testPostJson3接口，就会发现，能读取到结果了：
![](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308130024806.png)

日志中也可以验证
![](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308130025276.png)

那为什么HttpServetRequestWrapper能做到这一点呢？

那就需要来说到说到HttpServletRequestWrapper了。

HttpServletRequestWrapper是一个实现了HttpServletRequest接口的类，它被设计成一个装饰器（Decorator）类，主要用于对HttpServletRequest对象进行包装，提供一种修改请求对象的方式。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308130044802.png)

HttpServletRequestWrapper类的主要作用是在不修改原始请求对象的情况下，提供一种方式来修改请求中的信息，例如请求头或请求参数。

技术派中的 BodyReaderHttpServletRequestWrapper 就是 HttpServletRequestWrapper 类的一个具体实现，主要用于读取和缓存 HTTP 请求的 body。


我们来具体分析一下：
1. 构造方法，根据请求的内容类型和方法读取并缓存请求body
   ```java
public BodyReaderHttpServletRequestWrapper(HttpServletRequest request) {  
    super(request);  
  
    if (POST_METHOD.contains(request.getMethod()) && !isMultipart(request) && !isBinaryContent(request) && !isFormPost(request)) {  
        bodyString = getBodyString(request);  
        body = bodyString.getBytes(StandardCharsets.UTF_8);  
    } else {  
        bodyString = null;  
        body = null;  
    }  
}
   ```
2. 重写了getReader和getInputStream方法，使得每次调用都会返回一个新的输入流或读取器，指向同一个缓存的请求body。这样，我们就可以多起读取请求body了。
      ```java
@Override  
public BufferedReader getReader() throws IOException {  
    return new BufferedReader(new InputStreamReader(getInputStream()));  
}  
  
@Override  
public ServletInputStream getInputStream() throws IOException {  
    if (body == null) {  
        return super.getInputStream();  
    }  
  
    final ByteArrayInputStream bais = new ByteArrayInputStream(body);  
    return new ServletInputStream() {  
        @Override  
        public int read() throws IOException {  
            return bais.read();  
        }  
  
        @Override  
        public boolean isFinished() {  
            return false;  
        }  
  
        @Override  
        public boolean isReady() {  
            return true;  
        }  
  
        @Override  
        public void setReadListener(ReadListener readListener) {  
        }  
    };  
}
      ```
3. hasPayload方法返回一个布尔值，表示是否存在请求body
   ```java
public boolean hasPayload() {
    return bodyString != null;
}
   ```
4. getBodyString方法返回缓存的请求body
   ```java
private String getBodyString(HttpServletRequest request) {  
    BufferedReader br;  
    try {  
        br = request.getReader();  
    } catch (IOException e) {  
        logger.warn("Failed to get reader", e);  
        return "";  
    }  
  
    String str;  
    StringBuilder body = new StringBuilder();  
    try {  
        while ((str = br.readLine()) != null) {  
            body.append(str);  
        }  
    } catch (IOException e) {  
        logger.warn("Failed to read line", e);  
    }  
  
    try {  
        br.close();  
    } catch (IOException e) {  
        logger.warn("Failed to close reader", e);  
    }  
  
    return body.toString();  
}
   ```

## 2.3、@RequestBody

该注解将请求体绑定到一个方法参数上。通常用于处理POST、PUT等方法的请求，这些请求通常会在请求体中发送数据。在方法参数上添加@RequestBody注解，Spring会使用一个HttpMessageConverter将请求体转换为对应的Java对象。

HttpMessageConverter使用请求头中的Content-Type字段来决定如何解析请求体，例如，如果Content-Type是 `application/json` 那么将使用JSON转换器将请求体解析为Java对象。

技术派中使用的是MappingJackson2HttpMessageConverter和MappingJackJson2XmlHttpMessageConverter，用于对JSON和XML进行转换。

1. MappingJackson2HttpMessageConverter：此转换器用于将HTTP请求或响应体中的JSON数据转换为Java对象，或将Java对象转换为JSON数据。它使用[Jackson](2、相关技术/24、项目/1、技术派/4、补充/补2_Jackson：GitHub上star数最多的JSON解析库.md)库来进行转换，Jackson是一个可以将Java对象与JSON字符串相互转换的库。
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308131107156.png)
2. MappingJackson2XmlHttpMessageConverter：此转换器用于将HTTP请求或响应体中的XML数据据转换为Java独享，或者将Java对象转换为XML数据。他也使用Jackson库来进行转换，但是使用的是Jackson中处理XML数据的部分。
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308131111418.png)

### 技术派中使用@RequestBody注解实例

技术派中有很多使用@RequestBody注解实例的，随便搜索一下就能看到：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308131113929.png)

先看第一处使用@RequestBody的地方
```java
@PostMapping(path = "save")  
public ResVo<String> save(@RequestBody TagReq req) {  
    tagSettingService.saveTag(req);  
    return ResVo.ok("ok");  
}
```
1. @PostMapping注解：用于指定POST请求路径
2. @RequestBody注解：用于将POST请求参数绑定到方法参数上。

本例中 TagReq 是一个使用了 Lombok 库的 Requst 对象。
```java
/**  
 * 保存Tag请求参数  
 *  
 * @author LouZai  
 * @date 2022/9/17  
 */@Data  
public class TagReq implements Serializable {  
  
    /**  
     * ID     */    private Long tagId;  
  
    /**  
     * 标签名称  
     */  
    private String tag;  
  
    /**  
     * 类目ID  
     */    private Long categoryId;  
}
```

对应的业务是admin端保存标签。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308131328429.png)

## 2.4、MultipartFile

MultipartFile是Spring中处理文件上传的一个接口。当我们通过mutipart/form-data形式的HTTP POST请求上传文件时，Spring MVC，会将上传的文件包装成MultipartFile对象。

MultipartFile接口提供了一系列方法，可以方便的获取上传文件的信息和内容：
1. getOriginalFilename()：获取客户端发送的原始文件名
2. getName()：获取表单中文件组件的名字
3. isEmpty()：返回上传的文件是否为空
4. getSize()：返回上传的文件的大小，单位是字节
5. getContentType()：返回文件的MIME类型
6. getBytes()：返回文件的内容，以字节数组的形式
7. getInputStream()：返回一个InputStream，可以从中读取文件的内容
8. transferTo(File dest)：将上传的文件保存到一个目标文件或者目录

我们可以通过@RequestParam注解的形式直接获取一个MutipartFile对象，例如：
```java
@PostMapping("/upload")
public String handleFileUpload(@RequestParam("file") MultipartFile file) {
    String originalFilename = file.getOriginalFilename();
    // ...
}
```

技术派中是通过MultipartHttpServletRequest的方式从POST请求中获取文件对象的，在讲本地上传图片的教程中有详细的讲过，这里就简单带一笔。

MultipartHttpServletRequest是SpringMVC提供的一个接口，它用于处理multipart/form-data类型的HTTP请求，也就是常见的文件上传请求。
```java
@Override  
public String saveImg(HttpServletRequest request) {  
    MultipartFile file = null;  
    if (request instanceof MultipartHttpServletRequest) {  
        file = ((MultipartHttpServletRequest) request).getFile("image");  
    }  
    if (file == null) {  
        throw ExceptionUtil.of(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "缺少需要上传的图片");  
    }  
  
    // 目前只支持 jpg, png, webp 等静态图片格式  
    String fileType = validateStaticImg(file.getContentType());  
    if (fileType == null) {  
        throw ExceptionUtil.of(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "图片只支持png,jpg,gif");  
    }  
  
    try {  
        return imageUploader.upload(file.getInputStream(), fileType);  
    } catch (IOException e) {  
        log.error("Parse img from httpRequest to BufferedImage error! e:", e);  
        throw ExceptionUtil.of(StatusEnum.UPLOAD_PIC_FAILED);  
    }  
}
```
# 3、小结

在一个WEB应用中，处理HTTP请求参数是非常常见的任务。常见的解析请求参数的方式有：
1. 通过 `HttpServletRequest` ：可以使用 `request.getParameter(name)` 来获取GET或POST请求中的参数
2. 使用 `@RequestParam` 注解来获取请求参数
3. 如果URL中包含路径变量，比如 `/user/{id}` ，你可以使用 `@PathVariable` 注解获取这个路径变量的值
4. 如果请求的Content-Type为application/json，可以使用 `@RequestBody` 注解将请求中的JSON数据自动绑定到一个Java对象上
5. 对于文件上传请求，可以使用 `MultipartHttpServletRequest` 或者  `MultipartFile` 来获取上传的文件

并且我们在这个过程中穿插讲了两个非常重要的问题，你现在能答得上来吗？
1. POST 请求的参数为 JSON 字符串的时候，HttpServletRequest 能正确获取到参数吗？
2. 如果在切面日志中通过 InputStream 中读取了参数打印，业务控制器中还能正确获得到参数吗？






