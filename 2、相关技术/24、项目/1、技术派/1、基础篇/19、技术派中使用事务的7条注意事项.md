#事务失效 #事务不生效案例 

针对声明式事务@Transactional的使用姿势，只知道正确的使用姿势可能还不够，还得知道什么场景下不生效，避免踩坑。本文将结合一个简单的demo，来主要介绍让事务不生效的几种case。

# 1、配置

本文的case，将使用声明式事务，首先我们创建一个SpringBoot项目，版本2.2.1RELEASE，使用mysql作为目标数据库，存储殷勤选择Innodb，事务隔离级别为RR。

## 1.1、项目配置

在项目pom.xml文件中，加上spring-boot-starter-jdbc，会注入一个DataSourceTransactionManager的bean，提供了事务支持
```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

## 1.2、数据库配置

进入spring配置文件application.properties，设置下db相关信息
```properties
## DataSource
spring.datasource.url=jdbc:mysql://localhost:3306/${database.name}?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=
```

## 1.3、数据库

新建一个简单的表结构，用于测试
```sql
CREATE TABLE `money` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL DEFAULT '' COMMENT '用户名',
  `money` int(26) NOT NULL DEFAULT '0' COMMENT '钱',
  `is_deleted` tinyint(1) NOT NULL DEFAULT '0',
  `create_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=551 DEFAULT CHARSET=utf8mb4;
```

# 2、不生效case

对照：
[我认真总结并分析了Spring事务失效的十种常见场景](2、相关技术/15、常用框架-SSM+SpringSecurity/补9、事务/我认真总结并分析了Spring事务失效的十种常见场景.md)
[4、事务不生效的几种case](2、相关技术/15、常用框架-SSM+SpringSecurity/补9、事务/4、事务不生效的几种case.md)

在声明式事务的教程 [200119-SpringBoot系列教程之声明式事务Transactional](http://spring.hhui.top/spring-blog/2020/01/19/200119-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1Transactional/) 中，也提到了一些事务不生效的方式，比如声明式事务注解@Transactional主要是结合代理实现，结合AOP知识点，至少可以得出放在私有方法上，类内部调用都不会生效，下面进行详细说明。
## 1.1、数据库

事务生效的前提是你的数据源得支持事务，比如mysql的MyISAM引擎不支持事务，而Innodb支持事务

下面的case都是基于mysql+Innodb引擎

为后续的演示case，我们准备一些数据如下：
```java
@Service
public class NotEffectDemo {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @PostConstruct
    public void init() {
        String sql = "replace into money (id, name, money) values" + " (520, '初始化', 200)," + "(530, '初始化', 200)," +
                "(540, '初始化', 200)," + "(550, '初始化', 200)";
		jdbcTemplate.execute(sql);
    }
}    
```

## 1.2、类内部访问


简单来讲就是非直接访问带注解标记的方法B，而是通过普通类普通方法A，然后由A访问B

下面是一个简单的case
```java
/**
 * 非直接调用，不生效
 *
 * @param id
 * @return
 * @throws Exception
 */
 @Transactional(rollbackFor = Exception.class)
public boolean testCompileException2(int id) throws Exception {
    if (this.updateName(id)) {
	    this.query("after update name", id);
        if (this.update(id)) {
            return true;
        }
    }
    throw new Exception("参数异常");
}

public boolean testCall(int id) throws Exception {
    return testCompileException2(id);
}
```

上面两个方法，直接调用testCompleException方法，事务正常操作；若是通过调用testCall间接访问，则不生效。

测试case如下：
```java
@Component
public class NotEffectSample {
    @Autowired
    private NotEffectDemo notEffectDemo;
    
    public void testNotEffect() {
        testCall(530, (id) -> notEffectDemo.testCall(530));
    }
    
    private void testCall(int id, CallFunc<Integer, Boolean> func) {
        System.out.println("============ 事务不生效case start ========== ");
        notEffectDemo.query("transaction before", id);
        try {
	        // 事务可以正常工作
            func.apply(id);
        } catch (Exception e) {
        }
        notEffectDemo.query("transaction end", id);
        System.out.println("============ 事务不生效case end ========== \n");
    }
    
    @FunctionalInterface
    public interface CallFunc<T, R> {
        R apply(T t) throws Exception;
    }
}
```

输出结果如下：
```java
============ 事务不生效case start ========== 
transaction before >>>> {id=530, name=初始化, money=200, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
after update name >>>> {id=530, name=更新, money=200, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
transaction end >>>> {id=530, name=更新, money=210, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
============ 事务不生效case end ==========
```

从上面的输出可以看到，事务并没有回滚，主要是因为类内部调用，不会通过代理方式访问

针对这种场景，一般的解决方法：
```java
// 通过代理的方式来访问

public boolean testCall(int id) throws Exception {
    return SpringUtil.getBean(this.getClass()).testCompileException2(id);
}
```


## 1.3、私有方法

这种场景和 [1.2、类内部访问](2、相关技术/24、项目/1、技术派/1、基础篇/19、技术派中使用事务的7条注意事项.md#1.2、类内部访问) 也是同一种原因，动态代理设计模式生成的动态代理类和目标类之前的关系我认为类似装饰器模式，在动态代理类不一定能发现目标类中的非public方法（访问权限修饰符），所以目标类中的私有方法有事注解务修饰时即使异常也不会回滚。

在私有方法上，添加@Transactional注解也不会生效，私有方法外部不能访问，所以只能内部访问，上面的case不生效，这个当然也不生效了。
```java
/**
 * 私有方法上的注解，不生效
 *
 * @param id
 * @return
 * @throws Exception
 */
@Transactional
private boolean testSpecialException(int id) throws Exception {
	if (this.updateName(id)) {
        this.query("after update name", id);
        if (this.update(id)) {
            return true;
        }
    }
    throw new Exception("参数异常");
}
```

直接使用时，下面这种场景不太容易出现，因为IDEA会有提醒，文案为：`Methods annotated with '@Transactional' must be overridable`

## 1.4、异常不匹配

`@Transactional` 注解默认处理运行时异常，即只抛出运行时异常时，才会触发事务回滚，否则不会滚
```java
/**
 * 非运行异常，且没有通过 rollbackFor 指定抛出的异常，不生效
 *
 * @param id
 * @return
 * @throws Exception
 */
 @Transactional
public boolean testCompleException(int id) throws Exception {
    if (this.updateName(id)) {
	    this.query("after update name", id);
        if (this.update(id)) {
            return true;
        }
    }
    throw new Exception("参数异常");
}
```

测试case如下：
```java
public void testNotEffect() {
    testCall(520, (id) -> notEffectDemo.testCompleException(520));
}
```

输出如下，事务并未回滚（如果需要解决这个问题，可以通过设置@Transactional注解的rollbackFor属性）
```java
============ 事务不生效case start ========== 
transaction before >>>> {id=520, name=初始化, money=200, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
after update name >>>> {id=520, name=更新, money=200, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
transaction end >>>> {id=520, name=更新, money=210, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
============ 事务不生效case end ==========
```

## 1.5、多线程

这个场景可能并不多见，在标记事务的方法内部，另起子线程执行db操作，此时事务同样不会生效

下main给出两个不同的姿势，一个是子线程抛异常，主线程ok；一个是子线程ok，主线程抛出异常。

### 1.5.1、case1

```java
/**
 * 子线程抛异常，主线程无法捕获，导致事务不生效
 *
 * @param id
 * @return
 */
 @Transactional(rollbackFor = Exception.class)
public boolean testMultThread(int id) throws InterruptedException {
    new Thread(new Runnable() {
	    @Override
        public void run() {
            updateName(id);
            query("after update name", id);
        }
    }).start();
    
    new Thread(new Runnable() {
        @Override
        public void run() {
            boolean ans = update(id);
            query("after update id", id);
            if (!ans) {
	            throw new RuntimeException("failed to update ans");
            }
        }
    }).start();
    
    Thread.sleep(1000);
    System.out.println("------- 子线程 --------");

    return true;
}
```

上面这种场景不生效很好理解，子线程的异常不会被外部的线程捕获，`testMulThread`这个方法的调用不抛异常，因此不会触发事务回滚
```java
public void testNotEffect() {
    testCall(540, (id) -> notEffectDemo.testMultThread(540));
}
```

输出结果如下：
```java
============ 事务不生效case start ========== 
transaction before >>>> {id=540, name=初始化, money=200, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
after update name >>>> {id=540, name=更新, money=200, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
Exception in thread "Thread-3" java.lang.RuntimeException: failed to update ans
	at com.git.hui.boot.jdbc.demo.NotEffectDemo$2.run(NotEffectDemo.java:112)
	at java.lang.Thread.run(Thread.java:748)
after update id >>>> {id=540, name=更新, money=210, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
------- 子线程 --------
transaction end >>>> {id=540, name=更新, money=210, is_deleted=false, create_at=2020-02-03 13:44:11.0, update_at=2020-02-03 13:44:11.0}
============ 事务不生效case end ==========
```

### 1.5.2、case2

```java
/**
 * 子线程抛异常，主线程无法捕获，导致事务不生效
 *
 * @param id
 * @return
 */
@Transactional(rollbackFor = Exception.class)
public boolean testMultThread2(int id) throws InterruptedException {
    new Thread(new Runnable() {
        @Override
        public void run() {
            updateName(id);
            query("after update name", id);
		}
	}).start();
	
	new Thread(new Runnable() {
        @Override
        public void run() {
            boolean ans = update(id);
            query("after update id", id);
		}
	}).start();
	
	Thread.sleep(1000);
    System.out.println("------- 子线程 --------");

    update(id);
    query("after outer update id", id);
    
    throw new RuntimeException("failed to update ans");
}
```

上面这个看着好像没有问题，抛出异常，事务回滚，可以两个子线程的修改并不会被回滚。

测试代码：
```java
public void testNotEffect() {
    testCall(550, (id) -> notEffectDemo.testMultThread2(550));
}
```

从下面的输出也可以知道，子线程的修改并不在一个事务内，不会被回滚
```java
============ 事务不生效case start ========== 
transaction before >>>> {id=550, name=初始化, money=200, is_deleted=false, create_at=2020-02-03 13:52:38.0, update_at=2020-02-03 13:52:38.0}
after update name >>>> {id=550, name=更新, money=200, is_deleted=false, create_at=2020-02-03 13:52:38.0, update_at=2020-02-03 13:52:40.0}
after update id >>>> {id=550, name=更新, money=210, is_deleted=false, create_at=2020-02-03 13:52:38.0, update_at=2020-02-03 13:52:40.0}
------- 子线程 --------
after outer update id >>>> {id=550, name=更新, money=220, is_deleted=false, create_at=2020-02-03 13:52:38.0, update_at=2020-02-03 13:52:41.0}
transaction end >>>> {id=550, name=更新, money=210, is_deleted=false, create_at=2020-02-03 13:52:38.0, update_at=2020-02-03 13:52:40.0}
============ 事务不生效case end ==========
```

## 1.6、传播属性

上一篇关于传播属性的博文中，介绍了其中有几种是不走事务执行的，所以也需要额外注意下，详情参考文章：[200202-SpringBoot系列教程之事务传递属性](http://spring.hhui.top/spring-blog/2020/02/02/200202-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%8B%E5%8A%A1%E4%BC%A0%E9%80%92%E5%B1%9E%E6%80%A7/)

## 1.7、没有被Spring管理的类

即我们使用的类，并不是由Spring来进行管理的，如：
```java
public class DemoService {
    @Transactional
    public boolean testSpecialException(int id) throws Exception {
	    if (this.updateName(id)) 
	    {
			this.query("after update name", id);
			if (this.update(id)) {
				return true;
			}
		}
		throw new Exception("参数异常");
	}
}

@Service
public class DemoService2 {
	DemoService demoService = new DemoService();
    public void test() {
    	demoService.testSpecialException(1);
    }
}
```

由于上面的DemoService并不是由于Spring管理，所以并不会生成对应的代理类，事务自然也不会生效。
## 1.8、小结

下面小结几种@Transactional注解事务不生效的case
1. 数据库不支持事务
2. 注解放在了私有方法上
3. 方法调用类内部的方法
4. 未捕获异常
5. 多线程场景
6. 传播属性设置问题


关联博文：
- [200119-SpringBoot系列教程之声明式事务Transactional](http://spring.hhui.top/spring-blog/2020/01/19/200119-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1Transactional/)
- [200120-SpringBoot系列教程之事务隔离级别知识点小结](http://spring.hhui.top/spring-blog/2020/01/20/200120-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93/)
- [200202-SpringBoot系列教程之事务传递属性](http://spring.hhui.top/spring-blog/2020/02/02/200202-SpringBoot%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%8B%E5%8A%A1%E4%BC%A0%E9%80%92%E5%B1%9E%E6%80%A7/)

对应源码：
- 工程：[https://github.com/liuyueyi/spring-boot-demo](https://github.com/liuyueyi/spring-boot-demo)
- 实例源码: https://github.com/liuyueyi/spring-boot-demo/blob/master/spring-boot/101-jdbctemplate-transaction 
    已经将这个项目Fork到我的GitHub：[https://github.com/OtherGods/paicoding-yihui-spring-boot-demo](https://github.com/OtherGods/paicoding-yihui-spring-boot-demo)



事务相关系列文章：[https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/%E4%BA%8B%E5%8A%A1/](https://spring.hhui.top/spring-blog/categories/SpringBoot/DB%E7%B3%BB%E5%88%97/%E4%BA%8B%E5%8A%A1/)