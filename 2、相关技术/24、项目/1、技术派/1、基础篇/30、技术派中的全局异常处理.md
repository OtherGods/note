
今天由我来给大家讲一下技术派中的全局异常处理，全局异常处理是 Java 后端开发中不可或缺得有一部分，可以提高代码的健壮性和可维护性。

在我们的开发中，总是难免会碰到一些未经处理的异常，假如没有做全局异常处理，那么我们返回给用户的信息应该是不友好的，很抽象的，用户会认为我们的程序是不安全的。

相反0的反馈。

甚至可以把全局异常处理写到简历上，比如说你可以这样描述：项目采用了HandlerExceptionResolver（或者ControllerAdvice方案）的全局异常处理策略，提高了代码的健壮性和可维护性，优化了用户体验。

之后会结合业务场景介绍HandlerExceptionResolver与ControllerAdivce在项目中的使用。

# 1、业务场景

技术派整合了Redis，比如说用户登录的时候从Redis中获取缓存，假如我们本地没有启动Redis服务：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012041077.png)

我们在本地启动技术派的服务端：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012042327.png)

之后点击登录页面中的一键登录：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012043393.png)

然后就会收到这样一条信息：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012043103.png)

由于项目是开源的，所以这里直接把服务端的信息返回出来，好让大家第一时间辨别出来是哪里出现了问题，可以及时去调整。

当你看到这样一条错误提示，第一时间就能明白，哦，原来是Redis没有启动啊。

在服务器端的控制台面板（错误堆栈信息中），可以找到对应的错误信息。

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012052637.png)

其中ForumExceptionHandler就是用来进行全局异常处理的，它是HandlerExceptionResolve接口的实现类。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012058592.png)


# 2、HandlerExceptionResolver
HandlerExceptionResolver是Spring提供的一种异常处理机制，它允许我们在应用程序中以通过一的方式处理控制器方法引发的异常。

要使用HadnlerExceptionResolver，我们要创建一个实现该接口的类，并在其中定义如何处理异常，例如：
```java
@Slf4j  
@Order(-100)  
public class ForumExceptionHandler implements HandlerExceptionResolver {
    @Override  
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {}
```
1. @Slf4j是lombok提供的一个日志注解
2. @Order注解用于指定Spring中组件的加载顺序。他接受一个整数值，数值越小，组件的优先级越高，加载顺序越靠前
3. 在resolveException方法中，我们可以自定义异常处理逻辑，根据异常类型返回不同的ModelAndView

ForumExceptionHandler中resolveException方法中的具体代码：
```java
Status errStatus = buildToastMsg(ex);  

if (restResponse(request, response)) {  
    // 表示返回json数据格式的异常提示信息  
    if (response.isCommitted()) {  
        // 如果返回已经提交过，直接退出即可  
        return new ModelAndView();  
    }  
  
    try {  
        response.reset();  
        // 若是rest接口请求异常时，返回json格式的异常数据；而不是专门的500页面  
        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);  
        response.setHeader("Cache-Control", "no-cache, must-revalidate");  
        response.getWriter().println(JsonUtil.toStr(ResVo.fail(errStatus)));  
        response.getWriter().flush();  
        response.getWriter().close();  
        return new ModelAndView();  
    } catch (Exception e) {  
        throw new RuntimeException(e);  
    }  
}  
  
String view = getErrorPage(errStatus, response);  
ModelAndView mv = new ModelAndView(view);  
response.setContentType(MediaType.TEXT_HTML_VALUE);  
mv.getModel().put("global", SpringUtil.getBean(GlobalInitService.class).globalAttr());  
mv.getModel().put("res", ResVo.fail(errStatus));  
mv.getModel().put("toast", JsonUtil.toStr(ResVo.fail(errStatus)));  
return mv;
```

技术派中做了两种处理，一种是REST接口请求的异常，一种是针对普通页面请求的异常：
1. 如果是REST接口请求异常，代码会返回一个JSON格式的异常提示信息：
	1. 首先检查响应是否已经提交（调用ServletResponse中的isCommitted方法），如果已经提交，则直接返回一个空的ModelAndView
	   
	   **isCommitted方法**：在执行完service方法后调用PrintWriter对象的close方法关闭底输出流，该方法在关闭输出流之前会把缓冲区内的数据提交到客户端，因此在调用PrintWriter对象的close方法之前，response.isCommitted()方法返回false，而在调用PrintWriter对象的close方法之后，response.isCommitted()方法返回true。
	   
	2. 如果响应未提交，将重置响应对象（调用ServletResponse中的reset方法），设置响应的内容为JSON，并添加响应的响应头
	3. 使用response.getWriter()将异常状态对象errStatus转换为JSON格式并写入响应。完成后，返回一个空的ModelAndView。
2. 如果是普通页面请求异常，代码会返回一个包含错误信息的HTL页面：
	1. 根据异常状态对象errStatus和响应对象response获取错误页面的视图名称
	2. 创建一个ModelAndView对象，并设置视图名称
	3. 设置响应的内容类型为HTML
	4. 向ModelAndView中添加全局属性、错误响应对象以及错误信息（以JSON格式）
	5. 最后返回这个ModelAndView对象，用于展示错误页面。

下面是当遇到404错误的时候，返回的404页面：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012145311.png)

其中buildToastMsg方法用来对异常进行分类，使用instanceof关键字来判断不同类型的异常，添加不同的异常码和提示消息。
```java
private Status buildToastMsg(Exception ex) {  
    if (ex instanceof ForumException) {  
        return ((ForumException) ex).getStatus();  
    } else if (ex instanceof HttpMediaTypeNotAcceptableException) {  
        return Status.newStatus(StatusEnum.RECORDS_NOT_EXISTS, ExceptionUtils.getStackTrace(ex));  
    } else if (ex instanceof NestedRuntimeException) {  
        log.error("unexpect error! {}", ReqInfoContext.getReqInfo(), ex);  
        return Status.newStatus(StatusEnum.UNEXPECT_ERROR, ex.getMessage());  
    } else {  
        log.error("unexpect error! {}", ReqInfoContext.getReqInfo(), ex);  
        return Status.newStatus(StatusEnum.UNEXPECT_ERROR, ExceptionUtils.getStackTrace(ex));  
    }  
}
```

StatusEnum中定义了异常码的规范，举几个例子：
```java
/**  
 * 异常码规范：  
 * xxx - xxx - xxx  
 * 业务 - 状态 - code  
 * <p>  
 * 业务取值  
 * - 100 全局  
 * - 200 文章相关  
 * - 300 评论相关  
 * - 400 用户相关  
 * <p>  
 * 状态：基于http status的含义  
 * - 4xx 调用方使用姿势问题  
 * - 5xx 服务内部问题  
 * <p>  
 * code: 具体的业务code  
 * * @author YiHui  
 * @date 2022/7/27  
 */@Getter  
public enum StatusEnum {  
    SUCCESS(0, "OK"),  
    
    // -------------------------------- 通用  
    
    // 全局传参异常  
    ILLEGAL_ARGUMENTS(100_400_001, "参数异常"),  
    ILLEGAL_ARGUMENTS_MIXED(100_400_002, "参数异常:%s"),  
    
    // 全局权限相关  
    FORBID_ERROR(100_403_001, "无权限")
}
```

getErrorPage方法用于返回不同的错误页面，比如常见的404 Not Found（请求的资源不存在，服务器无法找到请求的资源）、403 Forbidden（服务器理解请求，但是拒绝处理它，一般是由于权限问题或者访问被拒绝）、500 Internal Server Error（服务器发生了错误，无法完成请求）等。
```java
private String getErrorPage(Status status, HttpServletResponse response) {  
    // 根据异常码解析需要返回的错误页面  
    if (StatusEnum.is5xx(status.getCode())) {  
        response.setStatus(500);  
        return "error/500";  
    } else if (StatusEnum.is403(status.getCode())) {  
        response.setStatus(403);  
        return "error/403";  
    } else {  
        response.setStatus(404);  
        return "error/404";  
    }  
}
```

restResponse方法用来判断是否是REST请求，比如说admin后台请求、api数据请求、上传图片等接口、Ajax请求等，这些请求统一返回JSON格式的异常提示信息，否则返回普通页面格式的异常提示信息。
```java
private boolean restResponse(HttpServletRequest request, HttpServletResponse response) {  
    if (request.getRequestURI().startsWith("/api/admin/") || request.getRequestURI().startsWith("/admin/")) {  
        return true;  
    }  
  
    if (request.getRequestURI().startsWith("/image/upload")) {  
        return true;  
    }  
  
    if (response.getContentType() != null && response.getContentType().contains(MediaType.APPLICATION_JSON_VALUE)) {  
        return true;  
    }  
  
    if (isAjaxRequest(request)) {  
        return true;  
    }  
  
    // 数据接口请求  
    AntPathMatcher pathMatcher = new AntPathMatcher();  
    if (pathMatcher.match("/**/api/**", request.getRequestURI())) {  
        return true;  
    }  
    return false;  
}
```

再来看一下自定义的异常类ForumException，非常简单，继承了RuntimeException
```java
public class ForumException extends RuntimeException {  
    @Getter  
    private Status status;  
  
    public ForumException(Status status) {  
        this.status = status;  
    }  
  
    public ForumException(int code, String msg) {  
        this.status = Status.newStatus(code, msg);  
    }  
  
    public ForumException(StatusEnum statusEnum, Object... args) {  
        this.status = Status.newStatus(statusEnum, args);  
    }  
  
}
```

HandlerExceptionResolver的工作原理主要基于Spring MVC的异常处理流程。当一个请求进入Spring MVC后，它会根据请求信息找到对应的处理器（handler，也就是Controller）。在Controller执行过程中，如果抛出了异常，Spring MVC就会启动异常处理流程：
1. 异常发生：当Controller执行过程中抛出异常，Spring MVC捕获到这个异常后，会进入异常处理流程。
2. 查找异常解析器：Spring MVC会遍历所有已注册的HandleExceptionResolver实现。比如说我们自定义的ForumExceptionHandler，Spring MVC本身也提供了一些默认的实现，比如DefaultHandlerExceptionResolver，ExceptionHandlerExceptionResolver。
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308012227612.png)
   
   在代码中是通过WebMvcConfigurer（参考[补7_SpringBoot---WebMvcConfigurer详解](2、相关技术/16、常用框架-SpringBoot/补7_SpringBoot中WebMvcConfigurer/补7_SpringBoot---WebMvcConfigurer详解.md)）类中的configureHandlerExceptionResolvers方法配置的。

3. 执行异常解析器：对于每个HandlerExceptionResolver实现，Spring MVC会调用它的resolveException方法，并传入请求、响应、处理器和异常对象。如果解析器能处理这个异常，他会返回一个非空的ModelAndView对象，这个对象封装了异常处理后的视图和模型数据。
4. 处理返回结果：当resolveException方法返回一个非空的ModelAndView对象时，Spring MVC会将这个对象用于生成最终的响应。可能渲染一个错误视图、设置响应状态码等。如果所有的HandlerExceptionResolver都无法处理这个异常（及都返回了空的ModelAndView对象），那么Spring MVC会将异常重新抛出，以便其他异常处理器（如Servlet容器）进行处理。

通过这个流程，HandlerExceptionResolver能够在Spring MVC中统一管理和处理异常。记得在Spring Boot的启动类中将自定义的HandlerExceptionResolver添加到Spring配置中。
```java
/**  
 * 入口，直接运行即可  
 *  
 * @author yihui  
 * @date 2022/7/6  
 */
 
@Slf4j 
@EnableScheduling  
@EnableCaching  
@EnableKnife4j
@ServletComponentScan  
@SpringBootApplication  
public class QuickForumApplication implements WebMvcConfigurer, ApplicationRunner {
	@Override  
	public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {  
	    resolvers.add(0, new ForumExceptionHandler());  
	}
}
```

# 3、@ControllerAdvice

除了HandlerExceptionResolver，全局异常还可以采用@ControllerAdvice注解的方式。它可以将通用的操作和逻辑抽离出来，避免每个控制器重复相同的操作。

步骤：
1. 新建一个自定义的异常类ForumAdviceException
   ```java
public class ForumAdviceException extends RuntimeException {  
    @Getter  
    private Status status;  
  
    public ForumAdviceException(Status status) {  
        this.status = status;  
    }  
  
    public ForumAdviceException(int code, String msg) {  
        this.status = Status.newStatus(code, msg);  
    }  
  
    public ForumAdviceException(StatusEnum statusEnum, Object... args) {  
        this.status = Status.newStatus(statusEnum, args);  
    } 
}
   ```
2. 新建一个全局控制器GlobalExceptionHandler，内容如下所示：
   ```java
@RestControllerAdvice  
public class GlobalExceptionHandler {  
  
    @ExceptionHandler(value = ForumAdviceException.class)  
    public ResVo<String> handleForumAdviceException(ForumAdviceException e) {  
        return ResVo.fail(e.getStatus());  
    }  
}
   ```
   **@RestControllerAdvice是一个特殊的@ControllerAdvice注解，适用于处理RESTful API异常的情况。这意味着他将处理来自带有@RestController注解的控制器抛出的异常。**
   
   此类中定义的方法handleForumAdviceException使用@ExceptionHandler注解，表示它将处理ForumAdviceException类型的异常
3. 加一个测试的控制器方法testControllerAdvice
   ```java
@Slf4j  
@RestController  
@RequestMapping(path = "test")  
public class TestController {
	@RequestMapping(path = "testControllerAdvice")  
	@ResponseBody  
	public String testControllerAdvice() {  
	    throw new ForumAdviceException(StatusEnum.ILLEGAL_ARGUMENTS_MIXED, "测试ControllerAdvice异常");  
	}
}
   ```

4. 如果在之前启动类中注册了ForumExceptionHandler，此时要干掉
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308042337166.png)
5. 重启服务器，测试testControllerAdvice接口
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308042338690.png)
   接口返回的内容如下所示：
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202308042339802.png)


# 4、两种全局异常处理的优点

比较两种全局异常处理HandlerExceptionResolver和@ControllerAdvice（或@RestControllerAdvice）的优缺点：
1. HandlerExceptionResolver是一个接口，用于处理Controller抛出的异常，我们可以重写resolveException方法，在其中实现该接口来自定义全局异常处理逻辑。然后在SpringBoot启动类中通过extendHandlerExceptionResolvers（代码中使用的是configureHandlerExceptionResolvers方法，这两个方法很类似）将自定义的HandlerExceptionResolver添加到解析器中。
	1. 优点：更加灵活的处理异常，可以编写任何处理逻辑
	2. 缺点：与其他SpringMVC组件的集成不够紧密，需要手动添加配置
2. @ControllerAdvice（或@RestControllerAdvice）是用于定义全局异常处理类的注解。在这个类中，我们可以使用@ExceptionHandler注解来处理不同类型的异常，@ControllerAdvice需要与@ExceptionHandler注解一起使用
	1. 优点：更容易实现和集成，只需要创建一个带有ControllerAdvice（或RestControllerAdvice）注解的类，并使用@ExceptionHandler注解定义异常处理方法
	2. 缺点：异常处理逻辑不如HandlerExceptionResolver那么灵活
	
	   
可以根据具体的需求和使用场景来选择。






