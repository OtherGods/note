# 一、技术派项目工程搭建手册

本文作为技术派入手的开篇，其主要目的就是将上手门槛消减到一个极低的程度（理想目标是即便是小白也可以无障碍入门）

基于以上目的，本文将包含以下内容点
- 技术派的本地环境依赖搭建
- 技术派的本地编译启动运行

## 1、环境依赖

技术派是一个基于 Spring Boot、MyBatis-Plus、MySQL、Redis、ElasticSearch、MongoDB、Docker、RabbitMQ 等技术栈实现的社区系统，采用主流的互联网技术架构。

1.0 版已正式上线，为了给大家呈现一个学习的梯度，整个项目所使用的技术栈也是按阶段的方式集成引入，因此你可以选择一个最少依赖的原始版本进行学习，也可以选择集成了各三方框架的生产版本进行学习，这一切都取决于你个人的实际诉求。

接下来我们介绍一下技术派的编程环境搭建。

### 1.1、JDK8+安装

技术派最小依赖jdk版本为8，因此在开始前，请确认本地jdk版本是否满足需求；若不满足请升级，若本地没有安装jdk，可以参考以下安装说明。

可以直接看《二哥的 Java 进阶之路》上的安装教程，对小白会更友好一些：
[Windows和macOS下安装JDK教程：原生安装与包管理器](https://javabetter.cn/overview/jdk-install-config.html#_03%E3%80%81macos-%E5%AE%89%E8%A3%85-jdk)

#### 1.1.1、win环境安装

**安装包下载**
官方下载主页: [https://www.oracle.com/downloads/](https://www.oracle.com/downloads/)  
下载地址: [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/)  
选择需要的版本进行下载(下载.exe的安装包)  
下载完毕之后，本地双击进行安装，请记录安装的路径，再下面的环境配置中需要用到！

**环境配置**
1. 我的电脑 -> 右键 -> 属性 -> 高级系统设置 -> 环境变量
   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091852505.png)
2. 系统变量 -> 新建 -> 变量名 = JAVA_HOME,  变量值 = jdk安装路径
   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091852065.png)
3. 编辑变量中的Path -> 添加 %JVA_HOME%\bin -> 确定
   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091852187.png)
4. 验证 -> 搜索 输入cmd -> 选中控制台 -> 控制台中输入 java -version
   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091853214.png)

#### 1.1.2、linux环境安装

linux环境中jdk可直接根据命令行进行安装，下面分别介绍 apt-install 与 yum 的安装命令

**apt**
```shell
# 安装jdk
sudo apt-get install openjdk-8-jdk

# 测试验证
java -version
```

yum
```shell
# 安装jdk
sudo yum install java-1.8.0-openjdk.x86_64 -y
# 选择性安装dev工具
sudo yum install java-1.8.0-openjdk-devel.x86_64 -y

# 测试验证
java -version
```

#### 1.1.3、mac环境安装

打开终端
```shell
# 安装命令
brew install openjdk@8

# 根据输出的安装信息的提示，为了让 Java wrappers 找到 JDK，需要手动建立链接
# For the system Java wrappers to find this JDK, symlink it with
sudo ln -sfn /usr/local/opt/openjdk@8/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-8.jdk

# 配置 $JAVA_HOME 环境变量
vim ~/.bashrc

# 再最后面添加
export JAVA_HOME=$(/usr/libexec/java_home -v1.8)

# 退出终端，并使上面的配置生效
source ~/.bashrc

# 验证
java -version
```


### 1.2、MySQL安装

MySQL 是一个关系型数据库，也是我们国内使用频率最高的一种数据库（没有之一），不管是校招还是社招，都是必考内容，并且考察项目会非常多，属于二哥一直强调的 Java 后端四大件之一。

MySQL 的学习路线戳：[MySQL 的学习四阶段open in new window](https://javabetter.cn/xuexiluxian/mysql.html)

对于学生党来说，我推荐大家至少在大一下半学期完成 MySQL 的学习，因为在后面做项目的时候，必然会用到 MySQL 进行 CRUD。工作党就更别提了，几乎每天的开发都会和 MySQL 打交道，掌握不了 MySQL，就不是一名称职的 CRUD 工程师（😂）。

好，要想学好 MySQL，就需要在本地先安装 MySQL，主要分为 Windows 平台和 macOS 平台，服务器（生产环境）一般就是 Linux 操作系统。

从 MySQL 的应用领域来说，MySQL 一共可以分为四个版本：

- MySQL Community Server（社区版），我们一般都用这个版本（免费，可白嫖 😁）。
- MySQL Enterprise Edition（企业版），需要付费，一般大型企业才会用。
- MySQL Cluster（集群版），用于架设 MySQL 集群，一般也是大型企业才会用到，小公司一个单体的 MySQL 就够用了。
- MySQL Cluster CGE (Carrier Grade Edition)，MySQL Cluster 的高级版本，提供了额外的稳定性和性能。不在我们的讨论范围内。

从 MySQL 的发展历史来说，目前主流的版本是 MySQL 8.0，[技术派open in new window](https://javabetter.cn/zhishixingqiu/paicoding.html)项目用的就是 MySQL 8.0，不支持 MySQL 5.7（以前的主流版本，于 2023 年 10 月 31 日 终结生命周期）。

MySQL 8.0 引入了很多重大更新，包括：

- 默认 utf8mb4 字符集，支持 emoji 表情符号。
- InnoDB 增强，比如说自增列支持自动填充（auto_increment），消除以往重启实例自增列不连续的问题。
- 性能增强，8.0 相比 5.7 在高并发时性能提升近 1 倍。
- 更多新特性参照[这篇open in new window](https://www.cnblogs.com/YangJiaXin/p/13800134.html)。

接下来的安装，我们都以 MySQL 8.0 为例。

#### 1.2.1、Windows环境安装

直接进入 MySQL 官网进行下载。

[https://dev.mysql.com/downloads/mysql/open in new window](https://dev.mysql.com/downloads/mysql/)

或者直接在搜素引擎上搜“MySQL 下载”关键字，跳转到官网。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091909925.png)
网站会根据你的操作系统自动帮你匹配对应的版本，如下图所示。新手直接下载 MSI 安装包即可。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091910514.png)

> MSI，Microsoft Installer，一种用于在 Windows 操作系统上安装、维护和删除软件的文件格式。

当出现以下界面时，直接选择「no thanks，just start my download」即可。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091910712.png)

下载完成后，直接双击安装（我这里只说关键步骤）。

当出现下面这一步时，选择默认的开发者模式就好（会安装 MySQL 服务器「必须」、MySQL Shell「命令行操作」、MySQL 连接器「支持编程语言和 MySQL 之间的通信」等）。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091910450.png)

MySQL 的架构是 C/S 架构，即客户端/服务器架构，客户端负责发送 SQL 命令，服务器负责解析和执行 SQL 命令，然后返回结果给客户端。

其他的选项我就不解释了，能看懂的话就自己选择，看不懂的话默认就好（😂）。

在「高可用」界面上选择「Standalone MySql Server / Classic MySQL Replication」，意思就是我们打算让 MySQL 作为单机服务器来运行。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091910130.png)

在「Type and Networking」界面上，选择「Development Computer」，开发计算机，占用最小资源。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091911393.png)

「Connectivity」中如果 3306 端口被占用的情况下可以修改，但不建议，保持默认就好。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091911074.png)

MySQL 8.0 版本可以使用强密码，本地开发随便选就好。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091911659.png)

安装过程中会提示你输入 root 用户的密码，这个密码一定要记住，后面会用到。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091911538.png)

在「Windows Service」界面上，可以勾选复选框让 MySQL 作为 Windows 服务运行，然后指定服务名（当开机时启动 MySQL），并作为标准系统账号。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091912201.png)

就这样一直到 finish 就行，其他的配置不明白的话，可以参考这篇：[在 Windows 上安装 MySQLopen in new window](https://www.sjkjc.com/mysql/install-on-windows/)

#### 1.2.2、macOS环境安装

略，参考 [这里](https://javabetter.cn/mysql/install.html#macos-%E5%B9%B3%E5%8F%B0)

#### 1.2.3、Linux环境安装

Linux 平台通常又分为 CentOS 和 Ubuntu 两种：

- CentOS（Community ENTerprise Operating System）是 Red Hat Enterprise Linux（RHEL）的一个免费克隆版本；使用 YUM（Yellowdog Updater Modified）作为其包管理工具。
- Ubuntu 是基于 Debian 的 Linux 发行版；使用 APT（Advanced Packaging Tool）作为包管理工具。

> 不太了解这些知识的小伙伴可以自行了解一下，这里就不再一一解释了。

可以通过 `cat /etc/os-release` 命令来查看自己的 Linux 版本。二哥目前有两台服务器，一台腾讯云的，一台阿里云的，TencentOS 是完全兼容 CentOS 的；阿里云的是 Ubuntu。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403091915132.png)

**CentOS**

CentOS 可以使用 yum 命令来安装 MySQL。
```shell
# 安装命令
yum install mysql mysql-server mysql-libs

# 初始密码查找
grep "temporary password" /var/log/mysqld.log

## 输出如下
# A temporary password is generated for root@localhost: xxxx
```

**Ubuntu**
```shell
# 安装命令
sudo apt-get install mysql-server mysql-client -y

# 注意安装过程中的初始化密码设置（若没有，则可以通过下面的方法找到初始化密码）
grep "temporary password" /var/log/mysqld.log

## 输出如下
# A temporary password is generated for root@localhost: xxxx
```

### 1.3、Redis安装

详细的图文版

Redis 的安装（Windows+macOS）

官方说明文档 https://redis.io/docs/getting-started/installation/install-redis-on-linux/

#### 1.3.1、Windows环境安装

通常来说，不建议redis直接安装win操作系统上，更推荐的方式是开启wsl2，然后安装到ubuntu子操作系统上
再子操作系统上执行：
```shell
curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list

sudo apt-get update
sudo apt-get install redis
```

#### 1.3.2、macOS环境安装

```shell
brew install redis
```

启动命令：
```shell
# 临时启动，关闭会话结束
redis-server

# 服务方式启动
sudo service redis-server start

# 连接redis
redis-cli
```

#### 1.3.3、Linux环境安装

redis可以直接将通过源码方式编译安装，也可以通过命令行进行安装
**命令行方式**
```shell
sudo apt install lsb-release

curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list

sudo apt-get update
sudo apt-get install redis
```

### 1.4、Maven安装

Maven 是项目的构建工具，也就是说，当你在导入技术派项目的时候，需要通过 Maven 来构建项目。

maven的三端安装姿势差不多，唯一的区别在于环境变量的配置
下载地址：[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)
选择.tar.gz 或者 .zip的包，本地选择一个位置进行解压

#### 1.4.1、Windows环境安装

win环境变量配置方式同上面的jdk方式，新增环境变量 MAVEN_HOME
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101650457.png)

更新Path变量，添加%MAVEN_HOME%\bin
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101651664.png)

确定之后，再终端中输入 mvn --version 验证
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101651843.png)


#### 1.4.2、macOS环境安装

同linux

#### 1.4.3、Linux环境安装

打开终端
```shell
vim ~/.bashrc

# 再文件的最后面，添加maven的解压目录
export MAVEN_HOME=/home/yihui/soft/apache-maven-3.6.3

export PATH=${MAVEN_HOME}/bin:${PATH}

# 保存并退出上面的文件编辑，然后让配置变更生效
source ~/.bashrc

# 验证
mvn --version
```

## 2、本地编译运行

以上环境准备完毕之后，接下来就可以拉下源码，本地开始编译运行

### 2.1、加载源码

源码地址：[https://github.com/itwanger/paicoding](https://github.com/itwanger/paicoding)

1. 本地clone
```shell
git clone git@github.com:itwanger/paicoding.git   
```

若本地没有安装git，推荐安装一下；当然也可以采用下面的下载源码方式
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101656371.png)

2. 导入项目
   idea打开项目: 启动idea -> File -> Open -> 选择下载的源码路径
   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101657863.png)
   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101657930.png)
   
   打开项目之后会构建索引，这一过程具体的耗时取决于你的网络环境，当构建完毕之后，最明显的就是左边的几个项目模块的标识，会变成下面这种样子   ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101658201.png)

### 2.2、开发环境配置

本地项目加载之后，再启动之前，先看一下本地的环境变量配置；我们默认的是dev开发环境（无需任何设置），此时打开 paicoding-web/src/main/resources-env/dev 目录下的配置文件 application-dal.yml
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101659900.png)

重点需要修改的就是数据库和redis的用户名和密码
- **数据库**：
	- spring.datasource.username 和 spring.datasource.password 分别为你本地的数据库用户名和密码
	- 如果你想使用其他服务器上的数据库，则可以改 spring.datasource.url 中的 127.0.0.1:3306 改为目标地址+端口号
	- 默认的数据库名：database.name = pai_coding，再配置文件 src/main/resources/application.yml 中
- **redis**：
	- 当不使用密码时，password为空；若有密码，则需要设置为对应的密码
	- 注意：这里使用的是单机的redis；若使用集群模式，请查看前面教程中的《技术派整合redis》

### 2.3、本地编译运行

接下来就进入本地启动的环节
1. 启动mysql
```shell
sudo service mysql start
```
2. 启动redis
```shell
redis-server
```
3. 启动项目
   找到启动入口：
   - paicoding-web模块中的：com.github.paicoding.forum.web.QuickForumApplication
   - 再下图的小三角行上，点击右键启动 -> 选择 Run or Debug 方式启动
     ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101707143.png)
     首次启动会自动创建数据库表，并初始化一些用户、博文等相关数据；
     ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101708030.png)
     启动成功的标识是控制台上会如下输出
     ![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101708229.png)

再本地开发环境下，若希望登录系统，请使用下面的 一键登录 和 随机新用户 登录，不要再公众号中输入验证码，因为微信公众平台不会将请求转发到你的本机![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403101709393.png)

接下来源码在手，页面可视，完全可以放飞自我的进行展开了；

## 3、小结

当前的搭建手册，目前适用于1.0版本的技术派；若后续有引入新的系统，如消息中间件mq，搜索引擎es，文档数据库mongodb，配置中心apollo、nacos等，会同步更新上面的环境依赖和本地运行配置

再技术派项目的搭建、学习过程中，遇到任何问题，可以再 《技术派--知识星球》 中进行提问，也可以再专属的微信群中抛出

# 二、技术派服务器部署指导手册

这一章节将主要介绍如何将技术派部署到服务器上，搭建成一个可以对外提供访问的技术社区
> 主要以linux系统作为服务器运行环境进行说明

## 1、基础环境搭建

当前技术派依赖的外部主要有：mysql + redis ，因此在服务器上部署时，若没有mysql,redis，那么需要首先进行安装
具体的安装方式可以参考：[工程搭建](https://www.yuque.com/itwanger/az7yww/qllbfg7sxm52vgi8) 这篇文章

下面是基础的服务器安装相关命令，如有疑问看上面

### 1.1、jdk环境安装

```shell
# ubuntu
apt install openjdk-8-jdk

# centos
yum install openjdk-8-jdk
```
### 1.2、maven安装

```shell
cd ~
mkdir soft
cd soft
wget https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.tar.gz
tar -zxvf apache-maven-3.8.6-bin.tar.gz

vim ~/.bashrc

# 在最后添加环境变量
export M2_HOME=/home/admin/soft/apache-maven-3.8.6
PATH=$M2_HOME/bin:$PATH

# 配置生效
source ~/.bashrc
```

配置完成之后执行命令 mvn --version 进行验证

国内添加阿里的镜像源，加快下载速度
```shell
vim ~/soft/apache-maven-3.8.6/conf/settings.xml
# 在<mirros>标签中，添加下面的镜像源
<mirror>
  <id>alimaven</id>
  <name>aliyun-maven</name>
  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
  <mirrorOf>central</mirrorOf>
</mirror>
```

### 1.3、redis安装

apt安装方式
```shell
sudo apt install lsb-release

curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg

echo "deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/redis.list

sudo apt-get update
sudo apt-get install redis
```

yum安装方式
```shell
# 下面这一行命令可以省略，主要是查看有哪些redis安装源
# sudo yum list | grep redis
sudo yum install redis.x86_64
```

安装完之后进行配置  sudo vim /etc/redis.conf
更推荐的方式是拷贝一份配置出来进行修改，如在用户目录下新增
```shell
cd ~
mkdir soft
cd soft
mkdir redis
cd redis
cp /etc/redis.conf ./
```

接下来修改配置文件
```shell
# 根据实际情况判断是否需要注释掉ip限定
bind 127.0.0.1

# 开启后台任务
damenoize yes
supervised no

# 设置访问密码
requirepass 你的密码

# 端口号，建议需改默认的6379，避免被攻击
port 6388

# 几个文件的路径调整一下
pidfile /home/app(这个是用户名)/soft/redis/redis.pid
logfile /home/app/soft/redis/redis.log
dir /home/app/soft/redis/
```

然后写一个启动关闭脚本 vim start.sh
```shell
#!/bin/bash

cat pid.log| xargs -I {} kill {}
redis-server ./redis.conf
ps aux | grep redis | awk  '{print $2}' 1> pid.log

# 保存配置，添加执行权限
chmod +x start.sh
```

启动redis服务
```shell
./start.sh
```

### 1.4、mysql安装

```shell
# ubuntu
sudo apt-get install mysql-server

# centos
yum install mysql mysql-server mysql-libs
```

查看登录密码
```shell
grep "temporary password" /var/log/mysqld.log

## 输出如下
# A temporary password is generated for root@localhost: xxxx
```

**密码修改：**
方式一：使用set password
**格式：**
```shell
mysql> set password for 用户名@localhost = password('新密码');
```

**如：**
```shell
mysql> set password for root@localhost = password('123');
```

方式二：update方式
```shell
mysql> use mysql;

mysql> update user set password=password('123') where user='root' and host='localhost';

mysql> flush privileges;
```

**启动mysql命令**
```shell
# 启动
sudo service mysql start
# 或 sudo service mysqld start

# 关闭
sudo service mysql stop

# 重启
sudo service mysql restart
```

### 1.5、nginx配置

以nginx做访问代理（如有域名访问需求时），可以如下配置
```shell
# 安装
sudo yum install nginx
```

配置访问域名
```shell
cd /usr/local/nginx/conf/

vim nginx.conf

# 添加子域名解析，每个域名一个独立的配置文件
# 在http的一级标签中，添加如下一行配置，表示在conf.d文件下的所有conf结尾的文件，都属于我们需要使用的nginx配置信息
include /usr/local/nginx/conf/conf.d/*.conf;
```

添加域名解析规则：
```nginx
# 内容如下
upstream  forum_host {
    server 127.0.0.1:8080;
}
server {
	server_name forum.hhui.top;

    gzip on;
    gzip_buffers 32 4K;
    gzip_comp_level 6;
    gzip_min_length 100;
    gzip_types application/javascript text/css text/xml;
    gzip_disable "MSIE [1-6]\."; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）
    gzip_vary on;

    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ {
	    access_log   off;
        expires      1d;
        proxy_pass         http://forum_host;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
    }
    
    location ~* ^.+\.(css|js|txt|xml|swf|wav|pptx)$ {
        access_log   off;
        expires      10m;
        proxy_pass         http://forum_host;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
    }
    
    location / {
        proxy_set_header X-real-ip  $remote_addr;
        proxy_pass http://127.0.0.1:8080/;
        proxy_redirect default;
    }
    
    listen 443 ssl; # managed by Certbot
    ssl_certificate /usr/local/nginx/conf/conf.d/cert.pem;
    ssl_certificate_key /usr/local/nginx/conf/conf.d/key.pem;
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 8.8.8.8 8.8.4.4 1.1.1.1 valid=60s;
    resolver_timeout 2s;
}

server {
    if ($host = forum.hhui.top) {
        return 301 https://$host$request_uri;
    } # managed by Certbot
    
    listen 80;
    server_name forum.hhui.top;
    return 404; # managed by Certbot
}
```

证书使用let's encrypt生成，不会的可以参考下面这个文档
[200810-acme.sh 快速实现https证书颁发与自动续期](2、相关技术/11、Linux/环境搭建/200810-acme.sh%20快速实现https证书颁发与自动续期.md)

> 我的nginx配置：
> 服务器ip：47.93.184.165
> nginx配置路径：/etc/nginx/nginx.conf
> nginx配置内容：
```shell
#user  nobody;
worker_processes  1;

events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    gzip  on;
    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;
    gzip_vary on;


    server {
        listen       81;
        server_name  static.zp.cn;

        location / {
	    # proxy_pass http://127.0.0.1:8080/;
            root /app/dist;
            index index.html;
            # 转发任何请求到 index.html
        }
    }

	server {
		listen 80;
		server_name www.caosihhy.lxd;
		location / {
		    proxy_pass http://testServer;
		}
		access_log /var/log/nginx/access.log;
		error_log /var/log/nginx/error.log;
	}

	upstream testServer {
			  server localhost:8080 weight=2;
			  server localhost:8081 weight=2;
			  server localhost:8082;
			}

	autoindex on;             #开启索引功能
	autoindex_exact_size off; # 关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）
	autoindex_localtime on;   # 显示本机时间而非 GMT 时间
	charset utf-8; # 避免中文乱码

	# 搭的nginx静态服务器，同时也是我公众号二维码所在位置
	server {
		listen       8090; #监听端口号
		server_name  localhost;
		root         /my/share; # 共享的文件目录
		error_log /my/share/logs/error.log ; # 报错的文件目录
		
		location / {
		}
		
		error_page 404 /404.html;
		  location = /40x.html {
		}
		
		error_page 500 502 503 504 /50x.html;
		  location = /50x.html {
		}
	}
}
```

## 2、源码部署方式

源码的部署方式表示直接使用源码进行构建，下面直接以paicoding的github上main分支的源码为例进行说明

### 2.1、下载源码，并构建

1. 下载
```bash
cd ~/
mkdir workspace
cd workspace
git clone git@github.com:itwanger/paicoding.git
```

2. 构建
```bash
cd paicoding
mvn clean install -DskipTests=ture -U
```

### 2.2、修改配置

在服务器上运行技术派时，原则上我们是希望以prod环境为主（表示这个是生产环境，如果是在测试机上进行部署，可以选择test）
首先第一步就是修改对应环境的配置信息

**数据库配置**
```bash
vim paicoding-web/src/main/resources-env/prod/application-dal.yml

# 修改数据库和redis的连接密码
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/${database.name}?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: 真实的用户名
    password: 真实的密码
  redis:
    host: 真实的redis地址
    port: 真实的redis端口
    password: 真实的redis访问密码
```

**oss配置**
生产环境上的图片默认上传到阿里云，因此也需要修改对应的配置
```bash
vim paicoding-web/src/main/resources-env/prod/application-image.yml

image:
  # 服务器保存图片的绝对地址
  abs-tmp-path: /home/admin/storage/
  # 图片前缀
  web-img-path: forum/img/
  # 临时存储目录
  tmp-upload-path: /tmp/forum/
  # 图片访问域名
  cdn-host: https://paicoding.com/
  oss:
    type: ali # 这个表示是使用阿里云的oss
    prefix: xxx
    endpoint: xxx
    ak: xxx
    sk: xxx
    bucket: xxx
    host: https://cdn.tobebetterjavaer.com/ # 访问图片的域名前缀
```

注意，当没有oss时，希望直接将图片保存到服务器上，可以如下设置(一般不建议这么干，一个是安全风险，一个是静态图片的存储与网络资源都将占用服务器，会导致服务器本身负载高)
```bash
image:
  # 服务器保存图片的绝对地址
  abs-tmp-path: /home/admin/storage/
  # 图片前缀
  web-img-path: forum/img/
  # 临时存储目录
  tmp-upload-path: /tmp/forum/
  # 图片访问域名
  cdn-host: https://paicoding.com/
  oss:
    type: local
    prefix: paicoding/
    endpoint: 
    ak: 
    sk: 
    bucket: 
    host: 
spring:
  web:
    resources:
      # 支持本地图片上传之后的链接，后面的file: 适用于mac/linux系统
      static-locations: classpath:/static/,  file:${image.abs-tmp-path}
```

上个配置中：
- resources: 用于指定Web资源的处理方式。
    - `static-locations`: 用于指定静态资源的位置。在这里配置了两个位置：
        - `classpath:/static/`：表示静态资源存放在classpath下的/static/目录中。这样的资源会被Spring Boot自动识别并处理。
        - `file:${image.abs-tmp-path}`：表示在本地文件系统中存放了一些资源，路径由`${image.abs-tmp-path}`指定。`${image.abs-tmp-path}`可能是一个变量，用来代表实际的文件系统路径。在这个配置中，可能是用来支持本地图片上传后的链接。当上传图片后，可以通过这个配置的路径访问到上传的图片文件。

总体来说，这段Spring配置指定了静态资源的处理方式，包括从classpath加载静态资源以及通过本地文件系统路径访问静态资源，其中${image.abs-tmp-path}可能是一个变量，用来指定实际的文件系统路径。

### 2.3、登录方式修改

技术派默认提供的是根据微信公众号的验证码方式来实现登录，因此如果希望在你自己的服务器上部署时，请完整的替换相应的微信公众号二维码、微信开放平台对接的相关的配置参数，具体详情可参考
[5、技术派中的微信公众号自动登录方案](2、相关技术/24、项目/1、技术派/2、进阶篇/5、技术派中的微信公众号自动登录方案.md)

下面列出基本的修改点:
1. 配置文件 application-config.yml 
	- view.site.contactMeWxQrCode: 公众号二维码
	- view.site.wxLoginUrl: 公众号二维码解码后的文本
2. 微信公众号平台
	- 开启开发者相关权限，设置回调url
	  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202406291808647.png)

登录方式主要使用的是微信公众平台的回调机制，因此需要设置白名单，当前没有使用直接调用微信公众号接口获取信息的功能，因此无需设置开发者id，密码等信息


### 2.4、启动
以上修改完毕之后，可以直接启动服务（注意无需初始化数据库表，默认的库名 pai_coding，可以通过修改application.yml配置文件中的database.name来替换）
```bash
# 进入源码根目录
cd ~/workspace/paicoding
# 给启动命令脚本添加执行权限
chmod +x launch.sh
# 启动
./launch.sh start
```

启动完毕之后，可以再当前目录看到新增一个 logs 目录，下面会有两个日志文件
- pai-prod.log：系统日志
- req-prod.log：外部请求日志
当系统日志中输出 **启动成功，点击查看首页** 的字样时，表示正常启动了，此时可以进行访问

**说明**
- 重新部署命令： launch.sh start
	- 会重新打包，并将之前运行的.jar 重名为 .jar.bak 的本分文件
- 重启命令：launch.sh restart
	- 单纯的重启，不会重新打包
- 若部署的不是prod环境，需要修改launch.sh脚本中的配置，将下面的 -Pprod 修改为 -P新环境
![0.jpg](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202406101830849.jpg)

jvm参数，根据实际的机器情况进行需改调整

#### 2.4.1、deploy.sh 脚本

```bash
#!/usr/bin/env bash

# pid file
PID_FILE_NAME="pid.log"

# file to upload
WEB_PATH="paicoding-web"
EXECUTABLE_JAR_NAME="paicoding-web-0.0.1-SNAPSHOT.jar"
TMP_EXECUTABLE_JAR_NAME=${EXECUTABLE_JAR_NAME}".tmp"
BAK_EXECUTABLE_JAR_NAME=${EXECUTABLE_JAR_NAME}".bak"
EXECUTABLE_JAR_PATH="./${WEB_PATH}/target/${EXECUTABLE_JAR_NAME}"

DEPLOY_SCRIPT="deploy.sh"
START_FUNC_NAME="start"
STOP_FUNC_NAME="stop"
RESTART_FUNC_NAME="restart"

#env, ssh remote, work dir
ENV_PRO="prod"
SSH_HOST_PRO=("admin@39.105.208.175")
WORK_DIR_PRO="/home/admin/workspace/paicoding-forum/"


# log file
declare LOG_FILES
LOG_BACKUP_FOLDER="logs/"

function stop() {
    # kill
    echo "--- 应用下线 ---"
    if [ -f "${PID_FILE_NAME}" ]; then
        pid=$(cat ${PID_FILE_NAME})
        echo "kill -9 ${pid}"
        kill -9 ${pid}
    fi
    echo "----------------"
}

function start() {
    # 获取当前脚本文件的目录路径
    work_dir=`dirname $0`
    cd ${work_dir}

    # 调用stop函数停止程序
    stop

    # 重命名文件
    mv ${EXECUTABLE_JAR_NAME} ${BAK_EXECUTABLE_JAR_NAME}
    mv ${TMP_EXECUTABLE_JAR_NAME} ${EXECUTABLE_JAR_NAME}

    # 设置用户对于指定文件的权限；当前用户、和当前用户在同一个组的用户（组用户）、其他用户设置权限：r(读/4)、w(写/2)、x(可执/1)
    chmod 755 ${EXECUTABLE_JAR_NAME}
    # run
    echo "===== 启动脚本：====="
    # 调用run函数运行程序
    run
}

function restart() {
    # 获取当前脚本文件的目录路径
    work_dir=`dirname $0`
    cd ${work_dir}
    # 调用stop函数停止程序
    stop
    # run
    echo "===== 启动重启：====="
    # 调用run函数运行程序
    run
}

function run() {
  echo "nohup java -server -Xms512m -Xmx512m -Xmn512m -XX:NativeMemoryTracking=detail -XX:-OmitStackTraceInFastThrow -jar ${EXECUTABLE_JAR_NAME} > /dev/null 2>&1 &"
  echo "==================="

  # nohup：在Unix和Linux系统中，nohup命令用于在后台运行命令，即使终端关闭也不会影响命令的执行。
  # -server：指示Java虚拟机以服务器模式运行。
  # -Dspring.devtools.restart.enabled=false：设置一个系统属性，用于禁用Spring Boot开发工具的自动重启功能。
  # -Xms512m -Xmx512m -Xmn512m：设置Java堆的初始大小（512MB）、最大大小（512MB）和年轻代大小（512MB）。
  # -XX:NativeMemoryTracking=detail：启用本地内存跟踪机制，并设置输出详细信息。
  # -XX:-OmitStackTraceInFastThrow：禁用在快速抛出异常时省略堆栈跟踪信息的优化。
  # -jar ${EXECUTABLE_JAR_NAME} "$@"：运行可执行的JAR文件${EXECUTABLE_JAR_NAME}，并传递脚本中接收到的所有参数。
  # > /dev/null: 将标准输出（stdout）重定向到/dev/null，即丢弃所有输出。
  # 2>&1: 将标准错误输出（stderr）也重定向到标准输出，即丢弃所有输出。
  nohup java -server -Dspring.devtools.restart.enabled=false -Xms512m -Xmx512m -Xmn512m -XX:NativeMemoryTracking=detail -XX:-OmitStackTraceInFastThrow -jar ${EXECUTABLE_JAR_NAME} "$@" > /dev/null 2>&1 &

  # 将最后一个后台进程的进程ID（PID，通过$!获取）写入${PID_FILE_NAME}文件中，以便后续可以方便地查找和管理该进程。
  # echo $! :
  #   - 输出上一个后台进程的进程 ID (PID)。
  #	  - `$!` 是一个特殊变量，表示最近运行的后台进程的 PID。
  # >或1> 用于将标准输出（stdout）重定向到指定文件
  echo $! > ${PID_FILE_NAME}
}

function compile() {
    echo "---- start to build jar ----"
    echo "安装依赖：mvn clean install -Dmaven.test.skip=True -P${1}"

    # -P：这个参数用于激活指定的配置文件。${1}是脚本中传入的参数（${1}和$1的作用一样），可能用于指定不同的配置文件，以便根据需要执行特定的构建配置。
    mvn clean install -Dmaven.test.skip=True -P${1}
    cd ${WEB_PATH}
    echo "构建可运行jar：mvn clean package spring-boot:repackage -Dmaven.test.skip=true -P${1}"

    # 构建可运行的JAR：执行mvn clean package spring-boot:repackage -Dmaven.test.skip=true -P${1}命令，用于构建可运行的JAR包。同样，${1}可能用于指定不同的构建配置文件。
    mvn clean package spring-boot:repackage -Dmaven.test.skip=true -P${1}

    # 返回上次所在的目录：切换回原始的工作目录。
    cd -

    # 检查构建结果：检查上述构建操作的返回值，如果不等于0，表示构建过程中出现错误，函数返回1。
    ret=$?
    if [[ ${ret} -ne 0 ]] ; then
        return 1
    fi
    echo "---------- jar包构建完成 -------------"
}

# 这个函数用于将可执行JAR文件和部署脚本上传到远程主机的指定目录，如果其中任何一个上传操作失败，函数将返回1。
function upload() {

    #上传JAR文件：使用scp命令将${EXECUTABLE_JAR_PATH}指定的可执行JAR文件上传到远程主机。上传后会将文件重命名为${TMP_EXECUTABLE_JAR_NAME}
    # upload jar
    # rename to *.jar.bak
    scp ${EXECUTABLE_JAR_PATH} $1:$2${TMP_EXECUTABLE_JAR_NAME}

    # 检查上传结果：检查scp命令的返回值，如果返回值不等于0，表示上传失败，打印错误消息并返回1。
    ret=$?
    if [[ ${ret} -ne 0 ]] ; then
        echo 'Failed to scp jar'
        return 1
    fi
    
    # 上传部署脚本：使用scp命令将${DEPLOY_SCRIPT}指定的部署脚本上传到远程主机的指定目录。
    # upload script
    scp ${DEPLOY_SCRIPT} $1:$2

    # 再次检查上传结果：再次检查scp命令的返回值，如果返回值不等于0，表示上传失败，打印错误消息并返回1。
    ret=$?
    if [[ ${ret} -ne 0 ]] ; then
        echo 'Failed to scp deploy.sh'
        return 1
    fi
}

function deploy() {

    # 打包：首先调用compile函数对指定环境进行编译打包。
    # package
    echo "*******Start to package*******"
    compile $1

    # 如果编译失败，则打印错误消息并以编译失败的返回码退出脚本。
    ret=$?
    if [[ ${ret} -ne 0 ]] ; then
        echo 'Failed to compile'
        exit ${ret}
    fi

    # 确定部署环境：根据传入的参数判断部署的环境是生产环境还是其他环境。如果是生产环境，则设置SSH主机和工作目录变量为生产环境的对应值。
    if [ "$1" = "${ENV_PRO}" ]; then
        SSH_HOST=${SSH_HOST_PRO[@]}
        WORK_DIR=${WORK_DIR_PRO}
    else
        echo "Unknown env: $1"
        exit
    fi

    # 上传文件并部署：对每个SSH主机执行以下操作：
    for host in ${SSH_HOST[@]}
    do
        # 调用upload()函数，将文件上传到远程主机指定目录。
        # upload jar and deploy.sh
        echo "*******Start to upload:${host} *******"
        upload ${host} ${WORK_DIR}

	# 检查上传结果，如果上传失败，则打印错误消息并以上传失败的返回码退出脚本。
        ret=$?
        if [[ ${ret} -ne 0 ]] ; then
            echo 'Failed to upload files'
            exit ${ret}
        fi
    done

    # 启动服务：对每个SSH主机执行以下操作：
    for host in ${SSH_HOST[@]}
    do
        # 运行部署脚本，启动服务。使用SSH连接到主机，并执行部署脚本${DEPLOY_SCRIPT}，传入${START_FUNC_NAME}作为参数。
        # run
        echo "*******Start service:${host} *******"
        ssh ${host} "bash ${WORK_DIR}${DEPLOY_SCRIPT} ${START_FUNC_NAME}"
        echo "*******Done*******"
    done
}

if [ "$1" = "${START_FUNC_NAME}" ]; then
    start "$@"
elif [ "$1" = "${ENV_PRO}" ]; then
    deploy $1
elif [ "$1" = "${STOP_FUNC_NAME}" ]; then
    stop
elif [ "$1" = "${RESTART_FUNC_NAME}" ]; then
    restart
else
    echo "部署jar到服务器:  ./deploy.sh prod"
    echo "服务器上应用重启: ./deploy.sh restart"
    echo "服务器上应用关闭: ./deploy.sh stop"
fi
```

#### 2.4.2、launch.sh

```shell
#!/usr/bin/env bash  
  
WEB_PATH="paicoding-web"  
JAR_NAME="paicoding-web-0.0.1-SNAPSHOT.jar"  
  
# 部署  
function start() {  
    git pull  
  
    # 杀掉之前的进程  
    cat pid.log| xargs -I {} kill {}  
    mv ${JAR_NAME} ${JAR_NAME}.bak  
  
    mvn clean install -Dmaven.test.skip=True -Pprod  
    cd ${WEB_PATH}  
    mvn clean package spring-boot:repackage -Dmaven.test.skip=true -Pprod  
    cd -  
  
    mv ${WEB_PATH}/target/${JAR_NAME} ./  
    run  
}  
  
# 重启  
function restart() {  
    # 杀掉之前的进程  
    cat pid.log| xargs -I {} kill {}  
    # 重新启动  
    run  
}  
  
function run() {  
  echo "启动脚本：==========="  
  echo "nohup java -server -Xms1g -Xmx1g -Xmn512m -XX:NativeMemoryTracking=detail -XX:-OmitStackTraceInFastThrow -jar ${JAR_NAME} > /dev/null 2>&1 &"  echo "==========="  
  # ms 堆大小  mx 最大堆大小  mn 新生代大小  
  nohup java -server -Dspring.devtools.restart.enabled=false -Xms1g -Xmx1g -Xmn256m -XX:NativeMemoryTracking=detail -XX:-OmitStackTraceInFastThrow -jar ${JAR_NAME} > /dev/null 2>&1 &  
  
  # `echo` 是一个 Shell 内置命令，用于将指定的字符串或变量值输出到标准输出（通常是终端）。
  # `$!` 是一个特殊的 Shell 变量，表示最近运行的后台进程的进程 ID (PID)。这个值是由上一个以 `&` 结尾的命令生成的。
  # `1>` 表示重定向标准输出（文件描述符 1）。标准输出默认是终端，可以使用重定向将其输出到文件。
  echo $! 1> pid.log  
}  
  
if [ $# == 0 ]; then  
  echo "miss command: start | restart"  
elif [ $1 == 'start' ]; then  
  start  
elif [ $1 == 'restart' ];then  
  restart  
else  
  echo 'illegal command, support cmd: start | restart'  
fi
```


### 2.4.3、涉及到的shell命令

在 Shell 中，`>`、`1>`、`2>` 是重定向操作符，用于将输出重定向到文件或设备。它们的区别和一些类似的 Shell 命令如下：

#### 2.4.3.1、区别

1. **`>`**:
   - 等同于 `1>`，用于将标准输出（stdout）重定向到文件。
   - 例子：`command > file.txt` 将标准输出重定向到 `file.txt`。

2. **`1>`**:
   - 明确指定标准输出（文件描述符 1）重定向到文件。
   - 例子：`command 1> file.txt` 与 `command > file.txt` 等效。

3. **`2>`**:
   - 用于将标准错误（stderr）重定向到文件。
   - 例子：`command 2> error.log` 将标准错误重定向到 `error.log`。

#### 2.4.3.2、类似的 Shell 命令

1. **`&>`**:
   - 将标准输出和标准错误都重定向到同一个文件。
   - 例子：`command &> output.txt`。

2. **`2>&1`**:
   - 将标准错误重定向到标准输出。
   - 例子：`command > file.txt 2>&1` 将标准输出和标准错误都重定向到 `file.txt`。

3. **`>>`**:
   - 追加标准输出到文件，而不是覆盖文件内容。
   - 例子：`command >> file.txt`。

4. **`2>>`**:
   - 追加标准错误到文件。
   - 例子：`command 2>> error.log`。

5. **`|`**:
   - 管道操作符，用于将一个命令的输出作为另一个命令的输入。
   - 例子：`command1 | command2`。

#### 2.4.3.3、示例

```sh
# 将标准输出重定向到 output.txt
echo "Hello, World!" > output.txt

# 将标准错误重定向到 error.log
ls nonexistentfile 2> error.log

# 将标准输出和标准错误都重定向到 output.txt
java -jar myapp.jar > output.txt 2>&1

# 将标准输出和标准错误都重定向到 output.txt，使用 &> 简化写法
java -jar myapp.jar &> output.txt

# 将标准输出追加到 output.txt
echo "Hello again!" >> output.txt

# 将标准错误追加到 error.log
ls anothernonexistentfile 2>> error.log
```

这些命令和操作符使得在脚本中控制输出非常灵活，可以根据需要将输出记录、忽略或传递到其他命令。


## 3、jar包部署方式

jar包部署的方式主要针对的是直接上传一个fat-jar包到服务器上运行，编译打包的过程可以是本机、也可以是jenkins，这里以简单的本机为例进行说明

### 3.1、ssh配置

我们采用scp的方式上传jar包，因此直接配置ssh访问服务器会省事很多，避免每次都需要输入密码
1. 生成本地密钥对
2. 服务器添加配置
```bash
vim ~/.ssh/authorized_keys

# 添加本机公钥
```
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404051658372.png)

### 3.2、项目配置

和源码配置修改相同
- prod：数据库配置，oss配置，登录配置

### 3.3、打包上传

主要使用 deploy.sh 脚本、上传、运行等操作，注意上面几个动作是一体的
- 修改deploy.sh脚本中，需要上传的jar包目录、目标ip地址
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404051701186.png)

```bash
chmod +x deploy.sh
# 打包jar，并上传到服务器，关闭旧的应用，重新启动新的应用
./deploy.sh prod
```

## 4、小结

本文主要介绍的是如何将技术派整个后端服务部署到服务器上并运行，当前提供了两种方式
- 基于源码的构建方式：
	- 这个模式与本机测试运行的方式差不多，需要注意的就是选择环境，修改相关的配置参数
- 上传jar包运行的方式：
- 在容器化盛行之前的运行机制，jar包运行或者war包放在tomcat这种容器中运行，通常是结合jenkins来使用
至于docker的镜像运行方式，应该是现在的主流了，技术派当然也有这方面的规划，相关的部署教程会放在docker部署这一章节进行体现

最后欢迎大家实操尝鲜，有任何问题可以在下面评论
