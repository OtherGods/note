
技术派项目，本地拉下代码之后，不需要自己在db中手动创建或者导入相关的schema、data，项目直接启动就会自动创建对应的库表，并初始化数据，那么有小伙伴有想过，它到底是怎么实现的么？

# 1、Liquibase数据库表版本管理

liquibase也是我们现在技术派采用的方案，我们将所有的表结构变更、初始化相关数据的变更都记录在案，对于开源项目而言，不管其他小伙伴当前使用的是什么版本，当他拉最新代码之后，可以无需关注库表的变更，启动之后自动同步更新，非常方便

接下来看一下技术派中的使用姿势

## 1.1、依赖配置

在 paicoding-web 模块中，pom.xml 文件中添加
```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
```

然后就是核心的配置，首先是 application.yml 配置文件中，有两个关键参数
```yml
spring:
    liquibase:
    	change-log: classpath:liquibase/master.xml
    	enabled: true # 当实际使用的数据库不支持liquibase，如 mariadb 时，将这个参数设置为false
```
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232213300.png)

**说明：**
- 对于不支持liquibase的数据库，如mariadb，请将上面的 spring.liquibase.enabled 设置为 false
- change-log: 对应的是核心的数据库版本变更配置

master.xml 文件中的内容如下
```xml
<?xml version="1.0" encoding="utf-8"?>  
<databaseChangeLog  
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog  
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">  
  
    <include file="liquibase/changelog/000_initial_schema.xml" relativeToChangelogFile="false"/>  
  
</databaseChangeLog>
```

注意上面这个 include， 这里就是告诉liquibase，所有的变更记录，都放在了  liquibase/changelog/000_initial_schema.xml 这个文件中
> 技术派中现在只有一个include标签，但是实际上是可以有很多个的；一个好的建议是，项目首次启动的初始化表、初始化数据可以是一个 include 标签；后续的每个大的版本迭代，对应一个新的include

再看一下 000_initial_schema.xml 文件的内容
```xml
<?xml version="1.0" encoding="utf-8"?>  
<databaseChangeLog  
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"  
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">  
  
    <property name="now" value="now()" dbms="mysql"/>  
    <property name="autoIncrement" value="true"/>  
  
    <changeSet id="00000000000001" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_schema_221209.sql"/>  
    </changeSet>  
    <changeSet id="00000000000002" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_221209.sql"/>  
    </changeSet>  
    <changeSet id="00000000000003" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_221210.sql"/>  
    </changeSet>  
    <changeSet id="00000000000005" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_221216.sql"/>  
    </changeSet>  
    <!--  专栏类型，新增免费开始时间、结束时间  -->  
    <changeSet id="00000000000006" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/update_schema_221223.sql"/>  
    </changeSet>  
    <!-- user_info表添加ip字段，用于记录访问用户所在地   -->  
    <changeSet id="00000000000007" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/update_schema_221229.sql"/>  
    </changeSet>  
    <!-- 配置表新增 extra 字段 -->  
    <changeSet id="00000000000008" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/update_schema_230103.sql"/>  
    </changeSet>  
    <!-- 技术派介绍文章 -->  
    <changeSet id="00000000000009" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_230103.sql"/>  
    </changeSet>  
    <!-- 重新更新标签 -->  
    <changeSet id="00000000000012" author="LouZai">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_230105.sql"/>  
    </changeSet>  
    <!-- 添加审核中 -->  
    <changeSet id="00000000000013" author="LouZai">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_230130.sql"/>  
    </changeSet>  
    <!-- 添加用户角色 -->  
    <changeSet id="00000000000014" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/update_schema_230131.sql"/>  
    </changeSet>  
    <!-- 重新调整初始化的相关文章内容 -->  
    <changeSet id="00000000000015" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_230415.sql"/>  
    </changeSet>  
    <!-- AI 聊天相关 -->  
    <changeSet id="00000000000016" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/update_schema_230626.sql"/>  
    </changeSet>  
    <!-- db 配置 -->  
    <changeSet id="00000000000017" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/update_schema_230628.sql"/>  
    </changeSet>  
    <!-- 添加枚举字典 -->  
    <changeSet id="00000000000018" author="YiHui">  
        <sqlFile dbms="mysql" endDelimiter=";" encoding="UTF-8" path="liquibase/data/init_data_230629.sql"/>  
    </changeSet></databaseChangeLog>
```

**说明：**
- changeSet标签，id必须唯一，不能出现冲突
- sqlFile里面的path，对应的可以是标准的sql文件，也可以是xml格式的数据库表定义、数据库操作文件
- 一旦写上去，changeSet的顺序不要调整

比如库表创建的sql
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232228312.png)

## 1.2、项目演示

在技术派的项目中，还做了一个事情，就是初始化库，在下面的DataSourceInitializer中有介绍；如果是一个新的项目，接入liquibase之后，数据库，请注意还是需要自己来创建的

项目启动之后，一切正常的话，直接连上数据库可以看到库表创建成功，数据也初始化完成，当然也可以直接观察控制台的输出
- 下面红框中的 ChangeSet xxx ran successfully in 401ms 就表示对应的sql执行成功了
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232230915.png)

## 1.3、注意事项

非常重要的一个点是，上面的每个ChangeSet只会执行一次，因此当执行完毕之后发现不对，要回滚怎么办？或者又需要修改怎么办？

liquibase 提供了回滚的机制，这个放在liquibase的专题中进行说明；现在单独的以修改来说明

当ChangeSet执行完毕之后，对应的sql文件/xml文件（即path定义的文件）不允许再修改，因为db中会记录这个文件的md5，当修改这个文件之后，这个md5也会随之发生改变
- 因此两个解决方案：新增一个changeSet
- 删除 DATABASECHANGELOG 表中 changeSet id对应的记录，然后重新走一遍
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232231769.png)

# 2、DataSourceInitializer首次初始化方案

我们这里主要是借助 DataSourceInitializer 来实现初始化，其核心有两个配置
- DatabasePopulator: 通过addScripts来指定对应的sql文件
- DataSourceInitializer#setEnabled: 判断是否需要执行初始化

我们主要借助DataSourceInitializer来实现Liquibase的表创建、数据变更等操作；但是再次之前，我们还做了一个库的初始化

## 2.1、库初始化

接下来重点需要看的就是needInit方法，我们再这个方法里面，需要判断数据库是否存在，若不存在时，则创建数据库；然后再判断表是否存在，以此来决定是否需要执行初始化方法

入口实现在 ForumDataSourceInitializer
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232235645.png)

```java
/**  
 * 检测一下数据库中表是否存在，若存在则不初始化；否则基于 schema-all.sql 进行初始化表  
 *  
 * @param dataSource  
 * @return  
 */  
private boolean needInit(DataSource dataSource) {  
    if (autoInitDatabase()) {  
        return true;  
    }  
    // 根据是否存在表来判断是否需要执行sql操作  
    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);  
    List list = jdbcTemplate.queryForList("SELECT table_name FROM information_schema.TABLES where table_name = 'user_info' and table_schema = '" + database + "';");  
    return CollectionUtils.isEmpty(list);  
}  
  
  
/**  
 * 数据库不存在时，尝试创建数据库  
 */  
private boolean autoInitDatabase() {  
    // 查询失败，可能是数据库不存在，尝试创建数据库之后再次测试  
    URI url = URI.create(SpringUtil.getConfigOrElse("spring.datasource.url", "spring.dynamic.datasource.master.url").substring(5));  
    String uname = SpringUtil.getConfigOrElse("spring.datasource.username", "spring.dynamic.datasource.master.username");  
    String pwd = SpringUtil.getConfigOrElse("spring.datasource.password", "spring.dynamic.datasource.master.password");  
    try (Connection connection = DriverManager.getConnection("jdbc:mysql://" + url.getHost() + ":" + url.getPort() +  
            "?useUnicode=true&characterEncoding=UTF-8&useSSL=false", uname, pwd);  
         Statement statement = connection.createStatement()) {  
        ResultSet set = statement.executeQuery("select schema_name from information_schema.schemata where schema_name = '" + database + "'");  
        if (!set.next()) {  
            // 不存在时，创建数据库  
            String createDb = "CREATE DATABASE IF NOT EXISTS " + database;  
            connection.setAutoCommit(false);  
            statement.execute(createDb);  
            connection.commit();  
            log.info("创建数据库（{}）成功", database);  
            if (set.isClosed()) {  
                set.close();  
            }  
            return true;  
        }  
        set.close();  
        log.info("数据库已存在，无需初始化");  
        return false;    } catch (SQLException e2) {  
        throw new RuntimeException(e2);  
    }  
}
```

上面的实现比较清晰了，首先是判断库是否存在，这里需要注意的就是，我们需要自己创建db的连接，并执行相关的库判断、初始化sql执行

**为什么不直接使用spring.datasource.url来创建连接？**
- 因为库不存在时，直接使用下面这个url进行连接会抛连接异常
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232314841.png)

## 2.2、表初始化

表的初始化，其实可以理解为项目启动之后执行一些sql，这时主要借助的就是 initializer.setDatabasePopulator

### 2.2.1、核心知识点

虽然技术派新增了一个DbChangeSetLoader 类来实现初始化sql的加载，但实际上，若你完全抛开Liquibase，单纯的希望项目启动后执行某些sql，可以非常简单的实现，直接用下面这种就可以了
- 通过 @Value 来加载需要初始化的sql文件
- 直接通过 ResourceDatabasePoplulator 添加sql资源
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232316799.png)


### 2.2.2、Liquibase兼容方案

在技术派中，做了liquibase的兼容，即找哪些sql需要进行初始化，完全遵循了 Liquibase 中定义的xml文件；

===要想在技术派中使用这种方式进行初始化，如使用mariadb时，需要修改配置参数===
- spring.liquibase.enabeld : false
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232319362.png)

核心的实现点如下：
虽然技术派新增了一个DbChangeSetLoader 类来实现初始化sql的加载，但实际上，若你完全抛开Liquibase，单纯的希望项目启动后执行某些sql，可以非常简单的实现，直接用下面这种就可以了
- 通过 @Value 来加载需要初始化的sql文件
- 直接通过 ResourceDatabasePoplulator 添加sql资源
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232324536.png)

注意上面的实现：
- 我们依然借助了Liquibase 的xml文件来解析来加载对应的数据库表变更历史sql
- 但是需要注意的是，采用DataSourceInitializer初始化方案，只会执行一次；当你从github上拉了代码本地执行之后，后续再拉新的代码，有新的变更时，这些新的变更都不会被执行 （这也是一个todo事项，有兴趣完善这一点的小伙伴可以提MR）

对于liquibase的xml文件解析，核心逻辑再 DbChangeSetLoader 中，借助sax来进行xml文件的解析（Spring也是用sax解析xml的）

具体的实现细节大家可以看源码，这里有两个知识点：
1. 如何加载xml文件
	1. 下面的传参set是相对路径，如  liquibase/data/init_data_221216.sql
	   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232327076.png)
2. sax的xml解析
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232327232.png)

## 2.3、小结

这一章节主要介绍的就是技术派如何实现项目启动之后的库表初始化操作的，结合实际的代码介绍了两种姿势
- Liquibase: 代表的数据库版本管理方式
- DataSourceInitializer: 代表的项目启动之后执行某些初始化操作方式

除此之外，还有 datasource配置方式、jpa配置方式，有兴趣的小伙伴可以查看：
- [【DB系列】数据库初始化-DataSourceInitializer方式](https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/)
- [【DB系列】数据库初始化-jpa配置方式](https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-jpa%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/)
- [【DB系列】数据库初始化-DataSourceInitializer方式](https://spring.hhui.top/spring-blog/2022/12/21/221221-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96-DataSourceInitializer%E6%96%B9%E5%BC%8F/)

抛开上面这个核心的初始化之外，这整个实现过程中，还有挺多的知识点：（这些你都发现了么? 还有哪些没有列出的欢迎评论给出）
1. @Value实现配置加载
2. xml文件的读取，资源文件的加载
3. xml文件的结构解析
4. 基础的jdbc操作方式（库的初始化）
5. 库的初始化校验相关操作
6. @Configuration配置类实现Bean定义












