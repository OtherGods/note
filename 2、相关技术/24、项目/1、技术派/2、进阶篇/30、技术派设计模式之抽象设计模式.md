# 1、抽象设计模式
## 1.1、什么是抽象设计模式

抽象设计模式是一种软件设计的方法论，用于解决特定问题的常见模式。它们提供了一种在软件设计中复用已有解决方案的方法，使设计更加灵活、可维护和可扩展。

抽象设计模式包括了多种设计模式，例如工厂模式、观察者模式、策略模式等。这些设计模式通过定义一组通用的类和接口，并指导如何将它们组合起来以解决特定问题。它们帮助开发者遵循设计原则，如开闭原则、单一职责原则等，从而产生高质量的、可重用的代码。

抽象设计模式的目标是提高代码的可维护性、可扩展性和可复用性。它们通过将不同的功能分离，降低了代码的耦合性，使得系统更加灵活和易于修改。此外，抽象设计模式还能够提高代码的可测试性，因为它们鼓励将功能分解成独立的组件，使得每个组件都可以独立地进行测试。

总之，抽象设计模式是一种在软件设计中常用的方法论，它通过定义一组通用的类和接口，指导如何组合它们以解决特定问题。这些设计模式可以提高代码的可维护性、可扩展性和可复用性，帮助开发者编写高质量的、易于修改和测试的代码。

## 1.2、简单示例

下面是一个模板设计模式的Java使用示例：
```java
// 抽象类作为模板
abstract class Game {
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();
   
   // 模板方法，定义了游戏的整体流程 
   public final void play() {
     // 初始化游戏 
     initialize();
     
     // 开始游戏 
     startPlay();

     // 结束游戏 
     endPlay();
   }
}

// 具体实现类
class Cricket extends Game {

	@Override 
	void initialize() {
		System.out.println("Cricket Game Initialized! Start playing.");
	}
	
	@Override 
	void startPlay() {
		System.out.println("Cricket Game Started. Enjoy the game!");
	}
	
	@Override 
	void endPlay() {
		System.out.println("Cricket Game Finished!");
	}
}

class Football extends Game {

	@Override 
	void initialize() {
		System.out.println("Football Game Initialized! Start playing.");
	}
	
	@Override 
	void startPlay() {
		System.out.println("Football Game Started. Enjoy the game!");
	}
	@Override 
	void endPlay() {
		System.out.println("Football Game Finished!");
	}
}

// 测试类
public class TemplatePatternDemo {
 public static void main(String[] args) {
   Game game = new Cricket();
   game.play();
   System.out.println();

   game = new Football();
   game.play();
 }
}
```

输出结果：
```java
Cricket Game Initialized! Start playing.
Cricket Game Started. Enjoy the game!
Cricket Game Finished!

Football Game Initialized! Start playing.
Football Game Started. Enjoy the game!
Football Game Finished!
```

在上述示例中，抽象类Game定义了游戏的整体流程，并将其中某些方法声明为抽象，由具体的实现类去实现。Game类的play()方法就是模板方法，它定义了游戏的整体流程，并在内部调用了抽象方法。具体的游戏类（如Cricket和Football）继承了Game类，并实现了其中的抽象方法。

在测试类TemplatePatternDemo中，我们通过创建一个Cricket对象和一个Football对象来演示模板设计模式的使用。调用play()方法时，会按照预定义的流程执行游戏。

# 2、技术派中的模板使用实例
## 2.1、应用场景

技术派中的模板设计模式，主要应用在派聪明上，我们提供了多家AI的接入，如当前实现的讯飞、chatgpt、技术派，以及后续可能陆续加入的bat的AI

其中用户与AI的整体聊天流程都是相同的，区别在于具体的AI接入实现上，在这种场景下，我们的抽象设计模式就非常适用了
- 定义ChatService通用的聊天接口
- 抽象类AbsChatService实现聊天交互逻辑 
	- 包括聊天计数，最大次数限制
	- 保存提问/回答信息
	- 同步/异步流式返回的操作封装
- 具体的接入AI实现上面的抽象类，只需要关注与AI交互即可，不需要考虑与用户的聊天流程

## 2.2、实现姿势

关于派聪明的抽象设计模式的核心代码主要在com.github.paicoding.forum.service.chatai.service包路径下，接下来重点给大家解构一下抽象类的设计以及实现思路

### 2.2.1、ChatService接口设计

再进入抽象实现之前，先看一下AI聊天的接口设计

- 一个用于策略模式中表明自己身份的source()方法
- 一个同步聊天、异步聊天的方法chat(), asyncChat()
- 以及获取历史聊天记录的方法getChatHistory()
```java
public interface ChatService {  
  
    /**  
     * 具体AI选择  
     *  
     * @return     */    AISourceEnum source();  
  
    /**  
     * 是否时异步优先  
     *  
     * @return     */    default boolean asyncFirst() {  
        return true;  
    }  
  
    /**  
     * 开始进入聊天  
     *  
     * @param user     提问人  
     * @param question 聊天的问题  
     * @return 返回的结果  
     */  
    ChatRecordsVo chat(Long user, String question);  
  
    /**  
     * 开始进入聊天  
     *  
     * @param user     提问人  
     * @param question 聊天的问题  
     * @param consumer 接收到AI返回之后可执行的回调  
     * @return 同步直接返回的结果  
     */  
    ChatRecordsVo chat(Long user, String question, Consumer<ChatRecordsVo> consumer);  
  
    /**  
     * 异步聊天  
     *  
     * @param user  
     * @param question  
     * @param consumer 执行成功之后，直接异步回调的通知  
     * @return 同步直接返回的结果  
     */  
    ChatRecordsVo asyncChat(Long user, String question, Consumer<ChatRecordsVo> consumer);  
  
  
    /**  
     * 查询聊天历史  
     *  
     * @param user  
     * @return  
     */    ChatRecordsVo getChatHistory(Long user);  
  
}
```

### 2.2.2、抽象类设计

如何根据接口来设计抽象类的实现呢? 这个就属于抽象设计模式的核心要点，要实现一个良好的抽象类，关键字就在于“提炼”，关键要素就在于“业务逻辑主流程”

以技术派中的派聪明的业务逻辑为例进行说明，我们先看一下派聪明的整体业务逻辑是怎样的

下面是提问同步等待返回结果的业务逻辑：
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403031035978.png)

请注意上面的整个业务流程图，其中不同的AI模型之间的差异点仅存于上面的红框内容（即向AI提问并等待回答）

当整个流程清晰之后，抽象类中要实现的点就相对明确了，即上面流程中非红色的地方，就是抽象类的核心实现逻辑

### 2.2.3、抽象类实现策略

我们同样以同步提问返回为例，来看一下抽象类中是怎么实现这个逻辑的

> 以下所有内容可查询源码 com.github.paicoding.forum.service.chatai.service.AbsChatService

1. 实现聊天方法，定义主流程
```java
@Override  
public ChatRecordsVo chat(Long user, String question) {  
    // 构建提问、返回的实体类，计算使用次数，最大次数  
    ChatRecordsVo res = initResVo(user, question);  
    if (!res.hasQaCnt()) {  
        return res;  
    }  
  
    // 执行提问  
    answer(user, res);  
    // 返回AI应答结果  
    return res;  
}   
```
2. 封装提问/返回的业务实体
```java
private ChatRecordsVo initResVo(Long user, String question) {  
    ChatRecordsVo res = new ChatRecordsVo();  
    //选择具体的AI实现  
    res.setSource(source());  
    //最大可提问次数  
    int maxCnt = getMaxQaCnt(user);  
    //已提问次数  
    int usedCnt = queryUserdCnt(user);  
    res.setMaxCnt(maxCnt);  
    res.setUsedCnt(usedCnt);  
  
    ChatItemVo item = new ChatItemVo().initQuestion(question);  
    if (!res.hasQaCnt()) {  
        // 次数已经使用完毕，直接返回对应结果  
        item.initAnswer(ChatConstants.TOKEN_OVER);  
    }  
    res.setRecords(Arrays.asList(item));  
    return res;  
}
```
3. 提问
```java
protected AiChatStatEnum answer(Long user, ChatRecordsVo res) {  
    ChatItemVo itemVo = res.getRecords().get(0);  
    AiChatStatEnum ans = doAnswer(user, itemVo);  
    if (ans == AiChatStatEnum.END) {  
        processAfterSuccessedAnswered(user, res);  
    }  
    return ans;  
}
```
重点注意上面的两处
- 提问public abstract AiChatStatEnum doAnswer(Long user, ChatItemVo chat); 需要由具体的AI来实现的抽象方法，即向AI提问，并等待它回复
- 回答完成之后的后置操作processAfterSuccessedAnswered(user, res) 
	- 更新提问次数
	- 保存历史记录
```java
/**
 * 成功返回之后的后置操作
 *
 * @param user
 * @param response
 */
protected void processAfterSuccessedAnswered(Long user, ChatRecordsVo response) {
    // 回答成功，保存聊天记录，剩余次数-1
    response.setUsedCnt(incrCnt(user).intValue());
    // 写入 MySQL
    userAiService.pushChatItem(source(), user, response.getRecords().get(0));
    // 写入 Redis
    RedisClient.lPush(ChatConstants.getAiHistoryRecordsKey(source(), user), response.getRecords().get(0));
    if (response.getUsedCnt() > ChatConstants.MAX_HISTORY_RECORD_ITEMS) {
        // 最多保存五百条历史聊天记录
        RedisClient.lTrim(ChatConstants.getAiHistoryRecordsKey(source(), user), 0, ChatConstants.MAX_HISTORY_RECORD_ITEMS);
    }
}
```

4. 返回结果

上面这一套实现，基本上就是前面的流程图主流程，在抽象类中完成了用户聊天交互的逻辑，下一层实现则只需要关注与AI的交互即可；

## 2.3、小结

最后这块看完之后，给大家提一个问题，从这个实现中，你最大的感受会是什么？

我自己的感觉抽象模式其核心目的就是为了复用，将一些通用的逻辑放在父类中，然后子类实现各自的差异化部分即可

我们也可以实际来看一下聪明派中的几个具体AI的实现，是不是如我们预期一样，只需要关心与AI的交互

![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403031242447.png)

![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403031242594.png)

![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403031243787.png)

最后同样再次说一下，设计模式并不是形而上的理论知识点，实际上它们非常贴地气，也非常实用；技术派这个实战教程类项目，会努力将高频的设计模式都给大家融入到恰当的业务场景中，希望可以给大家带来已给正向的指引，我是你们的好朋友一灰灰，咱么下篇见


