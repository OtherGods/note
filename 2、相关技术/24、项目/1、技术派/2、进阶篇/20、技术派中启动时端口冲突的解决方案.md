
技术派的项目再本地开发时，实现了一个小小的黑科技，即当本地的8080端口号被占用时，会重新选择一个端口号进行启动，而不是直接抛端口号被占用、启动失败的异常

不知道是否有人发现这个，若发现了这个小功能，那么你又是否去研究了下是怎么实现的么？

建议还没有看过的小伙伴可以先实际的体验，研究一下；若已经看过了，也可以看下本文，是否和自己get到的知识点相同，或者说文中有哪些写的还不够，亦可以提出来改进一下

# 1、端口启动冲突

一般来说，我们会指定每个项目启动的web端口，当不指定时，默认是8080，当本地有多个项目需要启动时，那么端口冲突的问题，就非常突出了

一般出现冲突，表现如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309102134929.png)

技术派项目启动时，表现如下
- 无冲突
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309102135484.png)
- 有冲突
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202309102135497.png)

# 2、解决方案
## 2.1、思路
想要解决端口冲突的问题，思路好像非常明确
1. 首先启动前，判断端口号是否被占用
2. 若未被占用，则直接使用这个端口启动
3. 若被占用，则随机选择一个端口号，重走步骤1

## 2.2.、技术方案

基于上面的实现实录，所以我们需要干的就是两件事
1. 判断端口号是否可用
2. 动态设置应用启动端口号

接下来看一下具体的技术选型
### 2.2.1、选择可用的端口号

> 这种不知道怎么实现时，网上查一下，一般来讲只要不是特别偏门的都能得到结果，我们采用的与一般网上介绍的并无区别

我们这里的关键点在于判断一个端口号是否可用，可选方案就是基于这个端口号尝试建立一个socket，当成功建立并可用，那么表示这个端口号没有被别人占用，可以使用它

一个简单的实现如下：
```java
public static boolean checkIpPort(String ip, int port) {
    Socket socket = new Socket();
    try {
        socket.connect(new InetSocketAddress(ip,port),3000);
        logger.info("地址和端口号可用");
        return true;
    } catch (Exception e) {
        logger.info("地址和端口号不可用");
        return false;
    } finally {
        if (socket != null) {
	        try {
                socket.close();
            } catch (IOException e) {
            }
        }
    }
}
```

**请注意**
- 上面种方式，存在一种可能，在验证时发现端口可用；选中了这个端口，在启动web容器时，可能被其他人给占用了
- 针对上面这种小概率事件，我们不予考虑（但是请注意考不考虑是一回事，知不知道这个方案的缺陷则是另外一回事了）
### 2.2.2、设置SpringMVC端口号

对于如何设置SpringBoot WEB项目的端口，相信大家应该都知道，再配置文件中加一个server.port配置即可
```yml
server:
	port: 8080
```

但是再我们这个场景中，并不是一个写死的配置就可以支持的，需要再代码中，首先找到一个可用的端口号，然后再启用它

一个很容易想到的思路：
- 改用配置覆盖，比如服务启动之时，就找出可用的端口，然后这个端口覆盖配置文件中的值，如
```java
public static void main(String[] args) {
    List<String> list = new ArrayList<>(args.length + 1);
    Collections.addAll(list, args);
    // 手动加一个指定web端口为8082的命令行参数
    list.add("--server.port=8082"); 
    args = list.toArray(new String[]{});
    
    SpringApplication.run(Application.class, args);
}
```

上面这种其实就相当于借助命令行参数的最高优先级，覆盖配置文件中的同名配置

关于配置的修改，除了上面这种方式之外，还可以通过重写PropertySourcesPlaceholderConfigurer来修改配置

> 关于配置动态修改感兴趣的可以等待后续的教程更新

上面这种方案虽然简单，但感觉不太专业，我们实际的诉求是动态设置web容器的端口号，所以完全从这个角度出发，内嵌的tomcat正好提供了相关支持

使用姿势如：
```java
private static int getPort() {
    return (int) (8080 + Math.random() * 10);
}

@Bean
public TomcatConnectorCustomizer customServerPortTomcatConnectorCustomizer() {
    // 方式1. 设置tomcat的端口号
    int port = getPort();
    System.out.println("使用的端口号为： " + port);
    return connector -> connector.setPort(port);
}
```

## 2.3、实现

上面的方案确定之后，我们再来看一下技术派的具体实现姿势
### 2.3.1、端口号选择

> 入口: com.github.paicoding.forum.core.util.SocketUtil

核心的端口号选择逻辑就是找一个可用的端口号,代码比较简单，没有太多可说道的
```java
/**  
 * @author YiHui  
 * @date 2022/11/26  
 */public class SocketUtil {  
  
    /**  
     * 判断端口是否可用  
     *  
     * @param port  
     * @return  
     */  
    public static boolean isPortAvailable(int port) {  
        try {  
            ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket(port, 1, InetAddress.getByName("localhost"));  
            serverSocket.close();  
            return true;        } catch (Exception var3) {  
            return false;  
        }  
    }  
  
    private static Random random = new Random();  
  
    private static int findRandomPort(int minPort, int maxPort) {  
        int portRange = maxPort - minPort;  
        return minPort + random.nextInt(portRange + 1);  
    }  
  
    /**  
     * 找一个可用的端口号  
     *  
     * @param minPort  
     * @param maxPort  
     * @param defaultPort  
     * @return  
     */  
    public static int findAvailableTcpPort(int minPort, int maxPort, int defaultPort) {  
        if (isPortAvailable(defaultPort)) {  
            return defaultPort;  
        }  
  
        if (maxPort <= minPort) {  
            throw new IllegalArgumentException("maxPort should bigger than miPort!");  
        }  
        int portRange = maxPort - minPort;  
        int searchCounter = 0;  
  
        while (searchCounter <= portRange) {  
            int candidatePort = findRandomPort(minPort, maxPort);  
            ++searchCounter;  
            if (isPortAvailable(candidatePort)) {  
                return candidatePort;  
            }  
        }  
  
        throw new IllegalStateException(String.format("Could not find an available %s port in the range [%d, %d] after %d attempts", SocketUtil.class.getName(), minPort, maxPort, searchCounter));  
    }  
}
```

### 2.3.2、端口号动态配置

我们这里做了一个兼容，只有dev启动时，才需要选择可用端口(基于SpEL来实现)；对于部署到测试、预发、生产环境的时候，就是用默认的端口号就行了

> 入口: com.github.paicoding.forum.web.QuickForumApplication#customServerPortTomcatConnectorCustomizer

```java
/**  
 * 兼容本地启动时8080端口被占用的场景; 只有dev启动方式才做这个逻辑  
 *  
 * @return  
 */  
@Bean  
@ConditionalOnExpression(value = "#{'dev'.equals(environment.getProperty('env.name'))}")  
public TomcatConnectorCustomizer customServerPortTomcatConnectorCustomizer() {  
    // 开发环境时，首先判断8080d端口是否可用；若可用则直接使用，否则选择一个可用的端口号启动  
    int port = SocketUtil.findAvailableTcpPort(8000, 10000, webPort);  
    if (port != webPort) {  
        log.info("默认端口号{}被占用，随机启用新端口号: {}", webPort, port);  
        webPort = port;  
    }  
    return connector -> connector.setPort(port);  
}
```

### 2.3.3、小结

看完上面的内容，会发现自主选择一个可用的端口号整体来说比较简单，只要我们对一个任务做好了拆解，然后逐步给出解决方案，其实落地并不会有太大的难度

最后再小结一下本篇文章中涉及到的知识点，下面的问题你有答案么？
- 如何实现只有dev环境才会动态选择端口号？
- 怎么判断一个端口号是否可用？
- 如何动态设置web容器的端口号？

