相信所有奋斗在一线的小伙伴，会很关心自己的系统的运行情况，一般来说，基础设施齐全一点的公司都会有完善的报警方案，那么如果我们是一个小公司呢，不能因为基础设施没有，就失去对象的感知能力吧；如果我们的系统大量异常却不能实时的触达给我们，那么也就只会有一个结果--杀个程序猿祭天

技术派这个项目给大家提供了一个切实可行，而且成本也非常低的解决方案，基于异常日志结合邮箱服务来实现异常报警

# 1、效果体验

首先我们来看一下，这个具体效果是咋样的

## 1.1、测试入口

同样我们先在测试入口TestController中，添加一个输出异常日志的接口
```java
@Slf4j  
@RestController  
@RequestMapping(path = "test")  
public class TestController {
	@RequestMapping(path = "alarm")  
	public ResVo<String> alarm(String content) {  
	    content = StringEscapeUtils.escapeHtml4(content);  
	    log.error("测试异常报警: {}", content);  
	    return ResVo.ok("移除日志接收完成！");  
	}
}
```

但是在本地启动测试时，请注意关闭devtool，它会引发类加载问题（详情后面分析），关闭方式：
- 启动时添加配置 `-Dspring.devtools.restart.enabled=false`
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307232309076.png)


## 1.2、测试效果

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307232311684.png)


# 2、实现方式
## 2.1、设计思路

接下来这个方案的主要出发点在于，当程序出现大量的异常，表明应用多半出现了问题，需要立马发送给项目owner

要实现这个方案，关键点就在于异常出现的感知与上报
1. 异常的捕获，并输出日志（这个感觉属于标配了吧，别告诉我现在还有应用不输出日志文件的...） 
	1. 对于这个感知，借助logback的扩展机制，可以实现，后面介绍
2. 异常上报：邮件发送

关于email的使用姿势，推荐参考博文：
1. [SpringBoot 系列之邮件发送姿势介绍](http://mp.weixin.qq.com/s?__biz=MzU3MTAzNTMzMQ==&mid=2247486591&idx=1&sn=04f18e2f313abd371947f9818e238067&chksm=fce717d3cb909ec575b8e521843eff04edfcf844e59ca976515bc29d8a23782c4d5d30580d0e&token=908878619&lang=zh_CN#rd)
2. [技术派整合邮件服务实现邮件发送](https://www.yuque.com/itwanger/az7yww/dhdfggdcdw09b69g)


## 2.2、自定义appender

定义一个用于错误发送的Appender，如下
```java
public class AlarmUtil extends AppenderBase<ILoggingEvent> {  
    private static final long INTERVAL = 10 * 1000 * 60;  
    private long lastAlarmTime = 0;  
  
    @Override  
    protected void append(ILoggingEvent iLoggingEvent) {  
        if (canAlarm()) {  
            EmailUtil.sendMail(iLoggingEvent.getLoggerName(),  
                    SpringUtil.getConfig("alarm.user", "xhhuiblog@163.com"),  
                    iLoggingEvent.getFormattedMessage());  
        }  
    }  
  
    private boolean canAlarm() {  
        // 做一个简单的频率过滤,一分钟内只允许发送一条报警  
        long now = System.currentTimeMillis();  
        if (now - lastAlarmTime >= INTERVAL) {  
            lastAlarmTime = now;  
            return true;        } else {  
            return false;  
        }  
    }  
}
```

上面的实现做了一个简单的频率控制，后续可以考虑借助gauva的限流器来做实现频率管理

## 2.3、logback配置

接下来就是在日志配置中，使用我们上面定义的Appender

logback-spring.xml文件内容如下：
```xml
<!-- 当出现error异常日志时，邮件报警   -->  
<appender name="errorAlarm" class="com.github.paicoding.forum.core.util.AlarmUtil">  
    <!--如果只是想要 Error 级别的日志，那么需要过滤一下，默认是 info 级别的，ThresholdFilter-->  
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">  
        <level>ERROR</level>  
    </filter>
</appender>

<!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 -->  
<!-- 级别依次为【从高到低】：FATAL > ERROR > WARN > INFO > DEBUG > TRACE  -->  
<!-- additivity=false 表示匹配之后，不再继续传递给其他的logger-->  
<logger name="com.github.paicoding.forum" level="INFO" additivity="false">  
    <appender-ref ref="service"/>  
    <appender-ref ref="STDOUT"/>  
    <appender-ref ref="errorAlarm"/>  
</logger>
```

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307232321000.png)


## 2.4、小结
这篇博文内容比较简单，关键是这个思路，如何将自己掌握的知识点，以合适的方式展现出来解决实际的生产问题，这点就是表现我们价值的时候了




