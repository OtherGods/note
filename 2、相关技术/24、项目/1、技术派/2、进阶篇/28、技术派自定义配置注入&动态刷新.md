参考文章：[补18_自定义属性配置绑定极简实现姿势介绍（没看懂）](2、相关技术/16、常用框架-SpringBoot/补12_SpringBoot配置/补18_自定义属性配置绑定极简实现姿势介绍（没看懂）.md)

> 来自 [AI](https://ora.ai/openai/chatgpt) 对于Spring Boot配置文件读取过程介绍：
> 
> 在Spring Boot中，配置文件的读取过程可以分为以下几个核心步骤：
> 1. 确定配置文件位置：Spring Boot会按照一定的规则来确定配置文件的位置。默认情况下，它会在classpath下寻找名为application.properties或application.yml的文件作为主配置文件。还可以使用spring.config.name和spring.config.location属性来指定其他的配置文件名和位置。
> 2. 加载配置文件：一旦确定了配置文件的位置，Spring Boot会使用PropertySourceLoader来加载配置文件。对于 `.properties` 文件，Spring Boot使用PropertiesPropertySourceLoader，而对于 `.yml` 文件，它使用YamlPropertySourceLoader。这些加载器将配置文件的内容转换为PropertySource对象。
> 3. 解析配置属性：一旦配置文件被加载，Spring Boot会使用PropertySources来管理这些属性源。它会遍历所有的属性源，将配置属性解析为Environment中的键值对。这些属性可以通过Environment接口的方法进行访问，例如getProperty()。
> 4. 属性值注入：在Spring Boot应用程序中，配置属性的值可以通过注解和@Value注解进行注入。Spring Boot会自动将配置属性的值注入到相应的Bean中，以便在应用程序中使用。
> 
> 总的来说，Spring Boot的配置文件读取过程涉及确定文件位置、加载配置文件、解析配置属性和属性值注入。这个过程使得配置文件中的属性可以轻松地在应用程序中使用，并提供了便捷的配置管理方式。

参考：[补1_6种读取SpringBoot的配置](2、相关技术/16、常用框架-SpringBoot/补12_SpringBoot配置/补1_6种读取SpringBoot的配置.md)


对SpringBoot有过了解的小伙伴应该知道，一般我们的配置信息都是放在配置文件application.yml中，然后SpringBoot就会自动加载配置文件中的信息到Environment中，再应用中访问这些配置也比较简单，常见的有@Value, @ConfigurationProperties 以及 environment.getProperty 三种使用姿势（关于具体的配置使用姿势介绍可以看技术派中的配置读取方式的教程）。需要注意的是，SpringBoot应用中的配置读取简单，但是这些配置是不支持动态刷新的

目前技术派的运行，还没有引入配置中心来接管应用的相关配置，所以会看到我们的配置都是放在项目的配置文件中的，如下图
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202401082206161.png)

现在派聪明已经上线，我们将AI相关的配置也放在application-ai.yml配置文件中，由于某些大家都知道的原因，AI模型的secretKey需要经常更新，但是我们现在又没有统一的配置中心，所以就面临着每次更新配置都需要修改配置文件，然后重新部署启动应用，这整个过程还真有点麻烦；

鉴于此，技术派开发了一个对单体应用而言，非常实用的配置扩展，支持从自定义的数据源（MySQL）中获取配置，并注入到Environment中，且优先级最高，同时也需要支持配置的动态刷新

接下来让我们看一下具体的实现姿势

# 1、自定义配置源加载
## 1.1、MySQL存储全局配置

我们将自定义的配置存在数据库中，核心的字段就是配置的key, value

技术派中设计了一个非常简单的全局配置表 global_conf
```sql
CREATE TABLE `global_conf`
(
    `id`          int unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `key`         varchar(128) NOT NULL DEFAULT '' COMMENT '配置key',
    `value`       varchar(512) NOT NULL DEFAULT '' COMMENT '配置value',
    `comment`     varchar(128) NOT NULL DEFAULT '' COMMENT '注释',
    `deleted`     tinyint      NOT NULL DEFAULT '0' COMMENT '是否删除 0 未删除 1 已删除',
    `create_time` timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` timestamp    NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间',
    PRIMARY KEY (`id`),
    KEY           `idx_key` (`key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='全局配置表';
```

**扩展说明**
- 对于实际业务上有相关诉求的小伙伴，建议再这个表上添加一个作用域（namesapce) + 版本（version)，至于原因可以想一下

## 1.2、自定义的配置加载注册

上面虽然定义了全局的配置源，但是我们怎样将这些配置注入到Spring的Environment中呢？

这里可以看一下DynamicConfigContainer的实现

### 1.2.1、step1: 读取配置到内存

首先借助一个Map来存储全局配置
```java
/**
 * 存储db中的全局配置，优先级最高
 */
@Getter
public Map<String, Object> cache;
```

其次就是从db中捞取有效的配置来初始化这个map
```java
@Autowired  
private JdbcTemplate jdbcTemplate;

/**  
 * 从db中获取全量的配置信息  
 *  
 * @return true 表示有信息变更; false 表示无信息变更  
 */  
private boolean loadAllConfigFromDb() {  
    List<Map<String, Object>> list = jdbcTemplate.queryForList("select `key`, `value` from global_conf where deleted = 0");  
    Map<String, Object> val = Maps.newHashMapWithExpectedSize(list.size());  
    for (Map<String, Object> conf : list) {  
        val.put(conf.get("key").toString(), conf.get("value").toString());  
    }  
    if (val.equals(cache)) {  
        return false;  
    }  
    cache.clear();  
    cache.putAll(val);  
    return true;
}
```

### 1.2.2、step2 将配置注册到Environment

将上面读取到的全局配置，封装为MapPropertySource然后注入到envionment，注意下面的addFirst，表示将db中的配置信息作为第一优先级，同名的配置覆盖配置文件中的配置
```java
private void bindBeansFromLocalCache(String namespace, Map<String, Object> cache) {  
    // 将内存的配置信息设置为最高优先级  
    MapPropertySource propertySource = new MapPropertySource(namespace, cache);  
    environment.getPropertySources().addFirst(propertySource);  
    this.binder = new DynamicConfigBinder(this.applicationContext, environment.getPropertySources());  
}
```

### 1.2.3、step3 配置绑定

上一步，初始化了一个DynamicConfigBinder对象，这个就是我们后面用于将配置与@ConfigurationProperties修饰的bean进行绑定的核心实现，后面介绍细节

我们这里重点看一下配置的绑定与刷新策略
```java
public void reloadConfig() {  
	if (loadAllConfigFromDb()) {  
		refreshConfig();  
		log.info("db配置已全部更新: {}", JsonUtil.toStr(cache));  
	}  
}

/**  
 * 支持配置的动态刷新  
 */  
private void refreshConfig() { 
	// 创建一个`Bindable`实例，该实例与特定的bean（在这里称为`bean`）和它的`@ConfigurationProperties`注解相关联
    applicationContext.getBeansWithAnnotation(ConfigurationProperties.class).values()
	    .forEach(bean -> {  
		    // 创建一个与特定bean和它的`@ConfigurationProperties`注解相
		    // 关联的`Bindable`对象，以便后续进行属性绑定操作
	        Bindable<?> target = Bindable.ofInstance(bean)
		        // 这是`Bindable`类的一个方法，它允许你为`Bindable`对象添加注解
		        .withAnnotations(
			        // 在给定的类（这里是`bean`的类）上查找指定的注解（这里是`@ConfigurationProperties`）。如果找到该注解，该方法将返回该注解的实例；否则，返回`null`。
			        AnnotationUtils.findAnnotation(bean.getClass(), ConfigurationProperties.class)
				);
	        bind(target);  
	    }
    );
}

/**  
 * 配置绑定  
 *  
 * @param bindable  
 */  
public void bind(Bindable bindable) {  
    binder.bind(bindable);  
}
```

对于配置的绑定比较简单，无非就是构造一个Bindable对象，那么它是怎么来的呢？

看 `refreshConfig()` 方法的实现，借助Spring容器来获取带有 `@ConfigurationProperties` 注解的bean对象，（也就是说，我们的这个自定义配置的刷新，主要是针对 `@ConfigurationProperties` 来加载配置的实用姿势，当然通过 `Environment#getProperty()` 获取配置的也会刷新），然后重新刷新这些bean对象的配置，让他们可以从自定义的配置源中进行初始化。

所以在系统中，如修改了db中的配置之后，如果希望 `@ConfigurationProperties` 对应的配置信息也会自动更新，那么最简单的方式就是调用一下上面的 `reloadConfig()` 方法

### 1.2.4、step4 定时刷新任务

为了避免我们直接修改db，程序无法感知配置变更这种事情，我们特意实现了一个定时任务，每五分钟加载一下配置
```java
/**  
 * 注册db的动态配置变更  
 */  
private void registerConfRefreshTask() {  
    Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -> {  
        try {  
            reloadConfig();  
        } catch (Exception e) {  
            log.warn("自动更新db配置信息异常!", e);  
        }  
    }, 5, 5, TimeUnit.MINUTES);  
}
```

到这一步，我们的自定义配置的加载注册、定时刷新已经实现（完整代码请直接看项目源码），接下来让我们再看一下配置的绑定

## 1.3、配置绑定

对于配置的绑定，主要借助知识点Binder来实现（这个再介绍自定义多数据源切换方案时有提过，有兴趣的小伙伴可以翻一下）


技术派中的主要实现的是@ConfigurationProperties配置的绑定支持，因此我们的具体实现也主要以它为主，详细看一下DynamicConfigBinder的实现
```java
/**  
 * 自定义动态配置绑定  
 *  
 * @author YiHui  
 * @date 2023/6/20  
 */public class DynamicConfigBinder {  
    private final ApplicationContext applicationContext;  
    private PropertySources propertySource;  
  
    private volatile Binder binder;  
  
    public DynamicConfigBinder(ApplicationContext applicationContext, PropertySources propertySource) {  
        this.applicationContext = applicationContext;  
        this.propertySource = propertySource;  
    }  
  
    public <T> void bind(Bindable<T> bindable) {  
        ConfigurationProperties propertiesAno = bindable.getAnnotation(ConfigurationProperties.class);  
        if (propertiesAno != null) {  
            BindHandler bindHandler = getBindHandler(propertiesAno);  
            getBinder().bind(propertiesAno.prefix(), bindable, bindHandler);  
        }  
    }  
  
    public <T> void bind(String prefix, Bindable<T> bindable, BindHandler bindHandler) {  
        getBinder().bind(prefix, bindable, bindHandler);  
    }  
  
    private BindHandler getBindHandler(ConfigurationProperties annotation) {  
        BindHandler handler = new IgnoreTopLevelConverterNotFoundBindHandler();  
        if (annotation.ignoreInvalidFields()) {  
            handler = new IgnoreErrorsBindHandler(handler);  
        }  
        if (!annotation.ignoreUnknownFields()) {  
            UnboundElementsSourceFilter filter = new UnboundElementsSourceFilter();  
            handler = new NoUnboundElementsBindHandler(handler, filter);  
        }  
        return handler;  
    }  
  
    private Binder getBinder() {  
        if (this.binder == null) {  
            synchronized (this) {  
                if (this.binder == null) {  
                    this.binder = new Binder(getConfigurationPropertySources(),  
                            getPropertySourcesPlaceholdersResolver(), getConversionService(),  
                            getPropertyEditorInitializer());  
                }  
            }  
        }  
        return this.binder;  
    }  
  
    private Iterable<ConfigurationPropertySource> getConfigurationPropertySources() {  
        return ConfigurationPropertySources.from(this.propertySource);  
    }  
  
    /**  
     * 指定占位符的前缀、后缀、默认值分隔符、未解析忽略、环境变量容器  
     *  
     * @return  
     */  
    private PropertySourcesPlaceholdersResolver getPropertySourcesPlaceholdersResolver() {  
        return new PropertySourcesPlaceholdersResolver(this.propertySource);  
    }  
  
    /**  
     * 类型转换  
     *  
     * @return  
     */  
    private ConversionService getConversionService() {  
        return new DefaultConversionService();  
    }  
  
    private Consumer<PropertyEditorRegistry> getPropertyEditorInitializer() {  
        if (this.applicationContext instanceof ConfigurableApplicationContext) {  
            return ((ConfigurableApplicationContext) this.applicationContext)  
                    .getBeanFactory()::copyRegisteredEditorsTo;  
        }  
        return null;  
    }  
}
```

上面的实现没有太多可以介绍的地方，无非是Binder的实用姿势；重点看一下bind()方法，再上面的实现中，强关联了@ConfigurationProperties注解，从它中获取绑定的配置前缀、异常处理策略等；若我们希望实现自定义的绑定策略，也可以将相关参数信息放开，如设计下面这样一个接口
```java
public <T> void bind(String prefix, Bindable<T> bindable, BindHandler bindHandler) {
    getBinder().bind(prefix, bindable, bindHandler);
}
```

### 1.3.1、文件中涉及到类的介绍

这段代码涉及到多个 Spring 框架中的核心类和接口。以下是这些类和接口的详细介绍及其使用场景：

#### 1. `ApplicationContext`
- **作用**：`ApplicationContext` 是 Spring 框架的核心接口之一，表示 Spring 应用的上下文。它负责管理 Spring Bean 的生命周期、依赖注入、事件传播、国际化等功能。
- **使用场景**：在 Spring 应用中，`ApplicationContext` 用于获取和管理 Bean。例如，在 Web 应用中，它通常是通过 `WebApplicationContext` 实现的，用于管理整个 Web 应用的 Bean。

#### 2. `PropertySources`
- **作用**：`PropertySources` 是一个接口，表示多个 `PropertySource` 对象的集合。`PropertySource` 用于从各种来源（如配置文件、系统属性、环境变量等）加载属性。
- **使用场景**：`PropertySources` 用于管理应用配置的来源，在配置属性绑定和解析时提供属性值。

#### 3. `Binder`
- **作用**：`Binder` 类用于绑定属性到对象上。它从 `ConfigurationPropertySource` 中读取配置属性，并将它们绑定到指定的对象。
- **使用场景**：`Binder` 在需要将外部配置（如 YAML 或 properties 文件）绑定到 Java 对象时使用。例如，Spring Boot 的配置属性绑定功能就依赖于 `Binder`。

#### 4. `Bindable`
- **作用**：`Bindable` 是一个泛型类，表示可以绑定的对象。它通常用于描述目标对象及其元数据（如注解）。
- **使用场景**：`Bindable` 在需要将属性绑定到特定对象时使用，尤其是在动态配置绑定场景中。

#### 5. `ConfigurationProperties`
- **作用**：`ConfigurationProperties` 是一个注解，用于将外部配置属性绑定到 Java 类的字段上。它支持前缀配置和复杂对象绑定。
- **使用场景**：在 Spring Boot 应用中，`@ConfigurationProperties` 注解常用于绑定外部配置到 Java Bean。例如，定义一个 `@ConfigurationProperties(prefix = "app")` 的类，可以将 `application.properties` 或 `application.yml` 中 `app` 前缀下的属性绑定到该类。

#### 6. `BindHandler`
- **作用**：`BindHandler` 是一个接口，用于处理绑定过程中发生的事件和错误。它可以用于自定义绑定行为。
- **使用场景**：`BindHandler` 在需要自定义属性绑定过程中的错误处理或事件处理时使用。例如，可以使用 `BindHandler` 忽略绑定过程中的某些错误或记录绑定事件。

#### 7. `IgnoreTopLevelConverterNotFoundBindHandler`
- **作用**：这是 `BindHandler` 的一个实现，用于忽略顶层转换器未找到的错误。
- **使用场景**：在绑定过程中，如果顶层转换器未找到，但不希望因该错误终止绑定过程时使用。

#### 8. `IgnoreErrorsBindHandler`
- **作用**：这是 `BindHandler` 的另一个实现，用于忽略绑定过程中发生的错误。
- **使用场景**：在希望绑定过程中忽略某些错误（如无效字段）并继续绑定时使用。

#### 9. `NoUnboundElementsBindHandler`
- **作用**：这是 `BindHandler` 的另一个实现，用于检测和处理未绑定的配置元素。
- **使用场景**：在希望严格检查所有配置元素是否已绑定并处理未绑定元素时使用。

#### 10. `UnboundElementsSourceFilter`
- **作用**：这是一个用于过滤未绑定元素的类，通常与 `NoUnboundElementsBindHandler` 一起使用。
- **使用场景**：在绑定过程中，需要过滤和处理未绑定的配置元素时使用。

#### 11. `ConfigurationPropertySource`
- **作用**：`ConfigurationPropertySource` 表示配置属性的来源，通常由 `PropertySources` 转换而来。
- **使用场景**：在属性绑定过程中，需要从不同来源读取配置属性时使用。

#### 12. `ConfigurationPropertySources`
- **作用**：`ConfigurationPropertySources` 是一个工具类，用于将 `PropertySources` 转换为 `ConfigurationPropertySource`。
- **使用场景**：在需要从 `PropertySources` 获取 `ConfigurationPropertySource` 以进行属性绑定时使用。

#### 13. `PropertySourcesPlaceholdersResolver`
- **作用**：`PropertySourcesPlaceholdersResolver` 用于解析占位符（如 `${property}`）的值。
- **使用场景**：在需要解析属性文件中占位符时使用，通常与 Spring 的环境配置相关。

#### 14. `ConversionService`
- **作用**：`ConversionService` 是一个接口，用于在不同类型之间进行转换。
- **使用场景**：在需要将属性值转换为不同类型（如 `String` 转 `Integer`）时使用。

#### 15. `DefaultConversionService`
- **作用**：`DefaultConversionService` 是 `ConversionService` 的默认实现，提供了常用类型转换的实现。
- **使用场景**：在需要进行类型转换时，通常使用该默认实现。

#### 16. `PropertyEditorRegistry`
- **作用**：`PropertyEditorRegistry` 是一个接口，用于管理属性编辑器，这些编辑器用于将字符串转换为其他类型。
- **使用场景**：在需要自定义属性转换逻辑时使用。

#### 17. `ConfigurableApplicationContext`
- **作用**：`ConfigurableApplicationContext` 是 `ApplicationContext` 的扩展接口，提供了配置应用上下文的额外功能。
- **使用场景**：在需要动态注册或注销 Bean，或自定义应用上下文配置时使用。

#### 18. `Consumer`
- **作用**：`Consumer` 是 Java 8 引入的函数式接口，表示一个接受单个输入参数并且不返回结果的操作。
- **使用场景**：在需要定义一个接受输入但不返回结果的操作时使用，通常用于 lambda 表达式和方法引用。

以上是代码中涉及的主要类和接口的详细介绍及其使用场景。这些类和接口在 Spring 框架中扮演了重要角色，确保了应用的配置管理、属性绑定和类型转换的灵活性和可扩展性。

# 2、实例演示与小结
## 2.1、实例演示

上面给大家介绍了基础的实现，但是具体是啥样呢？接下来给大家看一下具体的实现效果，直接以线上的技术派为例

我们在TestController中提供了两个测试方法，一个是打印Bean信息，一个是刷新配置
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202401082247853.png)

如以全局配置application-config.yml中的view.site.welcomeInfo配置为例，配置文件中的配置如下
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202401082305302.png)

但是db中我们同样新建一个对应的配置，内容做一个修改
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202401082306153.png)

根据上面的实现策略，db中的配置优先级最高，因此GlobalViewConfig中的welcomeInfo信息应该与db中的配置保持一致
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202401082306530.png)

接下来再给大家演示一下配置修改之后，并实现刷新的全流程
![1.gif](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403021521139.gif)


## 2.2、小结

在这里我们通过非常简单的方式（两个类，两百行代码）实现了自定义配置加载，并支持了动态刷新，文中所涉及到的知识点超过CURD的基本范围，就我个人而言，这个实例，可用于解释为什么我们要去看源码、了解框架背后实现机制和原理，当你的武器库掌握得足够多时，遇到你超出你当前能力范畴的需求时，你才有足够的能力去适应、去拆解，也可以更好的选择最小的实现方案来支撑，减少自己的工作量

最后基于本文给大家一个我个人的观点（不保证准确）：不要盲目的给自己的系统引入第三方的依赖，一个系统本身依赖项越少，它的稳定性将会更高



