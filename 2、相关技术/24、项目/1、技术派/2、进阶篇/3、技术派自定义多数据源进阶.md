
之前的一篇介绍了技术派是如何实现自定义的动态数据源切换的技术方案，但是当时提出了几个问题 [2、技术派自定义多数据源方案](2、相关技术/24、项目/1、技术派/2、进阶篇/2、技术派自定义多数据源方案.md)

上文的方案中，有几个明显的缺陷
1. 如果一个方法上有数据源选择注解，但是内部开了子线程做异步处理，那么上下文存储的数据源会失效
2. 一个方法上指定了数据源，它又调用其他有也指定了数据源的方法，当前的方案会存在数据源的选择冲突
3. druid数据源怎么兼容？

接下来我们基于上面的问题，来升级我们的实现方案

# 1、支持嵌套的数据源选择方案

前面提出的一个非常大的问题就是再整个链路中，只支持选择一次的数据源，显然这种方式缺陷比较大，也很容易出现问题；

若我们希望实现在选择了一个数据源之后，在执行某个代码片段时，还可以继续再选择其他的数据源，那么应该怎么实现呢？

首先我们来看一下之前的实现方案
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310102228922.png)

在执行sql时，从上下文中获取当前选中的数据源,前面设计的上下文直接使用线程上下文保存
```java
public class DsContextHolder {
    /**
     * 使用继承的线程上下文，支持异步时选择传递
     */
    private static final ThreadLocal<String> CONTEXT_HOLDER = new InheritableThreadLocal<>();
}
```

从上面的这个实现来看，上下文赋值只能有一次，当我们希望可以实现标题的效果，自然我们应该想到的数据结构就是栈 -- 后进先出

我们定义一个DsNode节点来存储选中的数据源，区别于之前的String，它除了记录选中的数据源之外，还记录前一次选中的数据源
```java
public static class DsNode {
    DsNode pre;
    String ds;

    public DsNode(DsNode parent, String ds) {
        pre = parent;
        this.ds = ds;
    }
}
```

然后将线程上下文存储的替换为DsNode
```java
/**
 * 使用继承的线程上下文，支持异步时选择传递
 * 使用DsNode，支持链式的数据源切换，如最外层使用master数据源，内部某个方法使用slave数据源；但是请注意，对于事务的场景，不要交叉
 */
private static final ThreadLocal<DsNode> CONTEXT_HOLDER = new InheritableThreadLocal<>();
```

接下来就需要重点看一下写入当前选中的数据源的逻辑
- 每当有一个新的数据源选中时，新创建一个DsNode，并重新加入ThreadLocal
- 之前的上下文中的DsNode将作为新的DsNode的上一个节点
```java
public static void set(String dbType) {
    DsNode current = CONTEXT_HOLDER.get();
    CONTEXT_HOLDER.set(new DsNode(current, dbType));
}
```

移除上下文则不能像之前那么粗暴，而是要实现栈的弹出效果
- 如果无选中的数据源，直接返回
- 若之前选中的DsNode，存在上一个节点，则将上一个节点重新写入上下文
- 若之前选中的DsNode，不存在上一个节点，则清空上下文
```java
public static void reset() {
    DsNode ds = CONTEXT_HOLDER.get();
    if (ds == null) {
        return;
    }
    if (ds.pre != null) {
        // 退出当前的数据源选择，切回去走上一次的数据源配置
        CONTEXT_HOLDER.set(ds.pre);
    } else {
	    CONTEXT_HOLDER.remove();
    }
}
```

上面整个改完之后，其他的地方无需做任何修改，现在就支持多级的数据源动态选择了

# 2、Druid数据源支持
## 2.1、DruidDataSource支持

有关注过上一个实现方案的小伙伴应该注意到了DataSource的实例化方式
```java
@Slf4j
@Configuration
@ConditionalOnProperty(prefix = "spring.dynamic", name = "primary")
@EnableConfigurationProperties(DsProperties.class)
public class DataSourceConfig {
    @Bean
    @Primary
    public DataSource dataSource(DsProperties dsProperties) {
        Map<Object, Object> targetDataSources = Maps.newHashMapWithExpectedSize(dsProperties.getDatasource().size());
        dsProperties.getDatasource().forEach((k, v) -> targetDataSources.put(k.toUpperCase(), v.initializeDataSourceBuilder().build()));
        // ……省略细节
	}
}
```

上面这段代码，初始化DataSource对象实际使用的是:
`DataSourceProperties.initializeDataSourceBuilder().build()`

而它创建的数据源是默认的HiKariDataSource，但是当我们项目中实际使用的是DuridDataSource时，怎么办？

这个时候就需要我们数据源的实例化进行微调了; 首先添加一个Druid包的检测工具类（如果druid都没有引入，就不需要实例化DruidDataSource了）
```java
public class DruidCheckUtil {  
  
    /**  
     * 判断是否包含durid相关的数据包  
     *  
     * @return  
     */  
    public static boolean hasDuridPkg() {  
        return ClassUtils.isPresent("com.alibaba.druid.pool.DruidDataSource", DataSourceConfig.class.getClassLoader());  
    }
}
```

接下来就是将前面创建数据源的地方，单独的抽出一个方法，根据实际的情况来选择DataSource type
```JAVA
/**  
 * 整合主从数据源  
 *  
 * @param dsProperties  
 * @return 1  
 */@Bean  
@Primary  
public DataSource dataSource(DsProperties dsProperties) {  
    Map<Object, Object> targetDataSources = Maps.newHashMapWithExpectedSize(dsProperties.getDatasource().size());  
    dsProperties.getDatasource().forEach((k, v) -> targetDataSources.put(k.toUpperCase(), initDataSource(k, v)));  
  
    if (CollectionUtils.isEmpty(targetDataSources)) {  
        throw new IllegalStateException("多数据源配置，请以 spring.dynamic 开头");  
    }  
  
    MyRoutingDataSource myRoutingDataSource = new MyRoutingDataSource();  
    Object key = dsProperties.getPrimary().toUpperCase();  
    if (!targetDataSources.containsKey(key)) {  
        if (targetDataSources.containsKey(MasterSlaveDsEnum.MASTER.name())) {  
            // 当们没有配置primary对应的数据源时，存在MASTER数据源，则将主库作为默认的数据源  
            key = MasterSlaveDsEnum.MASTER.name();  
        } else {  
            key = targetDataSources.keySet().iterator().next();  
        }  
    }  
  
    log.info("动态数据源，默认启用为： " + key);  
    myRoutingDataSource.setDefaultTargetDataSource(targetDataSources.get(key));  
    myRoutingDataSource.setTargetDataSources(targetDataSources);  
    return myRoutingDataSource;  
}  
  
  
public DataSource initDataSource(String prefix, DataSourceProperties properties) {  
    if (!DruidCheckUtil.hasDuridPkg()) {  
        log.info("实例化HikarDataSource: {}", prefix);  
        return properties.initializeDataSourceBuilder().build();  
    }  
  
    if (properties.getType() == null || !properties.getType().isAssignableFrom(DruidDataSource.class)) {  
        log.info("实例化HikarDataSource: {}", prefix);  
        return properties.initializeDataSourceBuilder().build();  
    }  
  
    log.info("实例化DruidDataSource: {}", prefix);  
    // fixme 知识点：手动将配置赋值到实例中的方式  
    return Binder.get(environment).bindOrCreate(DsProperties.DS_PREFIX + ".datasource." + prefix, DruidDataSource.class);  
}
```

注意上面实例化DruidDataSource的方法，从envionment中读取配置前缀为spring.dynamic.datasource.master配置值来初始化DruidDataSource的成员变量，并创建一个对应的实例

上面这一块实现之后，我们的数据源就支持DruidDataSource了， 如再db配置信息中，添加一些druid的相关配置
```JAVA
spring:
	dynamic: # 动态数据源  
		primary: master # 这个表示默认的数据源  
		datasource:  
			master:  
				# 数据库名，从配置 database.name 中获取  
				url: jdbc:mysql://localhost:3306/${database.name}?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai  
				username: root  
				password: 271441  
				type: com.alibaba.druid.pool.DruidDataSource  
				#DruidDataSource自有属性  
				filters: stat  
				initialSize: 0  
				minIdle: 1  
				maxActive: 200  
				maxWait: 10000  
				time-between-eviction-runs-millis: 60000  
				min-evictable-idle-time-millis: 200000  
				testWhileIdle: true  
				testOnBorrow: true  
				validationQuery: select 1
```

然后我们的默认数据源master就是druidDataSource了；因为slave的没有指定type，所以还是默认的HikarDataSource，再项目启动之后，也可以从启动日志上看
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310102317895.png)


## 2.2、Mybatis拦截器适配

对于使用DruidDataSource的场景，我们还需要将前面介绍的SqlStateInterceptor做一点改造，以支持用户名的获取，关键点就再下面这里
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310102321443.png)


## 2.3、Druid监控配置

既然使用到了druid数据源，那么不得不额外提一句的就是它配套的监控配置了，技术派中也给出了相关的设置
```java
/**  
 * 在数据源实例化之后进行创建  
 *  
 * @return  
 */  
@Bean  
@ConditionalOnExpression(value = "T(com.github.paicoding.forum.core.dal.DruidCheckUtil).hasDuridPkg()")  
public ServletRegistrationBean<?> druidStatViewServlet() {  
    //先配置管理后台的servLet，访问的入口为/druid/  
    ServletRegistrationBean<?> servletRegistrationBean = new ServletRegistrationBean<>(  
            new StatViewServlet(), "/druid/*");  
    // IP白名单 (没有配置或者为空，则允许所有访问)  
    servletRegistrationBean.addInitParameter("allow", "127.0.0.1");  
    // IP黑名单 (存在共同时，deny优先于allow)  
    servletRegistrationBean.addInitParameter("deny", "");  
    servletRegistrationBean.addInitParameter("loginUsername", "admin");  
    servletRegistrationBean.addInitParameter("loginPassword", "admin");  
    servletRegistrationBean.addInitParameter("resetEnable", "false");  
    log.info("开启druid数据源监控面板");  
    return servletRegistrationBean;  
}
```

至于项目中是否有Druid相关包，则可以直接通过控制paicoding-core项目的pom.xml中的依赖来决定
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232155394.png)

仅以技术派这个工程进行说明：

- 当<scope>provided</scope> 被注释，则表示项目中包含druid相关包
- 当 `<scope>provided</scope>` 未注释，则表示项目中不包含druid相关包

有没有druid的包，将直接决定访问druid监控页面到底长啥样，访问连接：http://127.0.0.1:8080/druid/index.html
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310232158615.png)

# 3、小结

本文作为动态数据源切换的第三篇，再前面自定义的数据源切换方案上进行了补充和完善，支持嵌套的数据源选择，同时也支持了druidDataSource的配置

文中的所有技术，都可以直接再项目源码中获取，接下来给大家小结一下相关的知识点（敲黑板，下面的是重点，前面的不想看没关系，下面的东西请牢记）

- 使用栈的数据结构，结合上下文来实现嵌套的数据源切换方案
- InheritableThreadLocal支持主子线程数据共享
- 使用Binder来手动基于Spring的配置信息来实例并初始化bean
- 如何判断项目中是否引入了某个包的方式
- 条件判断是否需要创建某个bean @ConditionalOnExpression
- DruidDataSource的实例化方式
- Druid数据源的监控配置方式







