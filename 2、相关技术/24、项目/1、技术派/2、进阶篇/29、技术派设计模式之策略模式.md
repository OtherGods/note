
技术派的实现源码中，很多地方多有使用到设计模式来让我们的编码显得更“优雅”，本文将给大家实例介绍一下“设计模式之-策略模式”在派聪明中的实现方式

# 1、策略模式
## 1.1、什么是策略模式

```text
策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列的算法，将每个算法封装起来，使得它们可以相互替换。策略模式让算法的变化独立于使用它的客户端。

在策略模式中，有三个角色：上下文（Context）、策略（Strategy）和具体策略（ConcreteStrategy）。

上下文（Context）类持有一个策略对象，并在需要执行算法时调用策略对象的方法。上下文类不关心具体的算法实现，只关心调用合适的策略对象。

策略（Strategy）接口定义了算法的方法，具体的策略类实现了该接口，提供了不同的算法实现。

具体策略（ConcreteStrategy）类是策略的具体实现，封装了不同的算法实现。

策略模式的优点是：
1. 策略模式将算法的定义和使用分离，使得算法可以独立于使用它的客户端进行变化和演化。

2. 策略模式可以方便地扩展和添加新的算法，只需要实现新的具体策略类即可，无需修改上下文类。

3. 策略模式可以减少大量的条件判断语句，提高代码的可读性和可维护性。

策略模式的缺点是：
1. 客户端需要了解不同的策略类，选择合适的策略对象，增加了客户端的复杂性。

2. 策略模式增加了对象的数量，每个具体策略类都需要一个独立的对象，导致系统中对象数量增加。
```

# 2、技术派的策略模式实例
## 2.1、应用场景

技术派中的策略模式，主要应用在派聪明上，我们提供了多家AI的接入，如当前实现的讯飞、chatgpt、技术派，以及后续可能陆续加入的bat的AI

那么用户来了，到底和哪个AI进行聊天呢？ 为了解决各种if/else的选择条件分支，我们采用策略模式来处理这个场景
1. 设计一个通用的ChatService 接口，定义聊天相关的方法
2. 具体策略实现：
	1. ChatGptAiServiceImpl： chatgpt的聊天实现
	2. XunFeiAiServiceImpl： 讯飞星火大模型的聊天实现
	3. PaiAiDemoServiceImpl：技术派价值1个亿的聊天实现
3. 选择策略的上下文：ChatServiceFactory

## 2.2、实现姿势

> 注意：我们这里主要介绍的是策略模式这一行为型设计模式，具体的AI实现细节请看后文

### 2.2.1、接口定义

根据策略模式的标准定义流程，我们同样定义了Ai聊天的接口
```java
public interface ChatService {  
  
    /**  
     * 具体AI选择  
     *  
     * @return     */    AISourceEnum source();  
  
    /**  
     * 是否时异步优先  
     *  
     * @return     */    default boolean asyncFirst() {  
        return true;  
    }  
  
    /**  
     * 开始进入聊天  
     *  
     * @param user     提问人  
     * @param question 聊天的问题  
     * @return 返回的结果  
     */  
    ChatRecordsVo chat(Long user, String question);  
  
    /**  
     * 开始进入聊天  
     *  
     * @param user     提问人  
     * @param question 聊天的问题  
     * @param consumer 接收到AI返回之后可执行的回调  
     * @return 同步直接返回的结果  
     */  
    ChatRecordsVo chat(Long user, String question, Consumer<ChatRecordsVo> consumer);  
  
    /**  
     * 异步聊天  
     *  
     * @param user  
     * @param question  
     * @param consumer 执行成功之后，直接异步回调的通知  
     * @return 同步直接返回的结果  
     */  
    ChatRecordsVo asyncChat(Long user, String question, Consumer<ChatRecordsVo> consumer);  
  
  
    /**  
     * 查询聊天历史  
     *  
     * @param user  
     * @return  
     */    ChatRecordsVo getChatHistory(Long user);  
  
}
```

注意上面的接口定义中，核心的方法 AISourceEnum source(), 它将主要用于表明当前的这个ChatService的实现，对应的是哪个AI源，后续再选择具体的策略实现时，非常重要

### 2.2.2、策略实现

技术派在具体的策略实现中，又利用到了模板设计模式，在这里我就不详细展开，简单的看一下三个实现

```java
@Service
public class PaiAiDemoServiceImpl extends AbsChatService {

    @Override
    public AISourceEnum source() {
        return AISourceEnum.PAI_AI;
    }
}

@Service
public class ChatGptAiServiceImpl extends AbsChatService {
    @Override
    public AISourceEnum source() {
        return AISourceEnum.CHAT_GPT_3_5;
    }
}

@Service
public class XunFeiAiServiceImpl extends AbsChatService {
    @Override
    public AISourceEnum source() {
        return AISourceEnum.XUN_FEI_AI;
    }
}
```

### 2.2.3、策略选择上下文

接下来重点看一下我们这个上下文的实现，这里主要借助了Spring的bean List注入方式，一次拿到上面的这些策略实现，然后保存到一个Map中，然后格局AiSourceEnum来进行选择具体的策略
```java
@Component  
public class ChatServiceFactory {  
    private final Map<AISourceEnum, ChatService> chatServiceMap;  
  
  
    public ChatServiceFactory(List<ChatService> chatServiceList) {  
        chatServiceMap = Maps.newHashMapWithExpectedSize(chatServiceList.size());  
        for (ChatService chatService : chatServiceList) {  
            chatServiceMap.put(chatService.source(), chatService);  
        }  
    }  
  
    public ChatService getChatService(AISourceEnum aiSource) {  
        return chatServiceMap.get(aiSource);  
    }  
}
```

### 2.2.4、实际使用场景

实际的使用则是在ChatFacade (没错我们又用了外观设计模式来封装AI的相关逻辑，简化对外的使用难度)
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403021637256.png)


## 2.3、小结

最后再来看一下技术派中使用策略模式来封装AI的选择的实现方式，其优劣与文章最开头提问派聪明回答的优劣是否能映射上

**略模式的优点是：**
```text
1. 策略模式将算法的定义和使用分离，使得算法可以独立于使用它的客户端进行变化和演化。
2. 策略模式可以方便地扩展和添加新的算法，只需要实现新的具体策略类即可，无需修改上下文类。
3. 策略模式可以减少大量的条件判断语句，提高代码的可读性和可维护性。
```

上面三点基本没啥疑问，技术派中新的AI接入，直接实现ChatService即可实现扩展，上下文并不需要进行修改，当然整个使用过程中，也没有什么if/else来走条件分支的选择；至于第一点，这个就是面向接口编程的标准优势，也没什么好说的

**策略模式的缺点是：**
```text
1. 客户端需要了解不同的策略类，选择合适的策略对象，增加了客户端的复杂性。
2. 策略模式增加了对象的数量，每个具体策略类都需要一个独立的对象，导致系统中对象数量增加。
```

对于第一个缺点，当然一般的策略模式确实是有这个问题的，特别是当策略非常多时，我应该选择哪一个呢？

但是在技术派中却是用ChatFacade外观模式来解决了这个问题，将具体的AI选择逻辑给屏蔽了，对于调用者而言，直接调用 chatService.autoChat(question, 响应回调) 就可以进行愉快的玩耍了（对，这就是外观模式的魅力）
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202403021720837.png)

对于第二个缺点，没啥好说的，当系统非常庞大时，这确实算问题；一般来讲，这种对象太多的问题，不需要我们这些CURDer来考虑

最后再补一句，设计模式并不是形而上的理论知识点，实际上它们非常贴地气，也非常实用；技术派这个实战教程类项目，会努力将高频的设计模式都给大家融入到恰当的业务场景中，希望可以给大家带来已给正向的指引，我是你们的好朋友一灰灰，咱么下篇见

