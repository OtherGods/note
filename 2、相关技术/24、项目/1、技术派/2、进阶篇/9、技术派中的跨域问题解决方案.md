技术派中的跨域问题有两处：
1. 页面加载CDN图片时
2. admin端请求后端API接口时

这篇内容会从源码的角度带大家来看一下，让大家真正掌握跨域问题的解决思路和发生原因。

# 1、跨域？

## 1.1、跨域概念

跨域对于前后端开发者来说，就像一块狗皮膏药，无论是面试还是开发中，都会经常遇到。

之所以出现跨域问题，是因为浏览器的同源策略，为了隔离潜在的恶意文件，为了防御来自邪门歪道的攻击，浏览器限制了从同一个源加载的文档或脚本与来自另一个源的资源进行交互。

同源策略要求，如果两个网页的协议（protocol）、域名（domain）和端口（port）都相同，它们才被认为是同源的，否则就是跨域。

同源策略是浏览器为了保护用户信息安全而实施的一种安全机制，可以防止恶意网站通过脚本窃取用户在其他网站上的数据，或者伪造用户身份执行一些操作。

瞧，现在有一个 Web 应用，运行在 5173 端口下，它有一个 login 请求，请求的是 8080 端口，那么就会出现跨域问题。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307301846617.png)

## 1.2、复现

具体如何复现呢？
1. 运行技术派，以便提供后端服务。技术派默认是运行在8080端口下的
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307301850774.png)
2. 安装Node.js,Node.js是一个基于Chrome V8 JavaScript引擎的开源，跨平台的运行时环境，它允许在服务器端口运行javaScript代码。在Node.js出现之前，JavaScript仅用于浏览器端，用于处理客户端逻辑与用户互动。Nodejs的出现极大的扩展了JavaScript的使用范围，使之成为一个全栈开发语言。
3. 通过命令行创建一个新的Vie+React应用，你也可以选择Vue
   `npx create-vite my-app`
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307301918753.png)
   进入my-app目录：cd my-app
   安装依赖项：npm install
   在src目录下编辑App.tsx，内容如下所示：
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307302130135.png)
   运行 Vite，Vite（法语中的"快"）是一个现代化的、轻量级的、基于浏览器的原生 ES 模块开发工具。Vite 由 Vue.js 的创始人 Evan You（尤雨溪）开发，旨在为前端开发带来更快的构建速度和更高的开发效率。：
   `npm run dev`
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307302133318.png)
   现在，在浏览器中访问 http://localhost:5173/,
   你将在控制台看到跨域错误，因为前端应用（在5173端口）正在尝试访问非同源的后端服务（在8080端口）。这就是一个典型的跨域问题。

# 2、如何解决跨域问提？

理解了跨域问题的发生原因，那么解决跨域问题也就简单了。

我们可以使用 Node.js 代理来解决跨域问题，思路就是，在本地创建一个虚拟服务器，对 5173 端口下的前端请求进行代理，同时接收 8080 端口下的服务器端响应，这样服务端和服务端进行数据的交互就不会出现跨域问题了。

在 vite.config.ts 的 server 配置中添加代理配置。
```
proxy: {
  "/admin": {
		target: "http://127.0.0.1:8080/",
		changeOrigin: true,
		rewrite: path => path.replace(/^\/api/, "")
  }
}
```

它将所有以 /admin 开头的请求转发到 http://127.0.0.1:8080/。
- proxy: 一个包含代理规则的对象。
- /admin: 指定要代理的路径前缀。所有以 /admin 开头的请求都将被代理。
- target: 目标服务器的 URL。所有匹配的请求将被转发到此 URL。
- changeOrigin: 设置为 true 时，代理会修改请求头中的 Host，使其与目标服务器一致。这有助于避免某些服务器对 Host 头进行验证的情况。
- rewrite: 一个函数，用于重写请求路径。在这个例子中，它会移除路径中的 /api 部分。例如，一个请求路径为 /admin/some-endpoint 的请求将被代理到 http://127.0.0.1:8080/some-endpoint。

运行技术派的admin端`npm run dev`
输入用户名和密码，点击登录，可以看到别的请求已经发送成功了！
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307302148863.png)

简单总结一下，通过在同源服务器上设置代理（如 Nginx、Node.js），将请求转发到目标服务器。这样，客户端和代理服务器之间就可以满足同源策略，而代理服务器与目标服务器之间的通信就不再受到同源策略的限制。做法很简单。

# 3、图片遇到跨域怎么办？

通常情况下，我们会把图片放到OSS上，然后通过CDN来访问，这样可以减轻服务器的压力，只不过，可能需要支付一部分OSS和CDN的费用。

在技术派中的图片也是放在OSS上的，这样的话，也会遇到跨域问题。技术派是运行在 https://paicoding.com/ 域名下的，而图片目前用的CDN连接是沉默王二另一个网站Java进阶之路上的子域名 https://cdn.tobebetterjavaer.com 下

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307302153865.png)

这样的话，如果不做处理，同样是会收到同源策略限制的。

那该怎么解除跨域限制呢？

第一步，给需要解除限制的图片加上 crossOrigin 属性。
```
const img = document.getElementById("cover0")
// 服务器 cdn 开启跨域消息头
img.setAttribute('crossOrigin', '')
console.log("img:", img)
```

crossOrigin 属性是 HTML 元素（如 <img>、`<video>`、`<audio>` 和 `<canvas>`）的一个属性，用于指定元素发起的跨域资源请求应该如何处理。当浏览器加载跨域资源时，crossOrigin 属性可以控制是否允许元素的内容在同源的上下文中被访问和操作。

crossOrigin 属性有三种可能的值：
1. anonymous：这个值表示发起跨域请求时，不会发送任何凭证（如 cookies、HTTP 认证或客户端 SSL 证书）。但是，服务器需要响应一个允许该来源跨域访问的 CORS 头部 Access-Control-Allow-Origin。如果服务器没有返回这个头部，浏览器将阻止对资源的访问。
2. use-credentials：这个值表示发起跨域请求时，会携带凭证。与 anonymous 类似，服务器需要返回允许该来源跨域访问的 CORS 头部 Access-Control-Allow-Origin，并且还需要返回 Access-Control-Allow-Credentials: true 头部。如果服务器没有返回这些头部，浏览器将阻止对资源的访问。
3. 未设置（默认值）：当 crossOrigin 属性未设置时，默认情况下，浏览器将阻止跨域资源的访问和操作。

第二步，登录阿里云 CDN 控制台，添加跨域配置。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202307302157038.png)

之后就可以跨域访问了。

# 4、总结
整个跨域问题的解决方案是非常简单的，重要的是一定要了解掌握解决思路。尤其是对于后端的小伙伴来说，第一次接触前端，很容易栽在跨域这个问题上。

可能前端的小伙伴也一样，明明代码没问题啊，为什么访问不到后端接口呢？

