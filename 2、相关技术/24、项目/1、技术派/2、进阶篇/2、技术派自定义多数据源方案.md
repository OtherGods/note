
一个项目使用多数据源这种场景可以说是很常见的了，当然这里说的多数据源并不是专指一个项目，连接几个不同的数据库（对于信奉微服务治理美学的小伙伴而言，一个微服务是不建议出现连接多个不同数据库的）， 相比于此，更有可能出现的则是主从数据库的配置

主库负责读写，从库专指读查询；那么我们一般针对这种多数据源，可以怎么显现呢？

接下来我们以技术派的实际实现来进行说明，手把手教你实现一个自定义的多数据源动态切换方案

本文主要涉及以下知识点:
- 动态数据源切换
- AOP
- MyBatis拦截器
- 上下文
- 函数式方法
- 自定义配置加载解析

## 1、环境准备

考虑到直接在本机搭建一个主从的数据库比较麻烦，所以我们根据账号权限的方式来模拟主从数据源的配置
- 主库：拥有完整的读写权限
- 从库：只拥有读权限

因此我们只需要再自己的服务器上，新建一个只读的账号即可，操作方式如下：
1. 创建账号
   创建一个只读账号，userName = 'readonly', password = ''
   `CREATE USER 'readonly'@'%' IDENTIFIED BY '';`
2. 授予技术派db的只读权限
   `grant select on pai_coding.* to 'readonly'@'%';`
3. 刷新权限
   `FLUSH PRIVILEGES;`

# 2、方案设计
## 2.1、基础知识点

主要借助AbstractRoutingDataSource来实现动态数据源，简单介绍下它的几个核心要点：
- defaultTargetDataSource：表示默认使用的数据源
- Map<Object, Object> targetDataSources: 动态数据源可以根据key来切换使用的数据源
```java
protected Object determineCurrentLookupKey() {
    // 返回上面 targetDataSources 对应的key
    // 根据这个key，来抉择最终实际选择的数据源时哪个
}
```

重点关注上面的这个方法，当我们想使用哪个数据源时，就发回这个数据源对应的key，在实际代码执行时，就根据这个key，到 targetDataSources这个map中找对应的数据源

## 2.2.、设计方案

基于上面的动态数据源的几个核心知识点，所以当我们需要实现动态数据源切换时，自然而然可以想到的一个方案就是在每次db执行之前，塞入这个希望使用的数据源key
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310072322517.png)

如上的设计思路，主要借助aop的思想来实现，通过上下文来存储当前方法的执行，具体希望使用的数据源，然后再执行的sql的时候，AbstractRoutingDataSource直接从上下文中获取key，以此来抉择具体的数据源

基于上面的方案，接下来我们补充一下细节

### 2.2.1、数据源选择方式

通过AOP的方式进行拦截，写入数据源选择，这种方式适用于方法级别的粒度，基于此常见的实现方式就是通过自定义注解，来标注需要使用的数据源

如自定义注解，通过设置ds值来指定这个方法执行时选择的数据源
```java
@Retention(RetentionPolicy.RUNTIME)  
@Target({ElementType.METHOD, ElementType.TYPE})  
public @interface DsAno {  
    /**  
     * 启用的数据源，默认主库  
     *  
     * @return  
     */  
    MasterSlaveDsEnum value() default MasterSlaveDsEnum.MASTER;  
  
    /**  
     * 启用的数据源，如果存在，则优先使用它来替换默认的value  
     *     * @return  
     */  
    String ds() default "";  
}
```

但是，请注意上面这种方式不适用于代码块维度的数据源选择策略

### 2.2.2、上下文

通过上下文来保存当前选中的数据源，因此可以借助 ThreadLocal 来实现

一个简单的数据源选择上下文
```java
public class DsContextHolder{
    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();
}
```

### 2.2.3、动态数据源选择

自定义的动态数据源路由方案
```java
protected Object determineCurrentLookupKey() {
    return DsContextHolder.get();
}
```

### 2.2.4、aop拦截

借助AOP，拦截方法、类上拥有DS注解的方法执行，然后从这个注解中读取选中的数据源，然后写入上下文；再方法执行完毕之后，清空上下文

基本的实现策略
```java
* 切入点, 拦截类上、方法上有注解的方法，用于切换数据源
 */
@Pointcut("@annotation(com.github.paicoding.forum.core.dal.DsAno) || @within(com.github.paicoding.forum.core.dal.DsAno)")
public void pointcut() {
}

@Around("pointcut()")
public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
    DsAno ds = getDsAno(proceedingJoinPoint);
    try {
	    if (ds != null && (StringUtils.isNotBlank(ds.ds()) || ds.value() != null)) {
            // 当上下文中没有时，则写入线程上下文，应该用哪个DB
            DsContextHolder.set(StringUtils.isNoneBlank(ds.ds()) ? ds.ds() : ds.value().name());
        }
        return proceedingJoinPoint.proceed();
    } finally {
        // 清空上下文信息
        if (ds != null) {
            DsContextHolder.reset();
        }
	}
}

private DsAno getDsAno(ProceedingJoinPoint proceedingJoinPoint) {
    MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
    Method method = signature.getMethod();
    DsAno ds = method.getAnnotation(DsAno.class);
    if (ds == null) {
        // 获取类上的注解
        ds = (DsAno) proceedingJoinPoint.getSignature().getDeclaringType().getAnnotation(DsAno.class);
    }
    return ds;
}
```

# 3、多数据源实现
## 3.1、多数据源定义

对于多数据源，因此无法直接使用默认的数据源配置，我们借助默认的配置规则，加一个多数据源版本的设计

对应的多数据源的配置规则如下：
```yml
spring:
  dynamic: # 动态数据源
    primary: master # 这个表示默认的数据源
    datasource:
      master:
        # 数据库名，从配置 database.name 中获取
        url: jdbc:mysql://localhost:3306/${database.name}?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
        username: root
        password:
      slave:
        # 数据库名，从配置 database.name 中获取
        url: jdbc:mysql://localhost:3306/${database.name}?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
        username: readonly
        password:
```

注意上面的定义：
- spring.dynamic.primary: 指定默认启用的数据源
- spring.dynamic.datasource.数据源名.配置: 这里的数据源名不能重复（忽略大小写），数据源下的配置与默认的配置参数要求一致

对应的数据源配置加载方式直接借助了Spring的ConfigurationProperties来实现（注意：这是个知识点）
```java
@Data
@ConfigurationProperties(prefix = "spring.dynamic")
public class DsProperties {
	/**
     * 默认数据源
     */
    private String primary;

    /**
     * 多数据源配置
     */
    private Map<String, DataSourceProperties> datasource;
}
```


## 3.2、多数据源注册

上面是数据源的配置定义与加载，但是我们需要基于上面的数据源配置来实例化对应的datasource

核心实现再 com.github.paicoding.forum.core.dal.DataSourceConfig
```java
/**  
 * 当配置了多数据源时，启用  
 *  
 * @author YiHui  
 * @date 2023/4/30  
 */@Slf4j  
@Configuration  
@ConditionalOnProperty(prefix = "spring.dynamic", name = "primary")  
@EnableConfigurationProperties(DsProperties.class)  
public class DataSourceConfig { 
  
    public DataSourceConfig() {  
        log.info("动态数据源初始化!");  
    }  
  
    @Bean  
    public DsAspect dsAspect() {  
        return new DsAspect();  
    }  
  
    /**  
     * 整合主从数据源  
     *  
     * @param dsProperties  
     * @return 1  
     */    
    @Bean  
    @Primary
    public DataSource dataSource(DsProperties dsProperties) {  
        Map<Object, Object> targetDataSources = Maps.newHashMapWithExpectedSize(dsProperties.getDatasource().size());  
        dsProperties.getDatasource().forEach((k, v) -> targetDataSources.put(k.toUpperCase(), initDataSource(k, v)));  
  
        if (CollectionUtils.isEmpty(targetDataSources)) {  
            throw new IllegalStateException("多数据源配置，请以 spring.dynamic 开头");  
        }  
  
        MyRoutingDataSource myRoutingDataSource = new MyRoutingDataSource();  
        Object key = dsProperties.getPrimary().toUpperCase();  
        if (!targetDataSources.containsKey(key)) {  
            if (targetDataSources.containsKey(MasterSlaveDsEnum.MASTER.name())) {  
                // 当们没有配置primary对应的数据源时，存在MASTER数据源，则将主库作为默认的数据源  
                key = MasterSlaveDsEnum.MASTER.name();  
            } else {  
                key = targetDataSources.keySet().iterator().next();  
            }  
        }  
  
        log.info("动态数据源，默认启用为： " + key);  
        myRoutingDataSource.setDefaultTargetDataSource(targetDataSources.get(key));  
        myRoutingDataSource.setTargetDataSources(targetDataSources);  
        return myRoutingDataSource;  
    }
}
```

上面的实现比较简单，但是有几个关键信息给大家指出一下

1. `@ConditionalOnProperty(prefix = "spring.dynamic", name = "primary")`
   这是一个条件注入的限定，表示只有配置了动态数据源时，才会生效，即当前的技术派系统支持单数据源以及多数据源两种方式自有切换的
   
   如果我只想使用单数据源的模式（默认场景）   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310092350446.png)
   当我们希望开启多数据源时，将上图中的注释打开即可
2. datasource实例化方式
   `DataSourceProperties.initializeDataSourceBuilder().build()`
   
   通过上面的方式创建的DataSource为默认的HikariDataSource
   
   因此当你的项目之前使用的是Druid时，请注意，这里就需要进行调整了（那么怎么调整呢？）
3. 自定义数据源
   ```java
   public class MyRoutingDataSource extends AbstractRoutingDataSource {
    @Nullable
    @Override
    protected Object determineCurrentLookupKey() {
        return DsContextHolder.get();
    }
}
	```

## 3.3、上下文定义

我们通过上下文来保存当前选择的数据源，因此一个简单的的上下文设计如下
```java
/**  
 * 数据源选择上下持有类，用于存储当前选中的是哪个数据源  
 *  
 * @author YiHui  
 * @date 2023/4/30  
 */public class DsContextHolder {  
    /**
     * 使用继承的线程上下文，支持异步时选择传递
     * 使用DsNode，支持链式的数据源切换，如最外层使用master数据源，内部某个方法使用slave数据源；但是请注意，对于事务的场景，不要交叉
     */
    private static final ThreadLocal<String> CONTEXT_HOLDER = new InheritableThreadLocal<>();
  
    private DsContextHolder() {  
    }  
  
  
    public static void set(String dbType) {
        CONTEXT_HOLDER.set(dbType);  
    }  
  
    public static String get() {
        return CONTEXT_HOLDER.get();
    }  
  
  
    public static void set(DS ds) {  
        set(ds.name().toUpperCase());  
    }  
  
  
    /**  
     * 移除上下文  
     */  
    public static void reset() {  
		CONTEXT_HOLDER.remove();  
    }
}
```

**注意：若发现上面的设计与代码中不一致的，无需疑问，因为本文介绍到是第一版的实现方式，代码的为改进后方案**

## 3.4、AOP实现

借助AOP来简化数据源的选择，因此我们先定义一个注解DsAno，可以放在类上，表示这个类下所有的共有方法，都走某个数据源；也可以放在方法上，且方法上的优先级大于类上的注解
```java
@Retention(RetentionPolicy.RUNTIME)  
@Target({ElementType.METHOD, ElementType.TYPE})  
public @interface DsAno {  
    /**  
     * 启用的数据源，默认主库  
     *  
     * @return  
     */  
    MasterSlaveDsEnum value() default MasterSlaveDsEnum.MASTER;  
  
    /**  
     * 启用的数据源，如果存在，则优先使用它来替换默认的value  
     *     * @return  
     */  
    String ds() default "";  
}
```

上面的设计中，针对常见的主从切换做了一个简单的兼容，定义了一个主从数据源的枚举，同样也是基于简化使用体验的出发
```java
public interface DS {
    /**
     * 使用的数据源名
     *
     * @return
     */
    String name();
}

public enum MasterSlaveDsEnum implements DS {
    /**
     * master主数据源类型
     */
    MASTER,
    /**
     * slave从数据源类型
     */
    SLAVE;
}
```

具体的aop拦截实现方式
```java
@Aspect  
public class DsAspect {  
    /**  
     * 切入点, 拦截类上、方法上有注解的方法，用于切换数据源  
     */  
    @Pointcut("@annotation(com.github.paicoding.forum.core.dal.DsAno) || @within(com.github.paicoding.forum.core.dal.DsAno)")  
    public void pointcut() {  
    }  
  
    @Around("pointcut()")  
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {  
        DsAno ds = getDsAno(proceedingJoinPoint);  
        try {  
            if (ds != null && (StringUtils.isNotBlank(ds.ds()) || ds.value() != null)) {  
                // 当上下文中没有时，则写入线程上下文，应该用哪个DB  
                DsContextHolder.set(StringUtils.isNoneBlank(ds.ds()) ? ds.ds() : ds.value().name());  
            }  
            //proceedingJoinPoint.  
            return proceedingJoinPoint.proceed();  
        } finally {  
            // 清空上下文信息  
            if (ds != null) {  
                DsContextHolder.reset();  
            }  
        }  
    }  
  
    private DsAno getDsAno(ProceedingJoinPoint proceedingJoinPoint) {  
        MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();  
        Method method = signature.getMethod();  
        DsAno ds = method.getAnnotation(DsAno.class);  
        if (ds == null) {  
            // 获取类上的注解  
            ds = (DsAno) proceedingJoinPoint.getSignature().getDeclaringType().getAnnotation(DsAno.class);  
        }  
        return ds;  
    }  
}
```

## 3.5、编程式数据源选择

前面也说到了，基于AOP方式的申明式数据源选择方案虽然简单，但是实用场景可能没有那么全，因此我们也设计了一种编程式的方式
```java
/**  
 * 手动指定数据源的用法  
 *  
 * @author YiHui  
 * @date 2023/4/30  
 */public class DsSelectExecutor {  
  
    /**  
     * 有返回结果  
     *  
     * @param ds  
     * @param supplier  
     * @param <T>  
     * @return  
     */  
    public static <T> T submit(DS ds, Supplier<T> supplier) {  
        DsContextHolder.set(ds);  
        try {  
            return supplier.get();  
        } finally {  
            DsContextHolder.reset();  
        }  
    }  
  
    /**  
     * 无返回结果  
     *  
     * @param ds  
     * @param call  
     */  
    public static void execute(DS ds, Runnable call) {  
        DsContextHolder.set(ds);  
        try {  
            call.run();  
        } finally {  
            DsContextHolder.reset();  
        }  
    }  
}
```

pass: 从上面实现也可以反推为啥 `MasterSlaveDsEnum` 这个枚举类为什么要继承DS接口

# 4、测试与小结
## 4.1、测试

基于次上面的整个多数据源支持方案已经落地实现，接下来就是写几个case来验证一下了
直接再TestController中新加几个
```java
@DsAno(MasterSlaveDsEnum.SLAVE)
@RestController
@RequestMapping(path = "test")
public class TestController {
    /**
     * 只读测试，如果有更新就会报错
     *
     * @return
     */
    @GetMapping(path = "ds/read")
    public String readOnly() {
        // 保存请求计数
        statisticsSettingService.saveRequestCount(ReqInfoContext.getReqInfo().getClientIp());
        return "使用从库：更新成功!";
    }
    
    /**
     * 只读测试，如果有更新就会报错
     *
     * @return
     */
    @GetMapping(path = "ds/write2")
    public String write2() {
        log.info("------------------- 业务逻辑进入 ----------------------------");
        int old = statisticsSettingService.getStatisticsCount().getPvCount();
        DsSelectExecutor.execute(MasterSlaveDsEnum.MASTER, () -> statisticsSettingService.saveRequestCount(ReqInfoContext.getReqInfo().getClientIp()));
        // 保存请求计数
        int n = statisticsSettingService.getStatisticsCount().getPvCount();
        log.info("------------------- 业务逻辑结束 ----------------------------");
        return "编程式切换主库：更新成功! old=" + old + " new=" + n;
    }
}
```

直接访问第一个只读的接口，日志输出如下
- 借助前面介绍的mybatis拦截器打印的日志，表示当前数据源为 slave(用户名区分）
- 执行更新操作时报异常
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310100019498.png)



当访问第二个master数据源接口时
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202310100018143.png)


## 4.2、小结

最后再小结一下整个的设计实现，主要基于AOP + 上下文的方式，配合AbstractRoutingDataSource来实现多数据源的自由选择

但是请注意，上面的实现，还有几个缺陷
1. 如果一个方法上有数据源选择注解，但是内部开了子线程做异步处理，那么上下文存储的数据源会失效
2. 一个方法上指定了数据源，它又调用其他有也指定了数据源的方法，当前的方案会存在数据源的选择冲突
3. druid数据源怎么兼容？

以上问题，欢迎各位小伙伴给出你们的解决方案和看法，我们下一篇将带来改进后的实现策略
