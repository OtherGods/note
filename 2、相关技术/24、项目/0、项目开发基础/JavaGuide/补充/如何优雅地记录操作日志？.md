没看明白，暂时跳过;

参照：[补1_Spring Boot 日志配置](2、相关技术/24、项目/1、技术派/4、补充/补1_Spring%20Boot%20日志配置.md)

操作日志几乎存在于每个系统中，而这些系统都有记录操作日志的一套 API。操作日志和系统日志不一样，操作日志必须要做到简单易懂。所以如何让操作日志不和业务逻辑耦合，如何让操作日志的内容易于理解，让操作日志的接入更加简单？上面这些都是本文要回答的问题，主要围绕着如何“优雅”地记录操作日志展开描述。

## 1. 操作日志的使用场景

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202408171445264.png)

**系统日志和操作日志的区别**

**系统日志**：系统日志主要是为开发排查问题提供依据，一般打印在日志文件中；系统日志的可读性要求没那么高，日志中会包含代码的信息，比如在某个类的某一行打印了一个日志。

**操作日志**：主要是对某个对象进行新增操作或者修改操作后记录下这个新增或者修改，操作日志要求可读性比较强，因为它主要是给用户看的，比如订单的物流信息，用户需要知道在什么时间发生了什么事情。再比如，客服对工单的处理记录信息。
- **单纯的文字记录**，比如：2021-09-16 10:00 订单创建。
- **简单的动态的文本记录**，比如：2021-09-16 10:00 订单创建，订单号：NO.11089999，其中涉及变量订单号“NO.11089999”。
- **修改类型的文本**，包含修改前和修改后的值，比如：2021-09-16 10:00 用户小明修改了订单的配送地址：从“金灿灿小区”修改到“银盏盏小区” ，其中涉及变量配送的原地址“金灿灿小区”和新地址“银盏盏小区”。
- **修改表单**，一次会修改多个字段。

## 2. 实现方式
### 2.1 使用 Canal 监听数据库记录操作日志

Canal 是一款**基于 MySQL 数据库增量日志解析**，提供增量数据订阅和消费的开源组件，通过**采用监听数据库 Binlog 的方式，这样可以从底层知道是哪些数据做了修改，然后根据更改的数据记录操作日志**。

这种方式的**优点是和业务逻辑完全分离**。**缺点也很明显，局限性太高，只能针对数据库的更改做操作日志记录**，如果修改涉及到其他团队的 RPC 的调用，就没办法监听数据库了，举个例子：给用户发送通知，通知服务一般都是公司内部的公共组件，这时候只能在调用 RPC 的时候手工记录发送通知的操作日志了。

### 2.2 通过日志文件的方式记录
```java
log.info("订单创建")
log.info("订单已经创建，订单编号:{}", orderNo)
log.info("修改了订单的配送地址：从“{}”修改到“{}”， "金灿灿小区", "银盏盏小区")
```

这种方式的操作记录需要解决三个问题。

**问题一：操作人如何记录**

借助 SLF4J 中的 MDC 工具类，把操作人放在日志中，然后在日志中统一打印出来。首先在用户的拦截器中把用户的标识 Put 到 MDC 中。
```java
@Component  
public class UserInterceptor extends HandlerInterceptorAdapter {  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //获取到用户标识  
        String userNo = getUserNo(request);  
        //把用户 ID 放到 MDC 上下文中  
        MDC.put("userId", userNo);  
        return super.preHandle(request, response, handler);  
    }  
      
    private String getUserNo(HttpServletRequest request) {  
        // 通过 SSO 或者Cookie 或者 Auth信息获取到 当前登陆的用户信息  
        return null;  
    }  
}
```

其次，把 userId 格式化到日志中，使用 %X{userId} 可以取到 MDC 中用户标识。
```xml
<pattern>"%d{yyyy-MM-dd HH:mm:ss.SSS} %t %-5level %X{userId} %logger{30}.%method:%L - %msg%n"</pattern>
```

**问题二：操作日志如何和系统日志区分开**

通过配置 Log 的配置文件，把有关操作日志的 Log 单独放到一日志文件中。
```xml
//不同业务日志记录到不同的文件  
<appender name="businessLogAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">  
    <File>logs/business.log</File>  
    <append>true</append>  
    <filter class="ch.qos.logback.classic.filter.LevelFilter">  
        <level>INFO</level>  
        <onMatch>ACCEPT</onMatch>  
        <onMismatch>DENY</onMismatch>  
    </filter>  
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">  
        <fileNamePattern>logs/业务A.%d.%i.log</fileNamePattern>  
        <maxHistory>90</maxHistory>  
        <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">  
            <maxFileSize>10MB</maxFileSize>  
        </timeBasedFileNamingAndTriggeringPolicy>  
    </rollingPolicy>  
    <encoder>  
        <pattern>"%d{yyyy-MM-dd HH:mm:ss.SSS} %t %-5level %X{userId} %logger{30}.%method:%L - %msg%n"</pattern>  
        <charset>UTF-8</charset>  
    </encoder>  
</appender>  
  
<logger name="businessLog" additivity="false" level="INFO">  
    <appender-ref ref="businessLogAppender"/>  
</logger>
```

然后在 Java 代码中单独的记录业务日志。

```java
//记录特定日志的声明 
private final Logger businessLog = LoggerFactory.getLogger("businessLog"); 

//日志存储 
businessLog.info("修改了配送地址");
```

**问题三：如何生成可读懂的日志文案**

可以采用 LogUtil 的方式，也可以采用切面的方式生成日志模板，后续内容将会进行介绍。这样就可以把日志单独保存在一个文件中，然后通过日志收集可以把日志保存在 Elasticsearch 或者数据库中，接下来看下如何生成可读的操作日志。

### 2.3 通过 LogUtil 的方式记录日志

```java
LogUtil.log(orderNo, "订单创建", "小明")模板 
LogUtil.log(orderNo, "订单创建，订单号"+"NO.11089999", "小明") 
String template = "用户%s修改了订单的配送地址：从“%s”修改到“%s”" 
LogUtil.log(orderNo, String.format(tempalte, "小明", "金灿灿小区", "银盏盏小区"), "小明")
```

> 这里解释下为什么记录操作日志的时候都绑定了一个 OrderNo，因为操作日志记录的是：某一个“时间”“谁”对“什么”做了什么“事情”。当查询业务的操作日志的时候，会查询针对这个订单的的所有操作，所以代码中加上了 OrderNo，记录操作日志的时候需要记录下操作人，所以传了操作人“小明”进来。

上面看起来问题并不大，在修改地址的业务逻辑方法中使用一行代码记录了操作日志，接下来再看一个更复杂的例子：
```java
private OnesIssueDO updateAddress(updateDeliveryRequest request) {  
    DeliveryOrder deliveryOrder = deliveryQueryService.queryOldAddress(request.getDeliveryOrderNo());  
    // 更新派送信息，电话，收件人，地址  
    doUpdate(request);  
    String logContent = getLogContent(request, deliveryOrder);  
    LogUtils.logRecord(request.getOrderNo(), logContent, request.getOperator);  
    return onesIssueDO;  
}  
  
private String getLogContent(updateDeliveryRequest request, DeliveryOrder deliveryOrder) {  
    String template = "用户%s修改了订单的配送地址：从“%s”修改到“%s”";  
    return String.format(tempalte, request.getUserName(), deliveryOrder.getAddress(), request.getAddress);  
}
```

可以看到上面的例子使用了两个方法代码，外加一个 `getLogContent` 的函数实现了操作日志的记录。当业务变得复杂后，记录操作日志放在业务代码中会导致业务的逻辑比较繁杂，最后导致 `LogUtils.logRecord()` 方法的调用存在于很多业务的代码中，而且类似 `getLogContent()` 这样的方法也散落在各个业务类中，对于代码的可读性和可维护性来说是一个灾难。下面介绍下如何避免这个灾难。

### 2.4 方法注解实现操作日志

为了解决上面问题，一般采用 AOP 的方式记录日志，让操作日志和业务逻辑解耦，接下来看一个简单的 AOP 日志的例子。
```java
@LogRecord(content="修改了配送地址") 
public void modifyAddress(updateDeliveryRequest request){ 
	// 更新派送信息 电话，收件人、地址 
	doUpdate(request); 
}
```

我们可以在注解的操作日志上记录固定文案，这样业务逻辑和业务代码可以做到解耦，让我们的业务代码变得纯净起来。可能有同学注意到，上面的方式虽然解耦了操作日志的代码，但是记录的文案并不符合我们的预期，文案是静态的，没有包含动态的文案，因为我们需要记录的操作日志是： 用户%s修改了订单的配送地址，从“%s”修改到“%s”。接下来，我们介绍一下如何优雅地使用 AOP 生成动态的操作日志。

## 3. 优雅地支持 AOP 生成动态的操作日志

### 3.1 动态模板

一提到动态模板，就会涉及到让变量通过占位符的方式解析模板，从而达到通过注解记录操作日志的目的。模板解析的方式有很多种，这里使用了 SpEL（Spring Expression Language，Spring表达式语言）来实现。我们可以先写下期望的记录日志的方式，然后再看下能否实现这样的功能。
```java
@LogRecord(content = "修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”") 
public void modifyAddress(updateDeliveryRequest request, String oldAddress){ 
	// 更新派送信息 电话，收件人、地址 
	doUpdate(request); 
}
```

通过 SpEL 表达式引用方法上的参数，可以让变量填充到模板中达到动态的操作日志文本内容。 但是现在还有几个问题需要解决： 
- 操作日志需要知道是哪个操作人修改的订单配送地址。
- 修改订单配送地址的操作日志需要绑定在配送的订单上，从而可以根据配送订单号查询出对这个配送订单的所有操作。
- 为了在注解上记录之前的配送地址是什么，在方法签名上添加了一个和业务无关的 oldAddress 的变量，这样就不优雅了。

为了解决前两个问题，我们需要把期望的操作日志使用形式改成下面的方式：











转载自：[如何优雅地记录操作日志？](https://tech.meituan.com/2021/09/16/operational-logbook.html)


