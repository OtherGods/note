# 典型回答

Seata 是一个开源的分布式事务解决方案，旨在提供高性能和简单的事务管理服务，用于微服务架构。其中，AT 模式是 Seata 支持的一种事务模式，全称为 `Auto-Commit Transaction`，也就是自动提交事务模式。

它是一种无侵入性的事务模式，对于业务开发来说，不需要做代码上面的改造，就可以实现分布式事务。

Seata中包含了三个组件：
- **TC (Transaction Coordinator)**：事务协调器，负责管理全局事务的生命周期，包括开始事务、提交事务和回滚事务。
- **TM (Transaction Manager)**：事务管理器，定义事务的范围，负责开启和结束全局事务。
- **RM (Resource Manager)**：资源管理器，管理资源对象，如数据库连接，负责资源的注册与释放。

详见：
[20、Seata的实现原理是什么](2、相关技术/21、分布式/Hollis/20、Seata的实现原理是什么.md)
[36、Seata的4种事务模式，各自适合的场景是什么？](2、相关技术/21、分布式/Hollis/36、Seata的4种事务模式，各自适合的场景是什么？.md)

**AT 模式基于两阶段提交（2PC）协议进行工作，通过==代理数据源==的方式，使得本地事务（如数据库事务）与全局事务（跨服务的事务）能够统一管理。**

所谓代理数据源，其实就是在应用自己的`Datasource`之上做了一层代理，是的原本的JDBC `Datasource`变成Seata `DatasourceProxy`，这样就可以<font color="blue" size=5>在这层代理当中控制SQL语句的提交、回滚等操作</font>。
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411241917083.png)

在Seata的AT模式中，事务的提交也是分成了2阶段的。

## 一阶段

关于InnoDB更新事务：[11、InnoDB的一次更新事务过程是怎么样的？](2、相关技术/4、数据库-MySQL/Hollis/11、InnoDB的一次更新事务过程是怎么样的？.md)

1. RM针对本次要执行的本地事务的SQL进行解析，得到SQL的类型、修改的表以及where条件等信息。
2. RM 根据 SQL 解析的结果，先进行一次查询，根据查询结果生成相应的 `before image`（变更前数据快照）。
3. 执行SQL语句进行数据库变更。
4. 再查询一次变更后的记录，作为`after image`（变更后的数据快照）
5. 把 *==before/after image==* 以及 *==业务 SQL==* 相关的信息 **==组成一条回滚日志记录，插入到 `UNDO_LOG` 表中（引入seata后在本地数据库中需要新建这张表）==**。
6. 提交前，向 TC 注册分支，并**申请表中本次需要修改的所有记录的==排他锁==（）**。
7. **将业务数据的更新和前面生成的 `UNDO LOG` 一并==提交（本地事务中的提交）==**。
8. 将本地事务的执行结果上报给TC。
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411241923707.png)

这里依赖的完全是本地事务，基于本地事务的ACID的特性，可以保证业务数据和回滚日志（`before/after image`）可以在同一个本地事务中被提交。

数藏项目中的undo_log表
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508292128840.png)


## 二阶段

在一阶段，业务操作完成后，TM 向 TC 发起提交请求。TC 会发起投票请求，询问所有的RM是否可以提交事务。

那么就会出现2种情况：

**提交事务**：如果所有的 RM 都同意提交，说明他们此时他们的本地事务都已经执行成功了，那么TC就可以释放该全局事务的所有锁，然后异步调用RM清理Undo Log
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411241942239.png)

**回滚事务**：如果任一 RM 投票否决或者出现故障，那么就要协调事务进行回滚。
1. 通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。
2. 会拿当前数据先跟afterImage进行比较，如果一致，执行第三步。如果不一致则在比较一下当前数据是否和beforeImage，如果一致性，说明未提交成功或者已经回滚了，则无需处理。如果不一致，那么说明有脏数据了，需要抛出异常，人工处理。
3. 根据 UNDO LOG 中的before image和业务 SQL 的相关信息生成并执行回滚的语句。
4. 执行SQL并提交本地事务。并把本地事务的执行结果上报给 TC。
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202411241944594.png)

# 扩展知识

## 如何使用AT模式

AT模式的使用非常简单，就是把Spring中的`@Transactional` 替换成 `@GlobalTransactional`，如下面的例子：
```java
@GlobalTransactional
public void purchase(String userId, String commodityCode, int count, int money) {
	jdbcTemplateA.update("update stock_tbl set count = count - ? where commodity_code = ?", new Object[] {count, commodityCode});
	jdbcTemplateB.update("update account_tbl set money = money - ? where user_id = ?", new Object[] {money, userId});
}
```

这里面的`jdbcTemplateA`和`jdbcTemplateB`是两个不同的数据源，通过Seata的分布式事务来协调ACID。

## undolog格式

关于undolog，可以看：[4.2.6.实现AT模式](2、相关技术/22、微服务/微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程/高级篇/学习资料/day02-分布式事务/讲义/分布式事务.md#4.2.6.实现AT模式)，这里面说在RM数据库中会创建undo_log表用于存储快照；

undolog的格式，以下内容来自Seata官网中的例子：
```json
{
	"branchId": 641789253,
	"undoItems": [{
		"afterImage": {
			"rows": [{
				"fields": [{
					"name": "id",
					"type": 4,
					"value": 1
				}, {
					"name": "name",
					"type": 12,
					"value": "GTS"
				}, {
					"name": "since",
					"type": 12,
					"value": "2014"
				}]
			}],
			"tableName": "product"
		},
		"beforeImage": {
			"rows": [{
				"fields": [{
					"name": "id",
					"type": 4,
					"value": 1
				},{
					"name": "name",
					"type": 12,
					"value": "TXC"
				}, {
					"name": "since",
					"type": 12,
					"value": "2014"
				}]
			}],
			"tableName": "product"
		},
		"sqlType": "UPDATE"
	}],
	"xid": "xid:xxx"
}
```

## ChatGPT关于Seata的全局锁

Seata中的AT模式（Automatic Transaction）通过全局锁机制实现分布式事务的隔离性和一致性。全局锁确保在分布式环境中，各个事务对资源的操作不会互相冲突，从而保证数据的完整性。下面详细介绍Seata AT模式中的全局锁机制。

### 全局锁概述

全局锁是Seata AT模式实现事务隔离性的关键机制。它确保在全局事务执行期间，所有涉及的资源在全局范围内被锁定，防止其他事务同时访问和修改这些资源。

### 全局锁的工作机制

1. **全局事务开始**：
    - 当一个全局事务开始时，事务管理器（TM）会生成一个全局事务ID（XID）。
    - XID在整个事务过程中唯一标识这个全局事务。
2. **分支事务注册**：
    - 每个参与全局事务的分支事务在执行前会向全局事务协调器（TC）注册，并请求全局锁。
    - TC会根据分支事务请求的资源，检查是否有其他事务持有这些资源的锁。
3. **获取全局锁**：
    - 如果请求的资源没有被其他事务锁定，TC会授予分支事务全局锁。
    - 如果资源已经被其他事务锁定，当前事务会被挂起，等待资源释放。
4. **执行分支事务**：
    - 获取全局锁后，分支事务开始执行，Seata会拦截业务操作并记录数据的before image和after image。
    - 分支事务执行过程中，资源保持锁定状态，防止其他事务修改。
5. **提交或回滚分支事务**：
    - 分支事务执行完成后，会根据全局事务的最终状态（提交或回滚），通知TC释放或保持全局锁。
    - 在提交阶段，分支事务提交更改并释放锁；在回滚阶段，分支事务使用before image恢复数据并释放锁。
6. **全局事务结束**：
    - 当所有分支事务完成后，TM会通知TC全局事务的最终状态（提交或回滚）。
    - TC根据通知，协调所有分支事务的提交或回滚操作，并释放所有全局锁。

### 全局锁的实现细节

- **锁的粒度**：Seata的全局锁粒度是根据业务场景定义的，通常是数据库表的行级锁。这意味着在同一个事务中，同一行数据不能被多个事务同时修改。
- **锁的存储**：*全局锁的信息存储在全局事务协调器（TC）中。TC通过维护全局锁表，记录每个全局事务对哪些资源进行了锁定*。
- **锁的冲突检测**：在分支事务注册和执行时，TC会检测资源的锁冲突。如果请求的资源已经被其他事务锁定，当前事务会被挂起，直到资源可用。

### 全局锁的示例

假设有一个全局事务涉及两个分支事务，分别对同一数据库表的不同行进行操作：

1. **全局事务开始**：
    - TM生成一个全局事务ID（XID）。
2. **分支事务1注册**：
    - 分支事务1请求锁定用户表中用户ID为1的行。
    - TC检测到该行没有被其他事务锁定，授予分支事务1全局锁。
3. **分支事务1执行**：
    - 分支事务1记录用户ID为1的行的before image和after image。
    - 分支事务1修改该行数据。
4. **分支事务2注册**：
    - 分支事务2请求锁定用户表中用户ID为2的行。
    - TC检测到该行没有被其他事务锁定，授予分支事务2全局锁。
5. **分支事务2执行**：
    - 分支事务2记录用户ID为2的行的before image和after image。
    - 分支事务2修改该行数据。
6. **全局事务提交**：
    - TM通知TC全局事务提交。
    - TC通知所有分支事务提交更改，并释放全局锁。

通过上述步骤，Seata的全局锁机制确保在事务执行过程中，资源不会被其他事务同时修改，从而保证数据的一致性和隔离性。

### 总结

Seata中的全局锁通过锁定资源，确保全局事务执行期间资源的独占访问，防止并发修改导致的数据不一致问题。这种机制有效地保证了分布式事务的隔离性和一致性，是Seata AT模式实现高可靠分布式事务的重要组成部分。

## DeepSeek关于Seata的全局锁

> 问题：Seata AT模式的全局锁是存储在全局事务协调器（TC）中的吗？如果是存储在TC中，那么使用分布式事务修改A表中id为1的数据时正好系统中一个普通的（不在分布式事务中）update修改A表中id为1的数据，如果这个时候分布式事务失败了，需要回滚，但是普通update语句已经修改了数据，这种情况该怎么处理？

1.  **全局锁存储在 TC 中：** 这是正确的。当 AT 模式的分支事务（Branch Transaction）执行一个 DML 操作（如 `UPDATE`）时，TC 会尝试为**该操作涉及的每一行数据**（通常由主键标识）注册一个**全局锁（Global Lock）**。这个锁存储在 TC 的内存或配置的持久化存储（如 Redis、数据库）中。TC 负责管理这些全局锁的获取和释放。
2.  **你描述的场景（分布式事务回滚 vs 普通 Update）及其问题：** 这正是 Seata AT 模式的核心挑战之一，称为“脏写”或“写隔离失效”。让我们详细分析一下：
    *   **场景时序：**
        1.  分布式事务 (Global Transaction, GTX1) 开始。
        2.  GTX1 的分支事务尝试更新 `A` 表中 `id=1` 的行。
        3.  分支事务执行本地 SQL `UPDATE A SET ... WHERE id=1`。此时：
            *   本地事务提交（数据被修改到本地库）。
            *   **TC 为该行数据注册了全局锁。**
            *   分支事务向 TC 报告成功。
        4.  在 GTX1 **尚未最终提交或回滚**之前（全局锁仍然存在），一个**不在任何分布式事务中**的普通本地事务 (LTX2) 执行 `UPDATE A SET ... WHERE id=1`。
        5.  LTX2 的本地 SQL 直接执行：
            *   **由于 LTX2 不感知 Seata 的全局锁（它只受数据库行锁约束），如果数据库行锁已被 GTX1 的分支事务释放（本地事务提交后就释放了数据库锁），那么 LTX2 就能成功执行并提交。** 此时 `id=1` 的数据被 LTX2 修改。
        6.  随后，GTX1 **决定回滚**（例如因为其他分支事务失败）。
        7.  TC 通知 GTX1 中更新 `A.id=1` 的分支事务执行回滚操作。
    *   **回滚时的问题：**
        *   分支事务执行回滚操作。回滚的关键是：**用第一阶段保存的“前镜像”（Before Image）覆盖当前数据**，即执行 `UPDATE A SET ... WHERE id=1`，试图把数据恢复到 GTX1 修改之前的状态。
        *   **然而，此时数据库中的当前数据已经是 LTX2 修改后的值，不再是 GTX1 分支事务修改后的“后镜像”（After Image）了！**
        *   当 Seata 执行回滚 SQL 时，它会执行一个**检查**：`UPDATE ... WHERE id=1 AND [当前字段值 = 后镜像字段值]`。这个 `WHERE` 条件是为了确保在回滚时，当前数据**仍然是该分支事务修改后的样子**。如果条件不匹配（即当前数据已经被别人改过），这个回滚 UPDATE 语句影响的**行数会是 0**。
        *   Seata 的 RM（Resource Manager）检测到这个回滚 UPDATE 影响了 0 行。**这被视为一个严重的异常，因为它意味着无法安全地自动回滚。**
3.  **Seata 如何处理这种情况？**
    *   **回滚失败：** Seata 无法自动完成这个分支事务的回滚操作。因为试图用旧的前镜像覆盖当前数据会**覆盖掉 LTX2 的合法修改**，这显然是不正确且不可接受的。
    *   **抛出异常：** Seata RM 会抛出一个特定的异常，通常是 `BranchRollbackFailed_Unretriable` 或其变种，表明回滚失败且无法自动重试。
    *   **事务状态标记：** TC 最终会将该全局事务标记为 `RollbackFailed` 状态。
    *   **人工干预：** **这是最关键的一步。** 此时，系统进入了需要**人工介入处理**的状态。
        *   管理员或监控系统会收到告警（事务回滚失败）。
        *   需要人工检查：
            *   原始全局事务 (GTX1) 试图做什么？
            *   冲突的普通更新 (LTX2) 做了什么？
            *   当前的业务数据 (`A.id=1`) 的实际状态是什么？
            *   基于业务逻辑，判断当前数据状态是否符合业务预期？哪个操作的结果应该被保留？
        *   人工决策后，可能采取的措施：
            *   **接受现状：** 如果 LTX2 的修改是合法的且业务上可以接受当前状态，则无需额外操作（相当于 GTX1 的影响被 LTX2 覆盖了，但 LTX2 本身成功了）。
            *   **补偿操作：** 如果业务逻辑要求必须撤销 GTX1 的影响，但由于 LTX2 的存在不能直接覆盖，可能需要编写一个特定的“补偿”业务逻辑（类似于 Saga 或 TCC 的 Cancel 操作），在**当前数据基础上**进行修正，以达到业务期望的状态。**这个补偿操作需要人工触发或编写脚本执行。**
            *   **数据订正：** 在极端情况下，可能需要直接在数据库中手动修正数据。
4.  **如何避免这种情况？**
    Seata AT 模式的全局锁**只能隔离其他分布式事务**对同一行数据的并发修改（其他分布式事务尝试获取同一行的全局锁时会失败或等待）。**它无法阻止非 Seata 管理的普通事务（LTX2）的修改。** 因此，避免这种问题的最佳实践是：
    *   **业务设计约束：** 对于会被分布式事务访问的关键数据（热点数据），**强烈建议所有对该数据的修改都通过 Seata 管理的分布式事务来进行**。避免混合使用分布式事务和非分布式事务（普通事务）操作同一行数据。
    *   **使用更强隔离的模式：** 如果业务场景复杂，无法保证所有写操作都走分布式事务，或者对隔离性要求极高，应考虑使用 Seata 的 **TCC 模式** 或 **Saga 模式**。这两种模式在第一阶段（Try）通常不直接提交业务数据变更（TCC 冻结资源，Saga 提交补偿日志），天然避免了本地事务提交后其他事务立即修改数据的风险，从而在回滚时不会遇到 AT 模式的这种脏写问题。不过 TCC/Saga 需要业务代码实现更多逻辑。
    *   **热点数据特殊处理：** 对并发冲突极高的热点数据，可能需要结合应用层锁（如 Redis 分布式锁）、数据库悲观锁（`SELECT ... FOR UPDATE`，但要小心死锁和性能）、队列串行化等额外机制来保证一致性。
    *   **监控与告警：** 建立完善的 Seata 事务监控，特别是对 `RollbackFailed` 状态的监控，确保能及时发现并人工处理冲突。

**总结：**

Seata AT 模式的全局锁存储在 TC 中，用于隔离其他**分布式事务**对同一行数据的并发修改。当非分布式事务（普通 Update）在分布式事务提交/回滚前修改了同一行数据，会导致分布式事务回滚时因数据已被“污染”而失败。Seata 无法自动处理这种情况，会抛出异常并标记事务回滚失败，最终**必须依靠人工介入**来检查数据状态、理解业务意图，并决定和执行适当的补偿或修正操作。避免此问题的根本方法是**规范对关键数据的访问路径，尽量让所有写操作都通过分布式事务进行**，或者选用隔离性更强的 TCC/Saga 模式。

## Hollis补充关于Seata的全局锁

关于 [DeepSeek关于Seata的全局锁](2、相关技术/21、分布式/Hollis/35、Seata的AT模式的实现原理.md#DeepSeek关于Seata的全局锁) 小节提到的问题，可以提前识别出哪些改动频繁的场景，比如问题中提到的非分布式事务中update修改A表中id为1的数据【记作操作T】，将T中频繁被修改的字段识别出来，专门建一张表用于频繁更新。

关于全局锁，可以看：[4.2.6.实现AT模式](2、相关技术/22、微服务/微服务开发框架SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式微服务全技术栈课程/高级篇/学习资料/day02-分布式事务/讲义/分布式事务.md#4.2.6.实现AT模式)，这里面说在TC数据库中会创建lock_table表用于存储锁；数藏项目中部署Seata TC服务端的数据库中有这张表：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508292123561.png)
