# 典型回答

《Effective Java》一书中，明确表达过一种观点：

> 使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现`Singleton`的最佳方法。

究其原因，主要有以下三个好处：
1. 枚举实现的单例**写法简单**
2. 枚举实现的单例**天然是线程安全**的
3. 枚举实现的单例**可避免被反序列化破坏**：[如何破坏单例模式？](2、相关技术/1、Java基础/Hollis/如何破坏单例模式？.md)

# 扩展知识

## 枚举单例写法简单

如果你看过 [7、单例模式的多种写法](2、相关技术/10、设计模式/Hollis/7、单例模式的多种写法.md) 中的实现单例的所有方式的代码，那就会发现，各种方式实现单例的代码都比较复杂。主要原因是在考虑线程安全问题。

我们简单对比下“双重校验锁”方式和枚举方式实现单例的代码。

双重校验锁实现单例：
```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

枚举实现单例：
```java
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```

相比之下，你就会发现，枚举实现单例的代码会精简很多。

上面的双重锁校验的代码之所以很臃肿，是因为大部分代码都是在保证线程安全。为了在保证线程安全和锁粒度之间做权衡，代码难免会写的复杂些。但是，这段代码还是有问题的，因为他无法解决反序列化会破坏单例的问题。

## 枚举可解决线程安全问题

上面提到过。使用非枚举的方式实现单例，都要自己来保证线程安全，所以，这就导致其他方法必然是比较臃肿的。那么，为什么使用枚举就不需要解决线程安全问题呢？

其实，并不是使用枚举就不需要保证线程安全，只不过线程安全的保证不需要我们关心而已。也就是说，其实在“底层”还是做了线程安全方面的保证的。

那么，“底层”到底指的是什么？

这就要说到关于枚举的实现了：

定义枚举时使用`enum`和`class`一样，是Java中的一个关键字。就像`class`对应用一个`Class`类一样，`enum`也对应有一个`Enum`类。

通过将定义好的枚举 [42、什么是编译和反编译？](2、相关技术/3、JVM/Hollis/42、什么是编译和反编译？.md) ，我们就能发现，其实枚举在经过`javac`的编译之后，会被转换成形如`public final class T extends Enum`的定义。

而且，枚举中的各个枚举项同时通过static来定义的。如：
```java
public enum T {
    SPRING,SUMMER,AUTUMN,WINTER;
}
```

反编译后代码为：
```java
public final class T extends Enum
{
    //省略部分内容
    public static final T SPRING;
    public static final T SUMMER;
    public static final T AUTUMN;
    public static final T WINTER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        AUTUMN = new T("AUTUMN", 2);
        WINTER = new T("WINTER", 3);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER, AUTUMN, WINTER
        });
    }
}
```

了解JVM的类加载机制的朋友应该对这部分比较清楚。`static`类型的属性会在类被加载过程中被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用`ClassLoader#loadClass`方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个enum类型是线程安全的。

也就是说，我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。

所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。

## 枚举可解决破坏单例的问题

### 反射

通过反射调用构造方法创建枚举会报错：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508161006699.png)

因为在`Constructor#newInstance`方法中创建实例时，会校验是否是枚举，是的话就报错
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508161004815.png)

### 反序列化

**对于普通的单例对象来说，反序列化过程中会通过Java 的 Unsafe 机制来创建对象的**。这意味着即使类的构造函数是私有的，反序列化仍然可以创建该类的实例，因为它不依赖于常规的构造过程。
[如何破坏单例模式？](2、相关技术/1、Java基础/Hollis/如何破坏单例模式？.md)

但是，枚举的反序列化并不是通过Unsafe，也不是通过反射实现的。所以，也就不会发生由于反序列化导致的单例破坏问题。
> > Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, ObjectOutputStream writes the value returned by the enum constant's name method. To deserialize an enum constant, ObjectInputStream reads the constant name from the stream; the deserialized constant is then obtained by calling the java.lang.Enum.valueOf method, passing the constant's enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific writeObject, readObject, readObjectNoData, writeReplace, and readResolve methods defined by enum types are ignored during serialization and deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixedserialVersionUID of 0L. Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent.
> > 来自：[ObjectOutputStream](https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html)
> 大概意思就是说，在序列化的时候Java**仅仅是将枚举对象的name属性输出到结果**中，**===反序列化的时候则是通过`java.lang.Enum#valueOf`方法来根据名字查找枚举对象===**。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了`writeObject`、`readObject`、`readObjectNoData`、`writeReplace`和`readResolve`等方法。 我们看一下这个`valueOf`方法：
```java
public static <T extends Enum<T>> T valueOf(Class<T> enumType,String name) {  
            T result = enumType.enumConstantDirectory().get(name);  
            if (result != null)  
                return result;  
            if (name == null)  
                throw new NullPointerException("Name is null");  
            throw new IllegalArgumentException(  
                "No enum const " + enumType +"." + name);  
        }  
```

从代码中可以看到，代码会尝试从调用`enumType`这个`Class`对象的`enumConstantDirectory()`方法返回的`map`中获取名字为`name`的枚举对象，如果不存在就会抛出异常。再进一步跟到`enumConstantDirectory()`方法，就会发现到最后会以反射的方式调用`enumType`这个类型的`values()`静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充`enumType`这个`Class`对象中的`enumConstantDirectory`属性。

所以，**JVM对序列化有保证。**

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508161015081.png)

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508161019412.png)
