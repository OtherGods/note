泛型是什么意思在这就不多说了，而Java中泛型类的定义也比较简单，例如：`public class Test<T>{}`。这样就定义了一个泛型类Test，在实例化该类时，必须指明泛型T的具体类型，例如：`Test<Object> t = new Test<Object>();`，指明泛型T的类型为Object。

但是Java中的泛型方法就比较复杂了。

1. 泛型类，是在 **==*实例化类的时候*指明泛型的具体类型==**；
2. 泛型方法，是在 **==*调用方法的时候*指明泛型的具体类型==**。

## 调用泛型方法

**定义泛型方法**语法格式如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121604878.png)

```java
package com.cnblogs.test;

/**
 * 泛型演示类
 */
public class Generic {
    /**
     * 泛型方法
     * @param <T> 声明一个泛型T
     * @param c 用来创建泛型对象
     * @return
     * @throws InstantiationException
     * @throws IllegalAccessException
     */
    public <T> T getObject(Class<T> c) throws InstantiationException, IllegalAccessException{
        //创建泛型对象
        T t = c.newInstance();
        return t;
    }
}
```

```java
package com.cnblogs.test;

/**
 * 实体类
 */
public class User {
    private String uid;
    private String pwd;
    
    public String getUid() {
        return uid;
    }
    public void setUid(String uid) {
        this.uid = uid;
    }
    public String getPwd() {
        return pwd;
    }
    public void setPwd(String pwd) {
        this.pwd = pwd;
    }
    
}
```

说明一下，定义泛型方法时，必须在返回值前边加一个`<T>`，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。

`Class<T>`的作用就是指明泛型的具体类型，而`Class<T>`类型的变量c，可以用来创建泛型类的对象。

为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。

泛型方法要求的参数是`Class<T>`类型，而`Class.forName()`方法的返回值也是`Class<T>`，因此可以用`Class.forName()`作为参数。其中，`forName()`方法中的参数是何种类型，返回的`Class<T>`就是何种类型。在本例中，`forName()`方法中传入的是`User`类的完整路径，因此返回的是`Class<User>`类型的对象，因此调用泛型方法时，变量c的类型就是`Class<User>`，因此泛型方法中的泛型T就被指明为`User`，因此变量obj的类型为`User`。

当然，泛型方法不是仅仅可以有一个参数`Class<T>`，可以根据需要添加其他参数。

**==为什么要使用泛型方法呢==**？因为 **==泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活==**。

## 调用泛型方法

**调用泛型方法**语法格式如下：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121610482.png)

```java
package com.cnblogs.test;

/**
 * 泛型调用演示
 */
public class GenericTest {
    public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException{
        
        Generic generic = new Generic();        
        //调用泛型方法
        Object obj = generic.getObject(Class.forName("com.cnblogs.test.User"));
        //判断obj的类型是否是指定的User类型
        System.out.println(obj instanceof User);
    }
}
```

转载自：[https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html](https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html)