重写`hashCode()`和`equals()`方法，核心目的是**保证对象在基于哈希表的集合（如 HashMap、HashSet）中能被正确识别和使用**，避免因默认实现导致的逻辑错误。

### 1. 先理解默认实现的问题

Object 类（所有类的父类）对两个方法的默认实现存在明显缺陷：
- **默认`equals()`**：仅比较对象的内存地址（即`==`的效果），意味着即使两个对象的属性完全相同，只要是不同对象实例，就会被判定为 “不相等”。
- **默认`hashCode()`**：返回对象的内存地址对应的哈希值，因此不同对象实例的哈希值必然不同。

### 2. 重写的核心原因：满足 “哈希契约”

Java 规范要求`hashCode()`和`equals()`必须遵守以下契约，否则哈希集合会失效：

- **契约 1**：若两个对象通过 **==`equals()`判定为相等==**（`a.equals(b) == true`），则它们的 **==`hashCode()`必须返回相同的值==**。
- **契约 2**：若两个对象的 **==`hashCode()`值相同==**（哈希冲突），**==`equals()`不一定相等==**（后续会通过`equals()`进一步区分）。

若不重写，会导致以下典型问题：

- **HashSet 无法去重**：两个属性相同的对象，因默认`equals()`返回`false`、`hashCode()`不同，会被当作两个不同元素存入，违背 “去重” 逻辑。
- **HashMap 无法正确取值**：存入时根据对象 A 的`hashCode()`定位哈希桶，取值时若用属性相同的对象 B（默认`hashCode()`不同），会定位到其他桶，导致找不到已存入的值。

### 3. 何时必须重写？

只要你的类需要：

- 存入`HashMap`、`HashSet`、`HashTable`等哈希集合。
- 逻辑上判断 “对象相等” 的依据是**属性值**（而非内存地址），例如 “两个用户 ID 相同即视为同一个用户”。
