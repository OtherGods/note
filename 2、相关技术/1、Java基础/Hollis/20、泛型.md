#泛型 #泛型类 #泛型方法 #形式类型变量的限定 #类型擦除 #继承 #参数化类型的继承 #通配符 

> - **==形式类型变量（类型变量、类型参数、形式类型参数）==**：在声明类、方法、字段时指定的；是实际类型参数的占位符，==当**实例化泛型类**或**调用泛型方法**时，每个形式类型参数都会被实际类型参数替换。==
>   形式类型参数分为两种：
> 	  - 无界形式类型参数
> 	  - 有界形式类型参数（只有上限 `extends`）
>   常见的作法就是**形式类型变量**使用大写字母，而且很简短。Java库使用变量E表示集合的元素类型，K和V分别表示表的键和值的类型，T（必要的时候还可以使用相邻的U和S字母）表示任意类型；如果是有界的，可以配合 `extends` 。
> 
> - **==实际类型参数==**：引用类型（Java中的类）、通配符、形式类型参数等等；当一个形式类型参数声明一个或多个边界的时候，**实际类型参数必须是相应形式的形式类型参数指定的所有边界的子类型**。
> 
> - **==参数化类型（实例化）==**：泛型类的 **`实例化`**，在实例化的时候会传递实际类型参数，有三种方式：
> 	- 具体参数化：`ArrayList<String>`
> 	- 无界通配符参数化：`ArrayList<?>`
> 	- 有界通配符参数化：上限`ArrayList<? extends Father>`、下限`ArrayList<? super Son>`

# 典型回答

Java泛型（generics） 是JDK 5中引入的一个新特性，允许在定义类和接口的时候使用类型参数（type parameter）。声明的类型参数在使用时用具体的类型来替换。泛型最主要的应用是在JDK 5中的新集合类框架中。

## 泛型类和泛型方法

### 泛型类

泛型类是指有一个或者多个类型变量的类，类型变量（类型参数）在类名的后面的尖括号中`<>`，`<>`中可以有多个类型变量。

设现在有一个父类`class Father<T>{}`，子类Son继承了这个父类，那么子类的声明可以有：
- 子类指定了具体的类型：`class Son extends Father<String>{}`
- 子类也需要使用泛型：`class Son3<T> extends Father<T>{}`
  - **错误写法**，父类上定义有泛型需要进行处理：`class Son2 extends Father<T>{}`

### 泛型方法

形式类型变量放在：修饰符（例如：public、static）和返回类型中间的尖括号中（`<>`）

泛型方法：[20.1、Java中的泛型方法](2、相关技术/1、Java基础/Hollis/20.1、Java中的泛型方法.md)

### 泛型类、方法对比

定义在普通类和泛型类中的方法
- 普通类
	- 普通方法
	- 泛型方法`<T>`
		- 泛型方法内可以使用泛型方法声明的形式类型变量`<T>`
- 泛型类`<T,E>`
	- **普通方法**
		- 静态方法：泛型类中的静态方法不能使用泛型类声明时的形式类型变量；因为 **==类中的泛型需要在对象建立才能确定==（实例化对象时候=指定具体的类型），而静态优先于对象存在**。那么*类中的静态方法如果想要使用泛型，就需要将该普通方法声明为静态泛型方法*。泛型声明在static之后，在返回值之前。
		- 实例方法：泛型类中的普通实例方法可以使用泛型类中定义的类型字段`<T>`作为返回值和参数类型。
	- **泛型方法**
		- 静态泛型方法`<T>`：静态泛型方法中使用的类型变量`<T>`和泛型类中的`<T>`不一样，静态泛型方法内可以使用静态泛型方法声明的类型变量`<T>`，**==静态泛型方法内不可以使用泛型类中定义的所有类型变量==**！！！
		- 实例泛型方法`<T>`：实例泛型方法中使用的类型变量`<T>`和泛型类中的`<T>`不一样，泛型方法内可以使用泛型方法声明的类型变量`<T>`，同时泛型方法内还可以使用泛型类中定义的类型变量`<E>`。
		  **注意**：在泛型方法中定义和泛型类中相同的类型变量`<T>`的时候，在泛型方法中使用的是在泛型方法中定义的，例如：泛型类在实例化的时候确定类型变量`<T>`是String类型的，但是在调用泛型类中的泛型方法的确定类型变量`<T>`是Integer类型的，那么在泛型方法中使用的类型变量`<T>`指的是Integer类型的。

## 泛型的好处

1. **方便**：**可以提高代码的复用性**。以List接口为例，我们可以将String、Integer等类型放入List中，如不用泛型，存放String类型要写一个List接口，存放Integer要写另外一个List接口，泛型可以很好的解决这个问题
2. **安全**：在泛型出之前，通过Object实现的类型转换需要在运行时检查，如果类型转换出错，程序直接GG，可能会带来毁灭性打击。而**泛型的作用就是在编译时做类型检查**，这无疑增加程序的安全性
3. **自动类型转换**：**编译器会在编译阶段在字节码的合适位置插入强制类型转换**，*泛型类中的方法* 在 *被调用的地方* 可以 *自动发生强制类型转换*（可以通过`jad`查看）
   示例代码：
```java
public class Pair<T>  
{  
    private T first;  
    private T second;  
      
    public Pair()  
    {  
        first = null;  
        second = null;  
    }  
      
    public Pair(T first, T second)  
    {  
        this.first = first;  
        this.second = second;  
    }  
      
    public void setFirst(T newValue)  
    {  
        first = newValue;  
    }  
      
    public void setSecond(T newValue)  
    {  
        second = newValue;  
    }  
    // 泛型方法
    protected <U extends Comparable,Serializable> U getSecond()  
    {  
        return (U) second;  
    }  
    // 普通方法
    public T getFirst()  
    {  
        return first;  
    }  
      
    public static void main(String[] args)  
    {  
        Pair<String> pair = new Pair<>();  
        String first1 = pair.getFirst();  
        Comparable second1 = pair.getSecond();  
    }  
}
```

jad反编译后代码如下：
```java
public class Pair
{
    public Pair()
    {
        first = null;
        second = null;
    }
    ......
	......
    protected Comparable getSecond()
    {
        return (Comparable)second;
    }

    public Object getFirst()
    {
        return first;
    }

    public static void main(String args[])
    {
        Pair pair = new Pair();
        String s = (String)pair.getFirst();
        Comparable comparable = pair.getSecond();
    }

    private Object first;
    private Object second;
}

```

## 形式类型变量的限定

<font color="red" size=5>对类或者方法上声明的形式类型变量加以约束</font>

**示例**：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121643219.png)
当向这个方法中**传递一个没有实现Comparable接口的数组对象**的时候，照片中圈住的代码就会出现问题，因为数组中的元素没有实现Comparable接口，所以不能调用compare方法，就会出现问题。

解决办法就是对形式类型变量加限定，代码中的`Comparable`是限定类型；一个类型变量可以有多个限定类型，使用 `&` 分隔，例如：`T extends Comparable & Serializable`
```java
public static <T extends Comparable> T main(T[] a)...
```

在Java继承中可以根据需要拥有多个接口超类型作为限定类型，但是最多有一个限定可以是类，**如果有一个类作为限定，它必须是限定列表中的第一个限定，而且为了提高效率应该将标签接口（没有方法的接口）放在限定列表的末尾**。

## 类型擦除

[21、什么是类型擦除？](2、相关技术/1、Java基础/Hollis/21、什么是类型擦除？.md)

## 参数化类型中的继承

`Manage`是`Employee`类的子类，`Pair<Employee>`与`Pair<Manage>`是同层次的，没有父子关系，不过都可以认为是`Pair<? extends Employee>` 或 `Pair`（原始类型） 或 `Pair<?>` 或 `Pair<? super Manage>` 的子类

关于通配符的上下界限定符：[23、泛型中上下界限定符extends 和 super有什么区别？](2、相关技术/1、Java基础/Hollis/23、泛型中上下界限定符extends%20和%20super有什么区别？.md)

### extends

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121447791.png)

对应代码：
```java
Pair<? extends Employee> p1 = new Pair<Employee>();  
Pair<? extends Manager> p2 = new Pair<Manager>();  
Pair p3 = new Pair<Employee>();  
Pair p4 = new Pair<Manager>();

Employee employee = new Employee();  
Manager manager = new Manager();

// 编译报错
p1.setSecond(employee);  
Employee second1 = p1.getSecond();  
// 编译报错
p2.setSecond(manager);  
Manager second2 = p2.getSecond();  
  
p3.setSecond(employee);  
Object second3 = p3.getSecond();  
p4.setSecond(manager);  
Object second4 = p4.getSecond();
```

### super

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508122117636.png)

对应代码：
```java
Pair<?> p5 = new Pair<Employee>();  
Pair<? super Employee> p6 = new Pair<Employee>();  
Pair<? super Manager> p7 = new Pair<Manager>();

Employee employee = new Employee();  
Manager manager = new Manager();

// 编译报错
p5.setSecond(employee);  
Object second5 = p5.getSecond();  
  
p6.setSecond(employee);  
Object second6 = p6.getSecond();  
p7.setSecond(manager);  
// second7类型写成Manager时编译报错
Object second7 = p7.getSecond();
```

### 原始类型

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508122300651.png)

# 知识扩展

## 泛型是如何实现的

Java中的泛型通过**类型擦除**的方式来实现，通俗点理解，就是通过语法糖的形式，在`.java`->`.class`转换的阶段，将`List<String>`擦除调转为List的手段。换句话说，Java的泛型只在编译期，Jvm是不会感知到泛型的。
[21、什么是类型擦除？](2、相关技术/1、Java基础/Hollis/21、什么是类型擦除？.md)

## 类型擦除的缺点有哪些？

1. 泛型不可以重载
2. 泛型异常类不可以多次catch
3. 泛型类中的静态变量也只有一份，不会有多份

## 对泛型通配符的理解

[23、泛型中上下界限定符extends 和 super有什么区别？](2、相关技术/1、Java基础/Hollis/23、泛型中上下界限定符extends%20和%20super有什么区别？.md)

## `List<?>`,`List<Object>`,`List`之间的区别

1. `List<?>` 是一个未知类型的List，而`List<Object>` 其实是任意类型的`List`。可以把`List<String>`、`List<Integer>`赋值给`List<?>`，却不能把`List<String>`赋值给 `List<Object>`
2. 可以把任何带参数的类型传递给原始类型`List`。
3. `List<?>`由于不确定列表中元素的具体类型，因此只能从这种列表中读取数据，而不能往里面添加除了 null 之外的任何元素。
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121457144.png)

## 在泛型为Integer的ArrayList中存放一个String类型的对象

通过反射可以实现：
```java
public void test() throws Exception {
    ArrayList<Integer> list = new ArrayList<Integer>();
    Method method = list.getClass().getMethod("add", Object.class);
    method.invoke(list, "Java反射机制实例");
    System.out.println(list.get(0));
}
```

## 对数组协变和泛型非协变的理解

所谓协变，可以简单理解为因为Object是String的父类，所以`Object[]`同样是`String[]`的父类，这种情况Java是允许的；但是对于泛型来说，`List<Object>`和`List<String>`半毛钱关系都没有

为什么要这样设计呢，如果泛型允许协变（实际上以下代码第一步就会编译失败），考虑如下例子：
```java
List<Object> a = new List<String>();
a.add(1); // 允许协变，可以装进来
String s = a.get(0); // 编译报错
```

但是，为什么泛型不允许协变，而数组允许协变呢？原因有二：
1. 因为数组设计之初没有泛型，为了兼容考虑，如`Arrays.equals(Object[], Object[])`方法，是时代无奈的产物
2. 数组也属于对象，它记录了引用实际的类型，在放入数组的时候，如果类型不一样就会报错，而不是等到拿出来的时候才发现问题，相对来说安全一点

## 泛型的限定与局限

1. 不能用基本类型作为实际类型参数
2. 不能创建参数化类型的数组
3. 不能实例化类型变量
4. 不能构造泛型数组——不能构造类型变量数组
5. 在静态上下文中使用的泛型类型的形式类型变量是无效的
6. 运行时类型查询只适用于原始类型


转载自：[什么是泛型？有什么好处？](https://www.yuque.com/hollis666/io9xi1/syhevb)
