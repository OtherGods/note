# 典型回答

在Java中，`equals()`和`hashCode()`方法通常是成对的，它们在使用基于Hash机制的数据结构时非常重要，例如`HashMap`、`HashSet`和`Hashtable`等。
- `equals`：用于判断两个对象是否相等
- `hashCode`：生成对象的哈希码，返回值是一个整数，用于确定对象在哈希表中的位置。

为什么需要`hashCode`，主要是为了方便用在`Hash`结构的数据结构中，因为**对于这种数据结构来说，想要把一个对象存进去，需要定位到他应该存放在哪个桶中**，而这个桶的位置，就需要通过一个整数来获取，然后再对桶的长度取模（实际`HashMap`要比这复杂一些，可以看：[18、HashMap的hash方法是如何实现的？](2、相关技术/1、Java基础/集合/Hollis/18、HashMap的hash方法是如何实现的？.md)）。

`HashMap`的数据结构详细的请参考：
[10、HashMap的数据结构是怎样的？](2、相关技术/1、Java基础/集合/Hollis/10、HashMap的数据结构是怎样的？.md)

那么，怎么能快速获取一个和这个对象有关的整数呢，那就是`hashCode`方法了。所以，`hashCode`的结果是和对象的内容息息相关的。那么也就意味着 **==如果==两个对象通过==`equals()`方法比较是相等的==，==那么==它们的==`hashCode()`方法必须返回相同的整数值==。**

那么，在一个对象中，**==定义了`equals`方法之后，同时还需要定义`hashCode`方法==**， 因为这样在向`hashMap`、`hashTable`等中存放的时候，才能快速的定位到位置。

所以，基于两方面考虑，**一方面是效率，`hashCode()` 方法提供了一种快速计算对象哈希值的方式，这些哈希值用于确定对象在哈希表中的位置。这意味着可以快速定位到对象应该存储在哪个位置或者从哪个位置检索，显著提高了查找效率。**

**另外一方面是可以和`equals`做协同来保证数据的一致性和准确性**。根据 Java 的规范，<font color="red" size=5>如果两个对象通过 equals() 方法比较时是相等的，那么这两个对象的 hashCode() 方法必须返回相同的整数值</font>。如果违反了这一规则，将导致哈希表等数据结构无法正确地处理对象，从而导致数据丢失和检索失败。