# 典型回答

类型擦除是发生在`javac`编译过程中，擦除主要有三个动作：
1. ==擦除**形式类型参数**和**实际类型参数**==
2. 转换泛型表达式（**==在合适的地方向字节码插入强制类型转换==**）——在合适的地方（比如：**被擦除了返回类型的*方法*** 和 **被擦除了类型的*字段*** ），编译器插入*强制类型转换*到字节码。
3. 转换泛型方法（**==编译器自动生成桥方法==**）——主要说的是为了解决在类型擦除的时候会出现的问题，编译器在子类中插入桥方法，**在父类类型变量引用子类类型对象时，这个变量调用的就是桥方法**，示例代码：
```java
import java.util.Date;

// 父类
public class Pair<T> {  
    public T first = new Date();  
    public T second;  

	public void setSecond(T newValue) {  
        second = newValue;  
    }  
}

// 子类
public class DateInterval extends Pair<Date> {
	public void setSecond(Date second) {  
	    if(second.compareTo(first) >= 0) {
		    super.second = second;
	    }
    }  
	public static void main(String[] args){
		Pair p = new DateInterval();
		p.second = new Date();
		System.out.println(p.second);
	}
}
```

对于DateInterval.class进行反编译
```java
import java.io.PrintStream;
import java.util.Date;

public class DateInterval extends Pair
{

    public DateInterval()
    {
    }

    public void setSecond(Date date)
    {
        if(date.compareTo((Date)first) >= 0)
            super.second = date;
    }

	// 桥方法，编译器自动帮我们生成的，当父类类型变量引用自类类型对象；用
	// 这个变量调用 setSecond(LocalDate) 方法时，因为类型是父类的，所以
	// 会提示调用方法出错，从而有了编译器为我们自动生成的这个方法。
    public volatile void setSecond(Object obj)
    {
        setSecond((Date)obj);
    }
	
	public static void main(String args[])
    {
        DateInterval dateinterval = new DateInterval();
        dateinterval.setSecond(new Date());
        System.out.println(((Pair) (dateinterval)).second);
    }
}
```

## 概念

类型擦除是Java在处理泛型的一种方式，如Java的编译器在编译以下代码时：
```java
public class Foo<T> {
    T bar;
    void doSth(T param) {
    }
};

Foo<String> f1 = new Foo<>();
Foo<Integer> f2 = new Foo<>();
```

在编译后的字节码文件中，会把泛型的信息擦除掉：
```java
// 擦除形式类型参数
public class Foo {
    Object bar;
    void doSth(Object param) {
    }
};

// 擦除实际类型参数
Foo foo = new Foo();
Foo foo1 = new Foo();
```

可以看到代码中的`Foo<T>`、`Foo<String>`、`Foo<Integer>`，经过编译后都被类型擦除。

所以说泛型技术实际上是Java语言的一颗语法糖，因为泛型经过编译器处理之后就被擦除了。

这种擦除的过程，被称之为——**==类型擦除==**。所以类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。**==编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上==**。类型擦除的关键在于 **==清除泛型类型中类型参数==的相关信息，并且在必要的时候添加==类型检查==和==类型转换==的方法**。

无论何时定义一个泛型类型，都会自动提供一个相应的 **==原始类型（raw type）==** 。这个 **原始类型** 的名字就是==去除掉 **形式/实际类型参数** 后的泛型类型名==。<font color="red" size=5>形式/实际类型变量会被 擦除</font>：
- 对于 **==有限定的形式类型参数==** 会被替换为它的限定类型中的第一个
- 对无 **==限定的形式类型参数==** 则替换为Obejct

## 示例代码

1. 形式类型参数无限定
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121705951.png)
   被擦除后的结果：
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121705251.png)
2. 形式类型参数有限定
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121706384.png)
   被擦除后的结果：
   ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508121708257.png)

# 扩展知识

## C语言对泛型的支持

泛型是一种编程范式，在不同的语言和编译器中的实现和支持方式都不一样。

通常情况下，一个编译器处理泛型有多种方式，在C++中，当编译器对以下代码编译时：
```java
template<typename T>
struct Foo
{
    T bar;
    void doSth(T param) {
    }
};

Foo<int> f1;
Foo<float> f2;
```

当编译器对其进行编译时，编译器发现要用到`Foo<int>`和`Foo<float>`，这时候就会为每一个泛型类新生成一份执行代码。相当于新创建了如下两个类：
```java
struct FooInt
{
    int bar;
    void doSth(int param) {
    }
};

struct FooFloat
{
    float bar;
    void doSth(float param) {
    }
};
```

这种做法，用起来的时候很方便，只需要根据具体类型找到具体的的类和方法就行了。但是问题是，当我们多次使用不同类型的模板时，就会创建出来的很多新的类，就会导致代码膨胀。