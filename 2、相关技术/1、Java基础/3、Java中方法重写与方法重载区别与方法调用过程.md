本文来自于我对Java核心技术卷Ⅰ种对方法重载与方法重写的总结

1. 方法重载：Java核心技术卷Ⅰ   第四章4.6.1节
2. 方法重写：Java核心技术卷Ⅰ   第五章5.1.6节

<font color = "red">方法签名：</font>方法的名字、参数类型/数量；在同一个类中不能有两个名字、参数类型/数量相同的方法。

## 1、方法重载

<font color = "red">重载：</font>某个**类中有多个方法有相同的名字、不同的参数，便出现了重载**；方法重载只是关心方法签名，对于方法的访问修饰符、返回类型、抛出的异常等都不关心。

<font color = "red">重载解析：</font>**编译器必须挑选出具体调用哪个方法，它用各个方法首部中的参数类型与特定方法调用中所使用的值的类型进行匹配，来选出正确的方法**，如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。

Java中**允许重载任何方法，而不只是构造方法**；因此要完整地描述一个方法，就需要指定方法名以及方法参数类型，这是叫做方法签名。

## 2、方法重写

<font color = "red">重写（覆盖~实例方法~/隐藏~静态/类方法~）：</font>**子类中定义了一个与超类中方法签名相同的方法**，那么子类中的这个方法就会覆盖超类中这个相同签名的方法。

声明覆盖父类中的某个方法的时候，要注意：方法修饰符、返回类型、方法名、方法参数、声明的可能抛出异常……【可能还有别的内容，因为我看见Java语言规范中方法声明语法中还有一些东西，但是我没有见过，不太会，所以就没写，待以后补充】

1. 方法修饰符
   这里知讨论两种，分别是访问修饰符和final

   1. final：被这个修饰符声明的方法不能被重写
   2. 访问修饰符：private、default、protected、public
      ![image-20221008193724288](D:\Tyora\AssociatedPicturesInTheArticles\Java中方法重写与方法重载区别与方法调用过程\image-20221008193724288.png)

   在重写方法的时候，子类中重写的方法的访问修饰符可见性更高（即父类中被重写的方法的访问修饰符更特定），比如：父类被重写的方法的访问修饰符是protected，那么子类可以是public、protected，不能是default或者private。
   
   **这个正好和返回类型与声明可能抛出的异常是相反的，它们两者在子类中声明的更加特定，而访问修饰符是父类更加特定。**

2. 返回类型
   返回类型不是方法签名的一部分。
   
   子类中重写方法的返回类型和父类中被重写的方法的返回类型是：**可协变**的——>（即**子类方法的返回类型是更严格的**）

   1. 子类中重写的方法的返回类型是超类中被重写的方法的返回类型。
   2. 子类中重写的方法的返回类型是超类中被重写的方法的返回类型的子类。

   这里会涉及到桥方法，即编译器会在子类中定义一个和父类中完全相同的桥方法，<u>但是这个时候你会发现，在一个类中出现了有两个方法的签名是完全一致的，这种操作我们不能做，只能编译器能做</u>，在桥方法中会调用子类中签名完全相同的方法（即在子类中重写的方法），可以通过反编译工具查看。

3. 方法名：方法签名一部分，子类中重写的方法的签名必须和父类中被重写的方法的一样
4. 方法参数：方法签名一部分，子类中重写的方法的签名必须和父类中被重写的方法的一样
5. 声明可能抛出的异常
   **和返回类型是同样的**
   **子类抛出的异常更加严格**，如果父类中不抛出检查型异常，那么子类中也不能抛出检查型异常。

上述介绍的方法重写并没有明确区分实例方法和静态方法，接下来的照片中是我在思维导图中总结的  ***<u>Java语言规范中的第八章和第九章中的一部分</u>***   ，具体内容可以去看思维导图：[Java核心技术卷 Ⅰ 第四、五章面向对象整理](D:\Xmind中的思维导图\java\Java核心技术卷 Ⅰ 第四、五章面向对象整理.xmind)，或者Java语言规范第八章和第九章；至于继承中的字段的阴影和遮蔽也可以去看思维导图或Java语言规范第八章、第九章。
![image-20221008214947801.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281016664.png)

## 3、方法调用过程

准确的理解如何在对象上面应用方法调用非常重要，下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象，以下是调用过程的详细描述：

1. 编译器查看对象的声明类型和方法名，需要注意的是：有可能存在多个名字为f但参数不同样的方法，例如，可能存在方法f(int)和方法f(String)。编译器将会一一列举C类中所有名为f的方法和超类中所有名为f且可以访问的方法（超类的私有方法不可以访问）。

   **至此编译器已经知道所有可能被调用的候选方法。**
2. 接下来编译器要确定方法调用中提供的参数类型。如果在所有名为f的方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法，这个过程称之为**重载解析**。
   由于允许类型转换（int 自动类型转换为 double等等），所以情况可能会变得很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，编译器就会报一个错误。

   <font color = "red">至此，编译器已经知道需要调用的方法的名字和参数类型，也就是说：编译器已经知道要调用的方法的签名，但是调用父类中的方法还是子类中的方法还是不确定的，需要后面步骤中根据动态绑定还是静态绑定来判断</font>。
   
3. 如果是private方法、static方法、final方法、构造器方法，那么编译器将可以准确的知道应该调用哪个方法，这是称之为<font color = "blue" size=5>静态绑定</font>。
   如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用<font color = "blue" size=5>动态绑定</font>，动态绑定看第四步。

   在我们的示例中，编译器会利用动态绑定生成一个调用f(String)的指令。

4. **程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对应的哪个方法。** 假设x的实际类型是D，它是C类的子类。如果D类中定义了方法f(String)【也就是实现了方法重写】，那么就会调用这个方法；如果在D类中没有定义这个f(String)方法，将在D类的超类X中寻找f(String)。依此类推。

   每次调用方法的时候都要完成这个搜索，时间开销较大。因此，虚拟机预先为每个类计算了一个方法表，其中罗列出了所有方法的签名和要调用的实际方法。这样一来，在真正调用方法的时候，虚拟机仅仅需要查找这个表就行了。

   在前面这个例子中，虚拟机搜索D类的方法表，寻找与调用f(String)相匹配的方法，这个方法即可能是D.f(String)，也可能是X.f(String)，这里的X是D的某个超类。

   这里需要提醒的一点，如果是调用super.f(param)，那么虚拟机将对隐式参数超类的方法表进行搜索。

   **动态绑定的一个重要特性：** 无需对现有代码进行修改就可以对程序进行扩展，如下实例代码，如果给Employee类增加一个新的子类Executive，并且变量e可能引用这个类的对象，我们不需要对包含调用e.getSalary()的代码进行重编译。

   1. 实例
      现在有如下代码：
      ![image-20221009164102332.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281021855.png)
      ![image-20221009164133834.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281023947.png)
      ![image-20221009164226196.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281024454.png)
      ![image-20221009164318441.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281026757.png)
      分析程序清单5-1中调用e.getSalary()的过程——>
      e声明为Employee类型，Employee类型。Employee类型只有一个名叫做getSalary，这个方法没有参数。因此，在这里不需要担心重载解析的问题。
      由于getSalary方法不是private方法、static方法或final方法，所以将会采用动态绑定，虚拟机为Employee和Manager类生成方法表。在Employee的方法中列出这个Emloyee类本身定义的所有方法（这里只是贴出部分）：
      ![image-20221009165650566.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281027585.png)
      
      实际上Employee类中的有一个超累Object，Employee类从这个超类中还继承了大量方法。
      Manager方法中有三个方法是继承来的，一个方法是重新定义的，还有一个新增加的（也只是贴出一部分）：
      ![image-20221009170009970.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507281028959.png)

      在运行的时候，调用e.getSalary()的解析过程：
      1. 首先虚拟机获取e的实际类型的方法表，这可能是Employee也可能是Manager的方法表，也可能是Employee类的其他子类的方法表。
      2. 接下来，虚拟机查找定义了getSalary()签名的类。此时虚拟机已经知道应该调用哪个方法。
      3. 最后虚拟机调用这个方法。

查看上述四步骤可以知道：

1. 方法调用前三步：编译器在方法调用的时候使用<font color = "blue">重载解析</font>对<font color = "red">方法重载</font>进行区分，也就是<u>确定方法签名</u>。
2. 方法调用最后一步：虚拟机在方法调用的时候使用<font color = "blue">动态绑定 / 静态绑定</font>对<font color = "red">方法重写</font>进行区分，也就是<u>确定调用的是父类还是子类中的方法</u>。

