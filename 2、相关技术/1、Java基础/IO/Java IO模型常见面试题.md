#IO
对比：[3、操作系统的IO模型有哪些？](4、操作系统/Hollis/3、操作系统的IO模型有哪些？.md)

面试中常喜欢的一个问题，因为通过这个问题，面试官可以顺便了解一下你的操作系统的水平。

IO模型这块确实挺难理解，需要太多计算机底层知识。

# 1、I/O

## 1.1、何为I/O？

I/O即为输入输出。

我们从计算机结构的角度来解读一下I/O

根据冯诺依曼结构，计算机结构分为5大部分：运算器、控制器、存储器、输入设备、输出设备。

![image-20221007093711363.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201041865.png)


输入设备（比如键盘）和输出设备（比如显示屏）都属于外部设备。网卡、硬盘这种即可以属于输入设备，也可以属于输出设备。

输入设备向计算机中输入数据，输出设备接受计算机输出的数据。

从计算机结构的角度来看，I/O描述了计算机系统与外部设备之间通信的过程。

从应用程序的角度来解读一下I/O。

根据大学操作系统的相关知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为  用户空间  和  内核空间。

我们平时运行的应用程序都是运行在用户空间，只有内核空间才能进行系统级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想进行IO操作，一定是要依赖内核空间的能力。

像我们平时运行的应用程序都运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等，也就是说，我们想要进行IO操作，一定是要依赖内核空间的能力。

并且，用户空间的程序不能直接访问内核空间。

当想要执行IO操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作请求操作系统帮忙完成。

因此，用户进程想要执行IO操作的话，必须通过系统调用来间接访问内核空间。

我们平时开发过程中接触最多的就是磁盘IO（读写文件）和网络IO（网络请求和响应）。

从应用程序的视角来看，我们的应用程序对操作系统的内核发起IO调用（系统调用），操作系统负责的内核执行具体的IO操作。也就是说，我们的应用程序实际上只是发起了IO操作的调用而已，具体IO的执行是由操作系统的内核来完成的。

<font color = "red">**当应用程序发起IO调用之后，会经历两个步骤：**</font>

1. <font color = "red">**内核等待IO设备准备好数据**</font>
2. <font color = "red">**内核将数据从内核空间拷贝到用户空间**</font>

## 1.2、有那些常见的IO模型？

UNIX系统下，IO模型一般有5种：

1. 同步阻塞IO
2. 同步非阻塞IO
3. IO多路复用
4. 驱动IO
5. 异步IO

# 2、Java中三种常见IO模型

## 2.1、BIO（Blocking IO）

BIO属于同步阻塞IO模型。

同步阻塞IO模型中，应用某线程中的任务发起read调用后，该线程会一直阻塞，直到在内核把数据拷贝到用户空间。【至于为什么会阻塞，可以去网上搜一下】

![image-20221007100714073.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201043921.png)

在客户端连接数量不高的情况下，是没有问题的。但是，当面对十万甚至数百万级连接的时候，传统的BIO模型是无能为力的。因此，我们需要一种更高效的IO处理模型来应对更高的并发量。

## 2.2、NIO（Non-blocking/New IO）

Java中的NIO于Java1.4中引入，对应的java.nio包，提供了Channel，Selector，Buffer等抽象，NIO中的N可以理解为Non-blocking，不单纯是New。它支持面对缓冲的，基于通道的IO操作方法。对于高负载、高并发的（网络）应用，应该使用NIO。

Java中的NIO 可以看作是IO多路复用模型，也有人认为Java中的NIO属于同步非阻塞IO模型。

我们来看看同步非阻塞IO模型。
![image-20221007101311435.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201051499.png)

同步非阻塞IO模型中，应用程序中会一直发起read调用，等数据从内核空间拷贝到用户空间的这段时间内，线程依然是阻塞的，直到在内核吧数据拷贝到用户空间。

相比于非阻塞IO模型中，应用程序会一直发起来read调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

相比于同步阻塞IO模型，同步非阻塞IO模型确实有了很大的改进。通过轮询操作，避免了一直阻塞。

但是，这种IO模型同样存在问题：**应用程序不断进行IO系统调用轮询数据是否已经准备好的过程是十分消耗CPU资源的**。

这个时候，**I/O多路复用**就上场了。

![image-20221007102355839.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201052598.png)

IO多路复用模型中，线程首先发起select调用，询问内核数据是否准备就绪，等待内核把数据准备好了，用户线程再发起read调用。read调用的过程中（数据从内核空间——>用户空间）还是阻塞的。

> 目前支持IO多路复用的系统调用，有select、epoll等等，select系统调用，是目前几乎在所有的操作系统上都有支持
>
> 1. **select调用**：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> 2. **epoll调用**：linux2.6内核，属于调用的增强版本，优化了IO的执行效率

**IO多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。**

Java的NIO中，有一个非常重要的**选择器（Selector）** 的概念，也可以被称为**多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其他服务。

![image-20221007103426806.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201054641.png)


## 2.3、AIO（Asynchronous IO）

AIO也就是NIO 2。Java7中引入了NIO的改进版NIO 2，它是异步IO模型。

异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在哪里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

![image-20221007104429306.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201055632.png)

目前来说AIO的应用还不是很广泛。Netty之前也尝试使用过AIO，不过又放弃了。这是因为，Netty使用了AIO之后，在Linux系统上的性能并没有多少提升。

最后，来一张图，简单总结一下Java中的BIO、NIO、AIO。

![image-20221007104637836.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202404201057057.png)
