内容来自：[泛型&通配符常见面试题总结](https://www.yuque.com/books/share/04ac99ea-7726-4adb-8e57-bf21e2cc7183/ipqccd)，我没有太多的修改原文的内容，连我思维导图中用到的名词都没有在这里使用。

# 1、泛型

## 1.1、什么是泛型？有什么作用？

Java泛型是JDK5种引入的一个特性。使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，并且通过单行参数可以指定传入的对象的类型。比如ArrayList<Person> persons = new ArrayList<Person>(); 这行代码就证明了该ArrayList对象只能传入Person对象，如果传了其他类型的对象就会报错。

```java
ArrayList<E> extends AbstractList<E>
```

并且，原生List返回类型是Object，需要手动转换类型才能使用，使用泛型后编译器自动转换。

## 1.2、泛型的使用方式有哪几种？

泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。

1. 泛型类
   ![image-20221009172607864](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009172607864.png)
   如何实例化泛型类：
   Generic<Integer> genericInteger = new Generic<>(123456);

2. 泛型接口
   ![image-20221009172704801](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009172704801.png)
   实现泛型接口也可以不指定形式类型参数为实际类型参数
   ![image-20221009172908952](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009172908952.png)

   实现泛型接口可以指定形式类型参数为实际类型参数
   ![image-20221009172925467](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009172925467.png)

3. 泛型方法
   ![image-20221009173001454](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009173001454.png)
   使用：
   ![image-20221009173026272](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009173026272.png)




## 1.3、项目中哪里使用到了泛型？

1. 自定义接口通用返回结果CommonResult<T>，通过参数T可以根据具体的返回类型动态指定结果的数据类型
2. 定义Excel处理类ExcelUtil<T>用于动态指定Excel导出的数据类型
3. 构建集合工具类（参考Collections中的sort，binarySearch方法）
4. ……

## 1.4、什么是泛型擦除机制？为什么要擦除?

Java中的泛型是伪反习惯，这是因为Java在编译期间，所有的泛型信息都会被擦除掉，这也就是类型擦除。

编译器会在编译期间动态的将T擦除为Object，将T extends xx

x擦除为其限定类型的第一个。

因此，泛型本质上其实还是编译器的行为，为了保证引入泛型机制但不会创建型的类型，减少虚拟机的运行开销，编译器通过泛型将泛型类型转换为一般类。

编译器还会在调用返回类型为泛型的方法处进行强制类型转换，具体解释如下代码所示：

```java
public class test<T>{
	private T result;
	public T getResult(){
		return result;
	}
	public void setResult(T result){
		this.result = result;
	}

	public static void main(String[] args){
		
		test<String> t = new test<>();
		t.setResult("456");
		String result = t.getResult();		
	}
}
```

编译test.java类，使用jad test.class反编译字节码文件的内容如下：

```java
// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   test.java


public class test
{

    public test()
    {
    }

    public Object getResult()
    {
        return result;
    }

    public void setResult(Object obj)
    {
        result = obj;
    }

    public static void main(String args[])
    {
        test test1 = new test();
        test1.setResult("456");
        //编译器在这里做了插入操作
        String s = (String)test1.getResult();
    }

    private Object result;
}

```

> 我的感悟：
>
> 由此可以知道  泛型 + 编译器  的最终结果就是：自动帮我们检查是否有类型错误，并且在需要的时候自动帮我们进行强制类型转换。

例如：

1. ![image-20221009213749331](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009213749331.png)
2. 由于泛型擦除的问题，下面的方法重载会报错：
   ![image-20221009213823974](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009213823974.png)
   报错原因如下：
   ![image-20221009213846538](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221009213846538.png)
   原因很简单，泛型擦除之后，List<String>与List<Integer>在编译之后都变成了List。

既然编译器要把泛型擦除，那么为什么还要使用泛型呢？用Object不是更加省事吗？

这个问题在变相的考察泛型的作用：

1. 使用泛型可以在编译期间进行类型检测。
2. 使用Object类型需要手动强制类型转换，降低代码可读性，提高出错概率，使用泛型会在必要的地方自动添加强制类型转换。
   必要的地方包括但不限于：<font color = "red">***都是在字节码中插入***</font>
   1. 调用返回类型为泛型的方法的地方
   2. 调用泛型类型的字段的地方
3. 泛型而可以使用自限定类型，如T extends Comparable。



## 1.5、什么是桥方法

桥方法是用于继承泛型类时保证多态。

![image-20221010091609621](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010091609621.png)
![image-20221010091627591](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010091627591.png)



桥方法为编译器自动生成，非手写。
桥方法会被volatile关键字修饰。

## 1.6、泛型有那些限制？为什么？

泛型的限制一般是由泛型擦除机制导致的。擦除wielObject后无法进行类型判断

1. 只能声明不能实例化T类型变量
2. 泛型参数不能是基本类型。因为基本类型不是Object子类，应该用基本类型对引用类型替代
3. 不能实例化泛型参数的数组，擦除后为Object，无法进行判断
4. 不能实例化泛型数组
5. 反省无法使用instanceof和getClass()进行判断
6. 不能实现两个不同泛型参数的同一接口，擦除后多个父类的桥方法将冲突
7. 不能使用static 修饰泛型变量

## 1.7、以下代码是否能编译，为什么？

![image-20221010092406902](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010092406902.png)

无法编译，因为x和y都会被擦除为Object类型，Object类型无法使用>进行比较
![image-20221010092450983](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010092450983.png)

无法编译，因为static不能修饰泛型T

# 2、通配符

## 2.1、什么是通配符？有什么作用？

泛型类型是固定的，某些场景下使用起来不太灵活，于是，配符就出现了！通配符可以允许类型参数变化，用来解决泛型无法协变的问题。

例如：![image-20221010092836009](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010092836009.png)

## 2.2、什么是无界通配符？

1. T可以用于声明变量或者常量，而？不行
2. T一般用于声明泛型类或者方法，通配符？一般用于泛型方法的调用代码和形参。
3. T在编译期间会被擦除为第一个限定类型或者Object，通配符用于捕获具体类型

## 2.3、什么是无界通配符

无界通配符可以接受任何泛型类型的数据，用于实现不依赖于具体参数的简单方法，而可以捕获参数类型并交由泛型方法进行处理。

![image-20221010094229032](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010094229032.png)

List<?>和List有区别吗？有：

1. List<?> list; 表示list是持有某种特定类型的list，但是不知道具体是那种类型。因此，我们添加元素的时候会报错
2. List list; 表示list是持有的元素的类型是Object，因此可以添加任何类型的对象，只不过编译器会有警告。

![image-20221010101553683](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010101553683.png)
照片中介绍的内容在《Java核心技术卷Ⅰ》第八章中有介绍，可以再去看看。

## 2.4、什么是上边界通配符？什么是下边界通配符？

在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：**类型实参只准传入某种类型的父类或某种类型的子类**

**上边界通配符** extends 可以实现泛型的向上转型即传入的类型实参必须是指定类型的子类型

![image-20221010110622892](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010110622892.png)

类型边界可以设置多个，还可以对T类型进行限制。

![image-20221010110654149](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010110654149.png)
**下边界通通配符** super与上边界通配符extends刚相反，它可以实现泛型的向下转型即传入的类型实参数是指定类型的父类型。

![image-20221010110809895](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010110809895.png)

**？ extends xxx 和 ？ super xxx 有什么区别？**

1. 两者接受参数的范围不同。

2. 使用前者只能安全的调用getter方法返回xxx类型，使用前者调用setter方法的时候会报错，因为编译器不能确定具体是外xxx类类型的哪个子类类型（xxx可能有多个子类）；

   使用后者只能安全的调用setter方法接受xxx类型（如果传递的参数是xxx类型的父类类型，那么会报错），调用getter方法的得到的是Object类型的，而不是xxx类型的，可以认为是不安全的。

**Class<?> 和 Class的区别？**

直接使用Class的话会一个类型警告，使用Class<?>的时候没有，因为Clas是一个泛型类，接受原生类型会产生警告。

## 2.5、以下代码是否能编译？为什么？

![image-20221010112023783](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010112023783.png)

不能编译，因为Node<Circle>不是Node<Shape>的子类

![image-20221010112141753](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010112141753.png)

可以编译，ChildNode<Circle>是Node<Circle>的子类

![image-20221010112223244](D:\Tyora\AssociatedPicturesInTheArticles\泛型&通配符常见面试题总结\image-20221010112223244.png)

可以编译，List<? extends Number>可以往外取元素，但是无法调用add()添加元素。





