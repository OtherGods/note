1. JVM内存模型
   ![image-20230527174953163](D:\Tyora\AssociatedPicturesInTheArticles\满帮\image-20230527174953163.png)

   1. 程序计数器：指向当前线程要执行的字节码指令的位置；此区域是Java虚拟机中唯一一个没有OOM的区域

   2. 虚拟机栈：虚拟机栈由一个个栈帧组成，每个方法在执行时都会创建一个栈帧用于存放局部变量（基本数据类型和对象引用）、操作数栈、方法出口、动态链接等信息，么一个方法从调用开始到执行完成就对应着一个栈帧在虚拟机栈中从入栈到出战的过程；可以抛出栈溢出（栈深度大于允许的最大值）、内存溢出。
      栈设置：

      1. -Xss1024k：设置栈大小为1024k相当于-XX:ThreadStack1024k

   3. 本地方法栈：Sun HotSpot把虚拟机栈和本地方法栈合二为一了

   4. 堆：JVM管理的最大一块内存区域，不要求物理连续，大小可以固定也可以扩展，是垃圾回收的主要区域，存储大多数对象实例和数组；可以抛出内存溢出异常。
      堆设置：

      1. -Xms1024k：设置堆的最小值为1024k相当于-XX:InitialHeap1024k
         【可以使用-Xmn或-XX:New1024k设置年轻代的堆的初始大小】
      2. -Xmx1024k：设置堆的最大值为1024k相当于-XX:MaxHeap1024k
         【可以使用-XX:MaxNew1024k设置年轻代的最大值】

   5. 方法区：不要求物理连续，大小可以固定也可以动态扩展，可以进行/不进行垃圾回收，存放结构化定义的一些描述信息，例如类信息、JIT编译后的代码（比如Spring使用IOC或AOP创建bean时或使用cglib反射的形式动态生成class信息等）、常量、接口、方法、字段、运行时常量池（字面量、符号引用）。
      方法区设置：

      1. -XX:MetaspaceSize=1024k
      2. -XX:MaxMetaspaceSize=1024k

      在hotspot虚拟机中用永久代来实现方法区（jdk8之前），jdk8之后（包含）用元数据空间实现。【永久代存放在堆中，其中存放的内容导致这个区域经常OOM，所以改用元数据空间，放在本地内存中，内存有多大元数据空间有多大】。

      

2. JMM（Java内存模型）
   ![image-20230527183639252](D:\Tyora\AssociatedPicturesInTheArticles\满帮\image-20230527183639252.png)

   > 计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行指令的过程中，势必会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而CPU从内存读取数据和CPU向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。
   >
   > 当程序在运行过程中，会将运算需要的数据从内存中复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到内存当中【至于是刷新到主内存还是本地内存就要看有没有被volatile修饰】。
   >
   > 线程间的共享变量存在主内存中，而对于每一个线程，都有一个私有的工作内存。工作内存是个虚拟的概念，涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化，总之就是指线程的本地内存。存在线程本地内存中的变量值对其他线程是不可见的。