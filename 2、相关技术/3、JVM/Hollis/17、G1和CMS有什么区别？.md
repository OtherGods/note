#G1 #CMS 
# 典型回答

G1 是 JDK 1.9中默认的垃圾收集器，他代替了Java 8 中的默认的==`Parallel Scavenge GC` + `Parallel Old GC`==，并且也代替了CMS。

G1 和 CMS相比，他们<font color="red" size=5>都是基于三色标记法</font>实现的，替代了原有的传统的可达性分析（三色标记也是可达性分析的一种，只不过特殊一点），可以大大的降低STW的时长。但是，他们之间还是有很大的不同的：

| 特性      | CMS                                 | G1                                             |
| ------- | ----------------------------------- | ---------------------------------------------- |
| 回收位置    | 老年代                                 | 整堆                                             |
| GC算法    | 标记-清除                               | **老年代**：标记-整理；**新生代**：标记-复制                    |
| 垃圾识别算法  | 三色标记-增量更新解决漏标                       | 三色标记-原始快照解决漏标                                  |
| 碎片产生    | 存在内存碎片                              | 不存在内存碎片                                        |
| 可预测性    | 无法预测                                | G1的STW时长可预测                                    |
| 堆内存基本要求 | 一般要求不高                              | 4G以上                                           |
| 自适应调优   | 不支持                                 | 支持                                             |
| 优点      | 低停顿、并发                              | 更低的停顿、并发、分代收集（不需要其他收集器配合）、空间整理（解决了内存碎片）、可预测的停顿 |
| 缺点      | 无法处理浮动垃圾（三色标记/GC与用户线程并发导致）、产生大量内存碎片 | 存在浮动垃圾                                         |

总结一下就是，==**G1会把Java的堆分为多个大小相等的Region（每个Region的大小为1M-32M）**==，他在 ==年轻代回收的时候采用 **标记-复制**== 算法，而在 ==老年代回收的时候，采用的是 **标记-整理**== 算法，这两种算法都可以避免内存碎片的产生。

G1在回收的过程中，==**标记**和**清理**的过程是*并行*的==，可以==充分**利用多个CPU来缩短STW**的时长==，在==**复制**的过程中是*并发*的==，可以让复制线程和用户线程并发执行，不需要STW。并且G1还可以在运行时动态的做区域内存大小的调整。
