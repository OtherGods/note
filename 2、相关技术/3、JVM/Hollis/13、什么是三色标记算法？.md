#GC对象是否存活 #三色标记 #多标 #漏标 #写屏障 #增量更新 #原始快照 

# 典型回答

**三色标记算法是一种JVM中垃圾标记的算法，他可以减少JVM在GC过程中的STW时长，他是CMS、G1等垃圾收集器中主要使用的标记算法。**

在出现三色标记算法之前，JVM中垃圾对象的标记主要采用可达性分析算法及引用计数法。但是这两种算法存在以下问题：
1. **循环引用问题**，如果两个对象互相引用，就形成了一个**环形结构**，如果采用引用计数法的话，那么**这两个对象将永远无法被回收**。
2. **STW时间长**，可达性分析的整个过程都需要STW，**以避免对象的状态发生改变(对象间引用关系可能会改变)，这就导致GC停顿时长很长**，大大影响应用的整体性能。

为了解决上面这些问题，就引入了**三色标记法**。

三色标记中新引入：一个中间状态、写屏障，配合 短暂的STW 来解决上面说的问题

**三色标记法将对象分为三种状态：白色、灰色和黑色**
- **白色**：该对象*没有被标记过*；**待回收**（不可达对象）
- **灰色**：该对象*已经被标记过了*，但该*对象的引用对象还没标记完*；**中间状态**
- **黑色**：该对象*已经被标记过了*，并且该*对象的全部引用对象也都标记过了*；**已确认存活**
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507291911853.png)

三色标记法的标记过程可以分为三个阶段：
1. **初始标记（Initial Marking）**：<font color="blue" size=5>遍历所有的根对象</font>，将**根对象**和**直接引用的对象**标记为<font color="red" size=5>灰色</font>。在这个阶段中，垃圾回收器只会扫描被直接或者间接引用的对象，而<font color="blue" size=5>不会扫描整个堆</font>。因此，初始标记阶段的**时间比较短**。<font color="blue" size=5>（Stop The World）</font>
2. **并发标记（Concurrent Marking）**：在这个过程中，垃圾回收器会<font color="blue" size=5>从灰色对象开始遍历整个对象图</font>，将**被引用的对象**标记为<font color="red" size=5>灰色</font>，并将已经遍历过的对象标记为<font color="red" size=5>黑色</font>。并发标记过程中，应用程序线程可能会修改对象图（对象引用可能被改变），因此垃圾回收器需要使用**写屏障**（Write Barrier）技术来保证并发标记的正确性。（<font color="blue" size=5>不需要STW</font>）
3. **重新标记（Remark）**：重新标记的主要作用是<font color="blue" size=5>标记在并发标记阶段中被修改的对象以及未被遍历到的对象</font>。这个过程中，垃圾回收器会<font color="blue" size=5>从灰色对象重新开始遍历对象图</font>，将被引用的对象标记为<font color="red" size=5>灰色</font>，并将已经遍历过的对象标记为<font color="red" size=5>黑色</font>。<font color="blue" size=5>（Stop The World）</font>

<font color="red" size=5>在重新标记阶段结束之后，垃圾回收器会执行清除操作，将未被标记为可达对象的对象进行回收，从而释放内存空间</font>。这个过程中，垃圾回收器会将所有未被标记的对象标记为白色（White）并回收。

以上三个标记阶段中，**初始标记** 和 **重新标记** 是需要**STW**的，而**并发标记是不需要STW**的。其中**最耗时的其实就是并发标记的这个阶段**，因为这个阶段需要遍历整个对象树，而三色标记把这个阶段做到了和应用线程并发执行，大大降低了GC的停顿时长。

# 扩展知识

## 并发标记的写屏障

<font color="red" size=5>并发标记过程中，<font color="blue" size=5>应用程序线程可能会修改对象图（对象间的引用关系）</font>，因此垃圾回收器需要使用<font color="blue" size=5>写屏障（Write Barrier）</font>技术来保证并发标记的正确性。</font>

<font color="red" size=5><font color="blue" size=5>写屏障</font>是一种在<font color="blue" size=5>对象引用被修改</font>时，<font color="blue" size=5>记录将其新的引用信息</font>到特殊数据结构中的机制。</font>在三色标记法中，写屏障技术被用于记录对象的标记状态，**并且只针对未被标记过的对象进行记录**（我理解的**未被标记的对象**也就是**漏标的对象**）。

当应用程序线程修改了一个对象的引用时，写屏障会记录该对象的新标记状态：
1. 如果该对象未被标记过，那么它会被标记为灰色，以便在<font color="red" size=5>垃圾回收器的下一次遍历中进行标记</font>
2. 如果该对象已经被标记为可达对象，那么写屏障不会对该对象进行任何操作

通过使用写屏障技术，可以使得三色标记法过程中标记更加准确。然而，尽管写屏障对于维护垃圾收集器的准确性至关重要，它们仍然存在一些<font color="red" size=5>局限性</font>：
1. **性能开销**： <font color="red" size=5>写屏障会引入额外的性能开销</font>，因为每次对象引用更新时都需要执行额外的代码。这种开销可能导致系统性能下降，尤其是在高度并发的场景中。
2. **并发修改的挑战**： 在高度并发的应用中，对象的引用可能会频繁变化。写屏障需要在每次引用变化时及时更新信息，但在极端并发条件下，可能难以捕捉到所有的变化。
3. **保守策略导致的多标**： <font color="red" size=5>为了避免误删除有效对象</font>，一些垃圾收集器可能采取保守策略，在<font color="red" size=5>存在不确定性时选择保留对象。这可能导致实际上已经不再使用的对象被错误地标记为存活</font>。
4. **优化策略的双刃剑**： 为了减轻性能开销，某些垃圾收集器可能采用优化策略，例如只在特定条件下激活写屏障。这种优化有可能导致某些引用更新被错过，影响标记的准确性。

所以，三色标记法即使在并发标记过程中用了写屏障，还是**可能会带来多标和少标的问题**。

## 多标的问题

所谓多标，其实就是<font color="red" size=5>原本应该被回收掉的白色对象，但是被错误的标记成了黑色的存活对象。从而导致这个对象没有被GC回收掉。</font>

漏标中 [原始快照](2、相关技术/3、JVM/Hollis/13、什么是三色标记算法？.md#原始快照) 方式也可能导致多标。

这个**一般发生在并发标记过程中**，该对象还是有引用的，但是在过程中，**应用程序执行过程中把他的引用关系删除了**，导致他变成了一个垃圾对象。

多标的话，会产生浮动垃圾，*这个问题一般都不太需要解决*，因为这种垃圾一般都不会太多，另外在下一次GC的时候也都能被回收掉。

## 怎么解决漏标的问题

所谓漏标，和多标刚好相反，就是说<font color="red" size=5>一个对象本来应该是黑色存活对象，但是没有被正确的标记上，导致被错误的垃圾回收掉了。</font>

这种情况一旦发生是很危险的，一个正常使用的对象被垃圾回收掉了，这对系统来说是灾难性的问题，那么如何解决呢？

具体的解决方式，在CMS和G1中也不太一样。**CMS采用的是增量更新方案**，**G1则采用的是原始快照的方案**。

漏标的问题想要发生，需要同时满足两个充要条件：
1. 至少有一个**黑色**对象在自己被**标记之后引用**了这个**白色**对象
2. 所有的**灰色**对象在自己**引用扫描完成之前删除**了对**白色对象的引用**

那么，**增量更新方案就是破坏了第一个条件**，而**原始快照方案就是破坏了第二个条件**。

### 增量更新

“至少有一个黑色对象在自己被标记之后指向了这个白色对象”，这个条件如果被破坏了，那么就**不会出现漏标**的问题。所以：

<font color="red" size=5>如果有黑色对象在自己标记后，又重新指向了白色对象。那么就把这个黑色对象的引用记录下来，在后续「重新标记」阶段再以这个黑色对象为根，对其引用进行重新扫描。</font>通过这种方式，**被黑色对象引用的白色对象就会变成灰色，从而变为存活状态**。

> 举个例子：在清理房间时，你已经检查了某个抽屉（对象）并决定里面的东西都是需要的（标记为黑色）。但是，在你继续清理其他地方时，家人回来并在这个抽屉里放了一些新的东西。增量更新就像是他们给你留了一个便条，提醒你“这个抽屉有变化，请重新检查”，确保你不会错过任何东西。

这种方式有个缺点，就是会重新扫描新增的这部分黑色对象，会浪费多一些时间。但是其实这个浪费还好，因为本来这种漏标的情况就并不是特别常见，所以这部分需要重新扫描的黑色对象也并不多。

<font color="red" size=5><font color="blue" size=5>增量更新</font>就是<font color="blue" size=5>实时记录变化</font>，确保每一次变化都会被重新检查，避免漏掉任何可能被错误视为垃圾的活跃对象。</font>

#### 实例分析

```java
class Node {
    Node next;
}

// 初始状态
Node A = new Node(); // 黑色（已扫描完成）
Node B = new Node(); // 白色（未访问）

// 用户线程执行
A.next = B; // 黑(A)→白(B)引用
```

**写屏障触发过程**：
1. 检测到黑→白引用
2. 将A降级为灰色
3. A重新加入标记栈
**后续GC行为**：
- 重新扫描灰色对象A
- 发现A引用B，将B标记为灰色
- 最终B被正确标记为存活

### 原始快照

"所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用"，这个条件如果被破坏了，那么就**不会出现漏标**的问题。所以：

<font color="red" size=5>如果灰色对象在扫描完成前删除了对白色对象的引用，那么我们就在灰色对象取消引用之前，先将灰色对象引用的白色对象记录下来。</font>

<font color="red" size=5>在后续「重新标记」阶段再以这些白色对象为根，对它的引用进行扫描，从而避免了漏标的问题。通过这种方式，原本漏标的对象就会被重新扫描变成灰色，从而变为存活状态。</font>

> 使用原始快照的方式，就像是在你开始清理房间时拍了一张照片，记录下所有需要保留的物品（即那一刻认为的“活跃”对象）。然后无论家人后来如何在房间内移动或添加物品，你的任务只需要根据照片上的记录来完成。即使物品的位置和数量发生了变化，它不会影响你这次清理的判断依据。

但是这种方式<font color="red" size=5>可能会把<font color="blue" size=5>本来真的要取消引用的对象给错误的复活了</font>，从而产生浮动垃圾</font>。但是就像前面说的，多标的问题是可以忽略的。

<font color="red" size=5>原始快照就是基于GC开始时（初始标记之前）的状态做决策，忽略之后的变化（一种保守策略），确保GC的稳定性和一致性，但可能需要更多的内存来记录快照信息。</font>

#### 实例分析（ChatGPT）

```java
class Graph {
    Node node1;
    Node node2;
}

// 初始状态
Graph g = new Graph(); // 灰色（扫描中）
Node X = new Node();   // 白色（未访问）

g.node1 = X; // 初始引用

// --- GC开始标记 ---
// g被标记为灰色（未完成扫描）

// 用户线程执行
g.node1 = null;  // 断开引用
g.node2 = X;     // 新引用

// --- GC继续标记 ---
// 完成g的扫描，标记为黑色
```

**无写屏障的后果**：
- 用户线程知道：X只被黑色对象g引用（通过g.node2）
- 但GC线程不知道：g.node2的新引用【因为用户线程和GC线程同时执行】
- X被错误回收
**SATB写屏障作用**：
1. 在初始标记阶段记录哪些字段引用了X，将 X 加入 SATB 队列
2. GC在最终标记阶段：
    - 处理 SATB 队列中的 X
    - 标记 X 为灰色（存活）
    - 扫描 X 的引用
