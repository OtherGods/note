#并发回收 #并行回收 #GC线程与用户线程 
# 典型回答

> **==GC属于计算密集型任务==**
> **==GC线程==**：执行 *垃圾回收* 的线程
> **==用户线程==**：执行 *具体业务逻辑代码* 的线程
> **==吞吐量==** = `代码运行时间 / (代码运行时间 + GC垃圾收集时间)`
> **==STW时长==**：<font color="blue" size=5>STW时长也就是用户线程停顿时长</font>
> **==持续时间==** 与 **==累计执行时间==**：举例：两个计算密集型的任务T1、T2，他们在单线程环境下分别执行所需时间各为10s；在两线程单CPU环境下并发执行，CPU分片执行，上下文1秒切换1次，T1任务累计执行时间为10s，但T1的持续时间可能达到20s

很多人知道并发和并行的概念，**并发**指的是*一个CPU不断的通过时间片切换来执行不同的任务*，**并行**是指*多个CPU同时执行不同的任务*。
[43、什么是并发，什么是并行？](2、相关技术/2、JUC/Hollis/Java并发/43、什么是并发，什么是并行？.md)

在Java的GC中，也有 **并发回收** 和 **并行回收** 的概念，但是这两个概念和我们前面提到的并发和并行之间的区别没啥关系。

**我们说的并行回收其实就是 `Parallel GC`，具体到垃圾收集器的实现上，就是 `Parallel Scavenge`，`Parallel Old`，`ParNew` 等收集器。而我们说的并发回收比较典型的就是 `Concurrenct Mark and Sweep GC`，也就是我们常说的CMS，当然`G1`也是并发回收器**

关于这几种垃圾收集器的介绍，可以看下面这篇文章，大家看完之后再继续看本文。
[16、新生代和老年代的垃圾回收器有何区别？](2、相关技术/3、JVM/Hollis/16、新生代和老年代的垃圾回收器有何区别？.md)

## 并行回收期

那么，其实我们所熟悉的 <font color="red" size=5>并行回收器</font> 主要的 <font color="red" size=5>关注目标是吞吐量</font>，所以他会想尽办法最高效率的利用CPU时间来进行垃圾回收。所以他会<font color="blue" size=5>在垃圾收集期间通常会暂停用户程序的执行（STW）</font>，以 **==快速完成垃圾收集==**。
> **==并行回收吞吐量高==** 是因为：
> 1.  STW期间停止所有用户线程，<font color="red" size=5>所有CPU核心并行执行GC任务（不需要频繁的上下文切换），极大缩短单次GC耗时</font>
>    
> **==并发回收吞吐量低==** 是因为：GC线程和用户线程交替执行，导致GC **==持续时间==** 增加（虽然GC **==累计执行时间==** 可能不变）

所以，并行回收器可以在多核处理器上显著提高垃圾收集的速度，尤其是在堆内存较大，且CPU资源充足的场景下效果最佳。

## 并发回收器

而<font color="red" size=5>并发回收器主要关注的目标是<font color="blue" size=5>STW时长（用户线程停顿的时长）</font></font>，它**允许GC线程在应用程序线程运行的同时执行部分垃圾收集工作**，从而**减少了STW时长（用户线程停顿）**。<font color="red" size=5>并发回收期间，只有在<font color="blue" size=5>特定的收集阶段会发生短暂的STW</font>。</font>
[56、什么是STW？有什么影响？](2、相关技术/3、JVM/Hollis/56、什么是STW？有什么影响？.md)

所以，并发回收器减少了用户线程停顿时间，适用于需要较低延迟的应用场景。

在适用场景上，**==并行==** 垃圾回收<font color="red" size=5>适用于<font color="blue" size=5>对用户线程停顿时长（STW时长）要求不是非常严格</font>，但希望<font color="blue" size=5>最大化吞吐量的应用</font></font>。而 **==并发==** 垃圾回收<font color="red" size=5>适用于<font color="blue" size=5>对响应时间敏感的应用</font></font>，如在线交易处理系统、游戏服务器等，这些应用需要尽可能减少GC引起的停顿。

## 并行与并发对比

|      | 并行回收器                                                                                           | 并发回收器                                                                                                                                                                                                           |
| ---- | ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 回收器  | Parallel Scavenge(新生代)、Parallel Old(老年代)、ParNew(新生代)                                            | CMS(老年代)、G1(整堆收集器)                                                                                                                                                                                              |
| 关注目标 | 吞吐量【代码运行时间/(代码运行时间+GC时间)】                                                                       | STW时长（用户线程停顿时长）                                                                                                                                                                                                 |
| STW  | 在垃圾收集期间通常会**暂停应用程序(用户线程)的执行（STW）**，集中所有CPU，以快速完成垃圾收集；<font color="blue" size=5>缩短了GC持续时间</font> | 允许 **部分垃圾收集工作** 与 **应用程序线程** 同时执行；<br>回收期间，只有在**特定的收集阶段**会发生**短暂的STW**，减少了应用程序的停顿时间，<font color="red" size=5>用户线程停顿越短，用户体验越好</font>；由于<font color="blue" size=5>GC线程和用户线程并发交替执行，导致GC累计执行时间可能不变，但GC持续时间增加</font> |
| 适用场景 | 适用于**多核处理器**、**CPU资源充足**、**内存较大**的场景；<br>对停顿时间 **（STW时间）要求不是非常严格**，但希望**最大化吞吐量**的应用；            | 对**响应时间敏感**的应用，适用于**与用户交互性强**的应用，                                                                                                                                                                               |
