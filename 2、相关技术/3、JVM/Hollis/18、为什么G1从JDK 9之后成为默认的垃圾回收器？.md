#G1 #RememberedSet #Region #Card #Rset 
# 典型回答

G1，Garbage First，是CMS的改进版，**解决了CMS内存碎片、更多的内存空间等问题**。总之，G1是一个先进的垃圾收集器，它可以**提高系统的吞吐量，降低停顿的频率，并且可以有效管理大型堆**。在JDK 9之后，G1成为了默认的垃圾回收器，主要是因为他有以下优势：

1. **并发回收**：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来==**缩短Stop The World的停顿时间**==。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
   [13、什么是三色标记算法？](2、相关技术/3、JVM/Hollis/13、什么是三色标记算法？.md)
2. **分代收集**：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说 ==**G1可以自己管理新生代和老年代**== 了。
3. **空间整合**：由于G1使用了独立区域（Region）概念，G1从整体来看是基于 ==**标记-整理**== 算法实现收集，从局部（两个Region）上来看是基于 ==**标记-复制**== 算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。
4. **可预测的停顿**：这是G1相对于CMS的另一大优势，==**降低停顿时间**==是G1和CMS共同的关注点，但==**G1除了追求低停顿外，还能建立可预测的停顿时间模型**==，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
5. 支持热插拔：G1可以在==**运行时动态调整堆的大小**==，以适应不同的内存需求。

与其它收集器相比，G1变化较大的是它<font color="red" size=5>将整个Java<font color="blue" size=5>堆划分为多个大小相等的独立区域（Region）</font>，虽然还保留了新生代和老年代的概念，但新生代和老年代不再是物理隔离的了它们都是一部分Region（不需要连续）的集合。</font>

同时，为了避免全堆扫描，G1使用了 `Remembered Set`（参考：[40、什么是跨代引用，有什么问题？](2、相关技术/3、JVM/Hollis/40、什么是跨代引用，有什么问题？.md) 和 [Remembered Set](2、相关技术/3、JVM/Hollis/18、为什么G1从JDK%209之后成为默认的垃圾回收器？.md#Remembered%20Set)） 来管理相关的对象引用信息。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏了。

Garbage First (G1) 是一种面向大型内存环境的垃圾回收算法。因此，G1适合在以下场景中使用：
1. **大型内存环境**：G1针对大型内存环境进行了优化，因此对于使用了大量内存的应用程序来说（超过4G），G1是一个更好的选择。
2. 对应用**程序响应时间敏感的场景**：G1通过分配多线程来进行垃圾回收，以最大限度地减少回收时应用程序的暂停时间。
3. 对**内存使用效率敏感的场景**：G1可以更好地评估哪些内存空间可以释放，以此来提高内存的利用率。
4. 动态内存需求的场景：G1支持热插拔，可以在运行时**动态调整堆的大小**，以适应不同的内存需求。
5. 要求回收时间具有可预测性的场景：G1使用固定的内存分配块来管理堆内存，这使得其在回收时间上具有更高的可预测性。

所以，如果应用程序需要在**大型内存环境**下运行，同时**对内存使用效率和应用程序的响应时间敏感**，那么G1是一个更好的选择。


# Remembered Set

来自KEVIN：[一次性精通JVM-理论篇-授课版-笔记中](2、相关技术/3、JVM/带你学习jvmjava虚拟机arthas_性能调优_故障排除_gc回收_内存溢出等/KEVIN授权学员专属资料-JVM课程51CTO-01/外发资料/一次性精通JVM-理论篇-授课版-笔记中.pdf)

## 介绍

2012年才在jdk1.7u4中可以使用，Oracle在jdk1.9中将G1变为默认的垃圾收集器，来代替CMS

**优点**
- **并发与并行**：G1能充分利用多CPU、多核环境的硬件优势，<font color="red" size=5>缩短STW(stop the word)停顿时间</font>
- **分代收集**：不需要其他收集器配合就能管理整个GC堆，同时管理新生代和老年代
- **空间整理**：整体上基于标记-整理算法，局部基于复制算法，G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存
- **可预测的停顿**：G1除了降低了STW时间外，还能建立可预测的停顿时间模型，比如指定在M毫秒内，消耗在GC上时间不得超过N毫秒。
- <font color="red" size=5>将新生代、老年代的<font color="blue" size=5>物理空间划分取消了（只存在逻辑空间划分）</font>，再也<font color="blue" size=5>不用单独设置每个代的大小了</font>，也不用担心它们的内存是否足够</font>
- **G1也采用分代垃圾回收策略**

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507301908605.png)
在有Humongous之前：在存放一个大的对象的时候，如果新生代放不下，那么会将这个大的对象放到老年代，但是如果这个对象用了一次之后就可以不再使用，可以被清除，那么放在老年代不是一个好的选择，因为老年代的清除周期长，所以有了Humongous来存放这种大对象。

G1-Garbage First,专注于垃圾最多的分区，花费较少的时间就能回收较多的垃圾，因为这个特性因此称之G1。

## Region

1. G1收集器将堆内存划分为一系列大小相等的Region区域，Region大小在1M到32M，在启动时由JVM确定；`-XX:G1HeapRegionSize=n`，可以使用这个参数设置每个Region的大小，必须是2的指数大小
2. 分为Eden、Survivor、Old、Humongous区，逻辑连续但是物理上不连续，一个Old Region在收集后可能变成一个Eden Region区域

### Card和Rset

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507301918024.png)
- 每一个`Regin`被分为大小相等的`Card`，每个Card大小为512 bytes
- 红色`Card`表示引用其他对象，蓝色`Card`表示被其他对象引用
- 逻辑上每一个`Region`都有一个`Rset`，全称是 `Remembered Set` 是一种GC辅助结构，空间换时间策略
- Rset使用 `points-in` 的方式记录每个`Card`的 `points-out` ，Rset中只记录其他`Region`到本`Region`的引用关系，本`Region`内部的引用关系不记录【<font color="red" size=5>记录了谁引用了我</font>】

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507301929413.png)
- **==HashTable结构==**，Key值为引用对象所在Region的起始地址、Value为引用对象所在的Card索引
	- RSet中记录的是哪个区域中的哪个卡片引用了我，哪个区域用key记录，key对应的value记录哪个区域中的那些个卡片，类似于HashMap中的数组+链表的存储方式（当然HashMap不只有这种存储方式）
- 主要记录`young->old`、`old->young`、`old->old`之间的引用，**如果不记录，就要扫描整个old区去确认对象是否存活，性能低下**。
- <font color="red" size=5>Young GC的时候，只要<font color="blue" size=5>扫描所有的年轻代Region的Rset</font>，就可以确认所有<font color="blue" size=5>老年代到年轻代的引用</font>，不用扫描整个老年代。</font>[40、什么是跨代引用，有什么问题？](2、相关技术/3、JVM/Hollis/40、什么是跨代引用，有什么问题？.md)
- <font color="red" size=5>Full GC的时候，只要<font color="blue" size=5>扫描所有老年代Region的Rset</font>，就可以确认<font color="blue" size=5>所有老年代之间的引用、以及新生代到老年代的引用</font>，这样不用扫描整个年轻代和老年代。</font>[40、什么是跨代引用，有什么问题？](2、相关技术/3、JVM/Hollis/40、什么是跨代引用，有什么问题？.md)
- 总结：付出了空间、维护的代价、带来了GC回收效率的提升

### G1垃圾收集器核心-收集类别

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507302018427.png)

#### Young GC

新生代是一种STW方式的（停止所有线程）

Young GC收集年轻代里的Region，主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空。

- **阶段1**：根扫描：静态和本地对象被扫描 
- **阶段2**：更新RS：处理`dirty card`更新RS
	- 每一个card被另一个card引用之后就会被标记为`dirty card`
- **阶段3**：处理RS：检测从年轻代指向年老代的对象  -> 记录Cset（Collection Set） 
	- `CSet`记录Eden区中需要被阶段4处理的对象的集合
- **阶段4**：对象拷贝：拷贝存活的对象到survivor/old区域
- **阶段5**：处理引用队列：软引用，弱引用，虚引用处理

#### Mixed GC

收集所有新生代以及部分老年代，包含Young GC

- 回收年轻代的所有Region、以及全局并发标记阶段选出的老年代Region。
- 当old region的对象占总Heap的比例超过阈值（默认45%）之后，就会开始并发标记（Concurent Marking）, 完成并发标记后，G1会从Young GC切换到Mixed GC, 在Mixed GC中，G1可以增加若干个Old区域的Region到CSet中。
- `-XX:InitiatingHeapOccupancyPercent=45`，开始一个标记周期的堆占用比例阈值，默认45%，注意这里是整个堆，不同于CMS中的Old堆比例。
- **阶段1**：全局并发标记（global concurrent marking）：<font color="blue" size=6>标记存活的对象，并且计算各个Region的活跃度</fonr>
	- S1.1**初始标记**（initial mark，STW）：**暂停所有线程**，标记出所有 **==可以直接从GC roots可以到达的对象==**，这是在Young GC的暂停收集阶段顺带进行的
	- S1.2**根区域扫描**（root region scan）：找出所有的 **==GC Roots的 Region==**, 然后 **==从这些Region开始标记可到达的对象==**。【可以和用户线程并发】
	- S1.2**并发标记**（Concurrent Marking）：在整个堆中查找存活的对象。该阶段与应用程序同时运行。【可以和用户线程并发】
	- S1.3**最终标记**（Remark，STW）：处理SATB(Snaphot-At-The-Beginning标记算法，这就是三色标记写屏障中的原始快照：[原始快照](13、什么是三色标记算法？#原始快照)) 缓冲区，跟踪未被访问的存活对象。 
	- S1.4**清除垃圾**（Cleanup，STW）：执行<font color="red" size=5>统计</font>和 RSet 净化的  STW 操作。在统计期间，G1 GC 会<font color="red" size=5>识别完全空闲的区域 和 可供进行混合垃圾回收的区域</font>（**==这是最重要的一步==**，类似于出个统计报表给G1，G1根据可供回收的区域黑完全空闲的区域以及用户提供的允许停顿的时间来判断回收哪些区域）
- **阶段2**：拷贝存活对象（evacuation）

**==总结==**：根据由三色标记衍生的步骤（初始标记、根区域扫描、并发标记、最终标记）<font color="red" size=5>统计各个Region的活跃度</font>，结合G1特性中的<font color="red" size=5>可预测停顿（允许m秒内停顿n秒）</font>，**==选择清理那个活跃度Region中的数据==**。

#### Full GC

- G1的一些收集过程是和应用程序并发执行的，所以可能还没有回收完成，是由于申请内存的速度比回收速度快，新的对象就占满了所有空间，在CMS中叫做Concurrent Mode Failure, 在G1中称为Allocation Failure，这时候就会触发Full GC
- G1是不提供FullGC的，因此会触发Serial Old，使用单线程进行FullGC，一旦FullGC对性能影响十分严重