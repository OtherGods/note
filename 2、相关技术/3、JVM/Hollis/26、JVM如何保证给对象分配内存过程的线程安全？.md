# 典型回答

首先，我们先来梳理下，JVM是如何给对象分配内存的：
1. 如果`JIT`的逃逸分析后该对象没有逃逸，那么可能优化到==**栈上分配**==。
2. 否则对象主要==**分配到新生代**==上，如果启动了`TLAB`，则==**分配到`TLAB`**==中，如果没启动`TLAB`采用 **`CAS` + 失败重试机制** 直接 **==分配到Eden==**；对象较大要直接分配到Eden
3. 如果被判断为大对象，则==**直接分配到老年代**==，譬如很长的字符串和数组，避免为大对象分配内存时由于分配担保机制（[空间分配担保机制](8、新生代如果只有一个Eden+一个Survivor可以吗？#空间分配担保机制)）带来的复制而降低效率 。可以<font color="red" size=5>设置 -XX:PretenureSizeThreshold ，令大于该尺寸的对象直接进入老年代</font>

简而言之，如下图所示：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507312238039.png)

所以，我们到这里就很清楚了，当给对象分配内存的时候，有可能在栈上分配，这自然不存在线程安全问题。除此之外，如果在堆上分配，则可能会启动 **`TLAB`** 机制，使得 **堆内存给线程单独划分空间，避免了线程安全的问题**。

同时，当 **不启动`TLAB`** 机制的时候，如果一个空间被多个线程同时分配对象，**JVM会采用 `CAS+失败重试` 的方式来避免线程问题**。（具体的CAS机制和其利弊可以移步到JAVA并发专栏）

简而言之，是采用乐观锁的方式，只有假定该堆没有被其他线程操作的时候，当前线程才会在堆上分配对象，如果被其他线程操作，就获取当前堆中的最新标识，然后重试

# 知识扩展

## 什么是TLAB

`TLAB`是虚拟机在 **<font color="red" size=5>堆内存的Eden</font>划分出来的一块专用空间，是<font color="red" size=5>线程专属</font>的**。在虚拟机的`TLAB`功能启动的情况下，在<font color="red" size=5><font color="blue" size=5>线程初始化时</font>，虚拟机会<font color="blue" size=5>为每个线程分配一块TLAB空间</font>，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要<font color="blue" size=5>给某线程分配内存，就在自己的空间上分配</font>，这样就不存在竞争的情况，可以大大提升分配效率。</font>

注意到上面的描述中”线程专属”、”只给当前线程使用”、”每个线程单独拥有”的描述了吗？

所以说，**==因为有了`TLAB`技术，堆内存并不是完完全全的线程共享，其Eden区域中还是有一部分空间在分配时是线程独享的==**。

这里值得注意的是，我们说`TLAB`是线程独享的，但是只是==**在“分配”这个动作上是线程独占的**==，至于==**在读取、垃圾回收等动作上都是线程共享的**==。而且在使用上也没有什么区别。

也就是说，虽然每个线程在初始化时都会去堆内存中申请一块`TLAB`，并不是说这个`TLAB`区域的内存其他线程就完全无法访问了，其他线程的读取还是可以的，只不过无法在这个区域中分配内存而已。

并且，在`TLAB`分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能通过TLAB分配内存，存放在Eden区，但是还是会被垃圾回收或者被移到Survivor Space、Old Gen等

## TLAB的缺点

虽然在一定程度上，**`TLAB`大大的提升了对象的分配速度**，但是TLAB并不是就没有任何问题的。

前面我们说过，因为`TLAB`内存区域并不是很大，所以，有可能会经常出现不够的情况。在《实战Java虚拟机》中有这样一个例子：

比如一个线程的`TLAB`空间有100KB，其中已经使用了80KB，当需要再分配一个30KB的对象时，就无法直接在`TLAB`中分配，遇到这种情况时，有两种处理方案：
1. 直接在堆内存中对该对象进行内存分配。
2. 废弃当前`TLAB`，重新申请`TLAB`空间再次进行内存分配。

以上两个方案各有利弊，如果采用方案1，那么就可能存在着一种极端情况，就是`TLAB`只剩下1KB，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。

如果采用方案2，也有可能存在频繁废弃`TLAB`，频繁申请`TLAB`的情况，而我们知道，虽然在`TLAB`上分配内存是线程独享的，但是`TLAB`内存自己从堆中划分出来的过程确实可能存在冲突的，所以，**==`TLAB`的分配过程其实也是需要并发控制的==**。而频繁的`TLAB`分配就失去了使用`TLAB`的意义。

为了解决这两个方案存在的问题，虚拟机定义了一个`refill_waste`的值，这个值可以翻译为“最大浪费空间”。

当请求分配的内存大于`refill_waste`的时候，会选择在堆内存中分配。若小于`refill_waste`值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。

前面的例子中，`TLAB`总空间100KB，使用了80KB，剩余20KB，如果设置的refill_waste的值为25KB，那么如果新对象的内存大于25KB，则直接堆内存分配，如果小于25KB，则会废弃掉之前的那个`TLAB`，重新分配一个`TLAB`空间，给新对象分配内存。

> 当一个`TLAB`被填满或者废弃时，原有`TLAB`中的对象不会被移动或复制到新的`TLAB`中。在JVM中，<font color="red" size=5>一旦对象被分配在堆上，它们通常会保持在原地直到被垃圾回收</font>。所以，<font color="blue" size=5>当一个TLAB用完时，线程会简单地分配一个新的TLAB，并在新的TLAB上继续对象分配；原有TLAB中的对象将保留在其当前位置</font>，直到它们不再被引用并由垃圾收集器回收。