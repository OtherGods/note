#垃圾收集器 #SerialGC #SerialOld #ParNew #ParallelScavenge #ParallelOld #CMS #G1 #ZGC #垃圾收集参数 #GC日志参数 #垃圾收集器总结对比 
# 典型回答

常见的垃圾回收器如下：
1. 串行垃圾回收器（Serial Garbage Collector） 如：Serial GC， Serial Old
2. 并行垃圾回收器（Parallel Garbage Collector） 如：Parallel Scavenge，Parallel Old，ParNew
3. 并发标记扫描垃圾回收器（CMS Garbage Collector、G1）
4. G1垃圾回收器（G1 Garbage Collector，JDK 7中推出，JDK 9中设置为默认） 
5. ZGC垃圾回收器（The Z Garbage Collector，JDK 11 推出）

**新生代收集器：Serial（串行）、ParNew（并行）、Parallel Scavenge（并行）**
**老年代收集器：Serial Old（串行）、Parallel Old（并行）、CMS（并发）**
**整堆收集器：G1、ZGC**
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507300024864.png)

# 扩展知识

## 串行垃圾收集器

### Serial GC

**适用于 ==新生代== ，`Serial`是 <font color="blue" size=5>单线程</font> 的串行垃圾回收器，主要采用 ==标记-复制== 算法进行垃圾回收。**

单线程地好处就是**减少上下文切换，减少系统资源的开销**。但这种方式的缺点也很明显，<font color="red" size=5>在GC的过程中，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（Stop The World）</font>。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。 

### Serial Old

**适用于 ==老年代== ，`Serial Old`是Serial的老年代版本，也是个 <font color="blue" size=5>单线程</font> 收集器，使用的是 ==标记-整理== 算法。**

优缺点基本和Serial差不多，二者主要是回收算法不一样。

是CMS收集器的背后方案，在CMS并发收集失败时使用。

## 并发回收与并行回收

[52、说一说JVM的并发回收和并行回收](2、相关技术/3、JVM/Hollis/52、说一说JVM的并发回收和并行回收.md)

## 并行垃圾收集器

### ParNew

**适用于==新生代== 的垃圾回收器，`ParNew`其实就是`Serial`的多线程 <font color="blue" size=5>并行</font> 执行的，在参数、回收算法上，和`Serial`是完全一样的，所以他也是采用 ==标记-复制== 算法进行垃圾回收的。**

<font color="red size=5">ParNew在垃圾回收的时候，同样会<font color="blue" "size=5">STW</font></font>，但是因为它是多线程并行进行垃圾回收的，所以通常情况下时间会比Serial短一些。

### Parallel Scavenge

**适用于 ==新生代== 的垃圾回收器，和`ParNew`一样，他也是多线程 <font color="blue" size=5>并行</font> 执行的，同样采用的也是 ==标记-复制== 算法**。与ParNew最大的不同是，**`Parallel Scavenge` 关注的是垃圾回收的 ==吞吐量==** （吞吐量=代码运行时间/(代码运行时间+垃圾收集时间)，以吞吐量优先。

因为`Parallel Scavenge`收集器的**高吞吐量**可以最**高效率的利用CPU时间**，尽快的完成程序的运算任务等，所以他主要适合在后台运算，比如一些定时任务的执行。

### Parallel Old

**是 `Parallel Scavenge`的 ==老年代== 版本，同样是一个 ==关注吞吐量== 的 <font color="blue" size=5>并行</font> 垃圾收集器，他采用的是 ==标记-整理== 算法算法进行垃圾回收的。**

## 并发回收

### CMS

CMS等收集器的**目的**是**尽可能的缩短垃圾回收时用户线程的停顿时间，提升用户体验**，适用于与用户交互性强的服务

**`CMS`，Concurrent Mark Sweep，同样是 ==老年代== 的收集器**。他也是一个 <font color="blue" size=5>并发</font> 执行的垃圾收集器，他和Parallel最大的区别是他**更加 ==关注垃圾回收时用户线程的停顿时间==** ，通过他的名字Concurrent Mark Sweep就可以知道，他**采用的是耗时更短的 ==标记-清除== 算法**。
[54、介绍下CMS的垃圾回收过程](2、相关技术/3、JVM/Hollis/54、介绍下CMS的垃圾回收过程.md)

### G1

**==全代收集==**，<font color="red" size=5>并发</font>回收，**==关注垃圾回收停顿时间==**，采用 ==**标记-复制 / 标记-整理**==。
[18、为什么G1从JDK 9之后成为默认的垃圾回收器？](2、相关技术/3、JVM/Hollis/18、为什么G1从JDK%209之后成为默认的垃圾回收器？.md)
[17、G1和CMS有什么区别？](2、相关技术/3、JVM/Hollis/17、G1和CMS有什么区别？.md)

## ZGC

[19、JDK 11中新出的ZGC有什么特点？](2、相关技术/3、JVM/Hollis/19、JDK%2011中新出的ZGC有什么特点？.md)

## 垃圾收集器的组合及参数解析

### 垃圾收集器组合

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507302047329.png)

### 垃圾收集器参数设置

参考：[GC参数](5、JVM的运行时内存区域是怎样的？#GC参数)

通过JVM参数`-XX:+PrintCommandLineFlags`显示所有设置成功的JVM参数以及JVM自动计算的默认参数（如：堆大小、线程栈大小等）

| 新生代/老年代           | 老年代              | JVM参数                                                                                 |
| ----------------- | ---------------- | ------------------------------------------------------------------------------------- |
| Serial(DefNew)    | Serial Old       | `-XX:+UseSerialGC`                                                                    |
| ParNew            | CMS + Serial Old | `-XX:+UseParNewGC` 或 <br>`-XX:+UseConcMarkSweepGC`<br>jdk1.8种可以不使用第二 <br>个参数          |
| Parallel Scavenge | Parallel Old     | `-XX:+UseParallelGC` 或<br>`-XX:+UseParallelOldGC`                                     |
| G1                | G1               | `-XX:+UseG1GC`                                                                        |
| ParNew            | Serial Old       | 已经废弃，直接使用ParNew+CMS+Serial Old组合，不支持- <br>XX:+UseParNewGC -XX:-UseConcMarkSweepGC参数组合 |

- SerialGC + SerialOld：`java -XX:+PrintCommandLineFlags -XX:+UseSerialGC -version`
- ParNew + CMS：`java -XX:+PrintCommandLineFlags -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -version`
- ParallelScavenge + ParallelOld：
	- `java -XX:+PrintCommandLineFlags -XX:+UseParallelGC -version`
	- `java -XX:+PrintCommandLineFlags -XX:+UseParallelOldGC -version`
- G1：`java -XX:+PrintCommandLineFlags -XX:+UseG1GC -version`
- SerialGC + CMS：`java -XX:+PrintCommandLineFlags -XX:+UseSerialGC -XX:+UseConcMarkSweepGC –version  //非法`
- ParNew + serialOld：`java -XX:+PrintCommandLineFlags -XX:+UseParNewGC -XX:-UseConcMarkSweepGC –version  //废弃`

1. `-XX:+UseSerialGC`
   允许**使用串行垃圾收集器**。对于不需要垃圾收集的任何特殊功能的**小型和简单应用程序**，这通常是最佳选择。
   *默认情况下，禁用此选项*，并根据计算机的配置和JVM的类型自动选择收集器
2. `-XX:+UseParNewGC`
   允许在年轻代中使用并行线程进行收集。
   *默认情况下，禁用此选项*。设置`-XX:+UseConcMarkSweepGC`选项时会自动启用它。使用`-XX:+UseParNewGC`不带选项`-XX:+UseConcMarkSweepGC`的选择是在JDK 8弃用。
3. `-XX:+UseConcMarkSweepGC`
   允许为老年代使用CMS垃圾收集器。Oracle建议您在并行整理（`-XX:+UseParallelGC`）垃圾收集器无法满足应用程序延迟要求时使用CMS垃圾收集器，G1垃圾收集器（`-XX:+UseG1GC`）是另一种选择。
   *默认情况下，禁用此选项*，并根据计算机的配置和JVM的类型自动选择收集器；启用此选项后，将`-XX:+UseParNewGC`自动设置该选项，您不应禁用该选项，因为JDK 8中已弃用以下选项组合：`-XX:+UseConcMarkSweepGC -XX:-UseParNewGC`。
4. `-XX:+UseParallelGC`
   允许使用并行整理垃圾收集器（也称为吞吐量收集器），通过利用多个处理器来提高应用程序的性能。
   *默认情况下，禁用此选项*，并根据计算机的配置和JVM的类型自动选择收集器。如果已启用，则会自动启用`-XX:+UseParallelOldGC`该选项，除非您明确禁用它。
5. `-XX:+UseParallelOldGC`
   允许将并行垃圾收集器用于完整的GC。
   *默认情况下，禁用此选项*。启用它会自动启用`-XX:+UseParallelGC`选项。
6. `-XX:+UseG1GC`
   允许使用垃圾优先（G1）垃圾收集器。它是一个服务器式垃圾收集器，针对具有大量RAM的多处理器计算机。它以高概率满足GC暂停时间目标，同时保持良好的吞吐量。G1收集器推荐用于需要大堆（大小约为6 GB或更大）且GC延迟要求有限的应用（稳定且可预测的暂停时间低于0.5秒）。 
   *默认情况下，禁用此选项*，并根据计算机的配置和JVM的类型自动选择收集器。

## GC日志参数解析

这些参数默认都是禁用的

1. `-verbose:gc` 等于 `-XX:+PrintGC`
   显示有关每个**垃圾回收（GC）事件的信息**。 
2. `-XX:+PrintGC` 等于 `-verbose:gc`
   允许**在每个GC上打印消息**。默认情况下，禁用此选项。 
3. `-XX:+PrintGCDetails`
   允许**在每个GC上打印详细消息**。默认情况下，禁用此选项。 
4. `-XX:+PrintGCTimeStamps`
   【打印GC发生的时间，要配合`-XX:+PrintGCDetails`一起用，否则没效果】
   允许**在每个GC上打印时间戳**。默认情况下，禁用此选项。 
5. `-XX:+PrintGCDateStamps`
   【打印GC发生的时间，要配合`-XX:+PrintGCDetails`一起用，否则没效果】
   允许**在每个GC上打印日期戳**。默认情况下，禁用此选项。 
5. `-XX:+PrintGCTaskTimeStamps` 【不怎么常用】
   允许**为每个GC工作线程任务打印时间戳**。默认情况下，禁用此选项。 
6. `-XX:+PrintHeapAtGC`  【重要】
   在**GC发生之前与之后打印堆的详细信息**

常用命令组合：
1. `-Xmn2m -Xmx6M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseSerialGC -XX:+PrintCommandLineFlags`
2. `-Xmn2m -Xmx6M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+UseSerialGC -XX:+PrintCommandLineFlags`

示例代码：`Demo com.mimaxueyuan.jvm.gc.SerialGCDemo`

### 示例一：SerialGC + SerialOld

JVM参数：
```shell
-Xmn2m -Xmx6M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+UseSerialGC -XX:+PrintCommandLineFlags
```

YoungGC日志格式：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508041833536.png)

FullGC日志格式：
- 触发空间分配担保：
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508041831186.png)
- 正常FullGC：
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508041846850.png)

### 示例二：ParNew + CMS + Serial Old

JVM参数：除了垃圾收集器不一样外，其他参数都和SerialGC相同
```shell
-Xmn2m -Xmx6M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+UseParNewGC - 
XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags
```
下图仅圈出与SerialGC不一样的位置（仅名称不同）

YoungGC:
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508041847073.png)

FullGC日志格式：
- 触发空间分配担保：
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508041851696.png)
- 正常FullGC：
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508041907124.png)

### 示例三：ParallelGC + ParallelOld

JVM参数：除了垃圾收集器不一样外，其他参数都和SerialGC相同
```shell
-Xmn2m -Xmx6M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+UseParallelGC -XX:+PrintCommandLineFlags
```

YoungGC日志格式:
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508042041213.png)

FullGC日志格式：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508042043807.png)

三种日志格式对比：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508042044026.png)

### 示例四：G1
JVM参数
```shell
-Xmx6M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+UseG1GC -XX:+PrintCommandLineFlags
```
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508042056463.png)

## 总结对比

| 特性             | SerialGC                                              | SerialOld | ParNew         | ParallelScavenge | ParallelOld    | CMS                        | G1                                                                                                    | ZGC               |
| -------------- | ----------------------------------------------------- | --------- | -------------- | ---------------- | -------------- | -------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------- |
| 垃圾标识           |                                                       |           |                |                  |                |                            | 三色标记                                                                                                  |                   |
| 垃圾回收算法         | 标记-复制                                                 | 标记-整理     | 标记-复制          | 标记-复制            | 标记-整理          |                            | 标记-复制、标记-整理                                                                                           |                   |
| 回收位置           | 新生代                                                   | 老年代       | 新生代            | 新生代              | 老年代            | 整堆                         | 整堆                                                                                                    | 整堆                |
| 单线程/多线程（并发/并行） | 单线程                                                   | 单线程       | 多线程并行          | 多线程并行            | 多线程并行          |                            | 多线程并发+并行                                                                                              |                   |
| STW            | STW                                                   | STW       | STW            | STW              | STW            |                            | 写屏障+原始快照+STW                                                                                          |                   |
| 关注目标           |                                                       |           | 吞吐量            | 吞吐量              | 吞吐量            | 在保持高吞吐量的情况下，保证低            | STW时长（用户线程停顿时长）                                                                                       | 在保持高吞吐量的情况下，保证低停顿 |
| 优点             | **简单高效**；对于单个CPU的环境来说，由于没有线程上下文切换的开销，因而可以获得最高的单线程收集效率 | 同SerialGC | 多核多线程并行可以提高吞吐量 | 多核多线程并行可以提高吞吐量   | 多核多线程并行可以提高吞吐量 | 1. 并行回收可以降低STW时长（用户线程停顿时间） | 1. 并行回收可以降低STW时长（用户线程停顿时间）<br>2. 分代收集策略，勿需配合其他垃圾收集器<br>3. 可预测的停顿时间<br>4.堆内存无需我们设置，可以自动管理<br>5. 没有空间碎片 |                   |
| 缺点             | GC时暂停所有用户线程直到GC结束                                     | 同SerialGC | 同SerialGC      | 同SerialGC        | 同SerialGC      | 存在空间碎片，存在浮动垃圾              | 存在浮动垃圾                                                                                                |                   |

G1与CMS对比，来自：[17、G1和CMS有什么区别？](2、相关技术/3、JVM/Hollis/17、G1和CMS有什么区别？.md)

| 特性      | CMS                                 | G1                                                       |
| ------- | ----------------------------------- | -------------------------------------------------------- |
| 回收位置    | 老年代                                 | 整堆                                                       |
| GC算法    | 标记-清除                               | **老年代**：标记-整理；**新生代**：标记-复制                              |
| 垃圾识别算法  | 三色标记-增量更新解决漏标                       | 三色标记-原始快照解决漏标                                            |
| 碎片产生    | 存在内存碎片                              | 不存在内存碎片                                                  |
| 可预测性    | 无法预测                                | G1的STW时长可预测                                              |
| 堆内存基本要求 | 一般要求不高                              | 4G以上                                                     |
| 自适应调优   | 不支持                                 | 支持                                                       |
| 优点      | 低停顿、并发、响应快（用户体验好）                   | 更低的停顿、并发、分代收集（不需要其他收集器配合）、空间整理（解决了内存碎片）、可预测的停顿、可以动态调整堆大小 |
| 缺点      | 无法处理浮动垃圾（三色标记/GC与用户线程并发导致）、产生大量内存碎片 | 存在浮动垃圾                                                   |
| 适用场景    |                                     | 大型内存环境、对内存使用效率和应用程序的响应时间敏感                               |

并行与并发回收对比：[总结对比](2、相关技术/3、JVM/Hollis/52、说一说JVM的并发回收和并行回收.md#总结对比)

|      | 并行回收器                                                                                           | 并发回收器                                                                                                                                                                                                           |
| ---- | ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 回收器  | Parallel Scavenge(新生代)、Parallel Old(老年代)、ParNew(新生代)                                            | CMS(老年代)、G1(整堆收集器)                                                                                                                                                                                              |
| 关注目标 | 吞吐量【代码运行时间/(代码运行时间+GC时间)】                                                                       | STW时长（用户线程停顿时长）                                                                                                                                                                                                 |
| STW  | 在垃圾收集期间通常会**暂停应用程序(用户线程)的执行（STW）**，集中所有CPU，以快速完成垃圾收集；<font color="blue" size=5>缩短了GC持续时间</font> | 允许 **部分垃圾收集工作** 与 **应用程序线程** 同时执行；<br>回收期间，只有在**特定的收集阶段**会发生**短暂的STW**，减少了应用程序的停顿时间，<font color="red" size=5>用户线程停顿越短，用户体验越好</font>；由于<font color="blue" size=5>GC线程和用户线程并发交替执行，导致GC累计执行时间可能不变，但GC持续时间增加</font> |
| 适用场景 | 适用于**多核处理器**、**CPU资源充足**、**内存较大**的场景；<br>对停顿时间 **（STW时间）要求不是非常严格**，但希望**最大化吞吐量**的应用；            | 对**响应时间敏感**的应用，适用于**与用户交互性强**的应用，                                                                                                                                                                               |
