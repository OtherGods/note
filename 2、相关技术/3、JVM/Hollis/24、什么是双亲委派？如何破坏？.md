# 典型回答

下图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。

**双亲委派模型**要求**除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。**
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507280825885.png)

双亲委派模型的工作过程是：<font color="red" size=5>如果一个类加载器收到了类加载的请求，<font color="blue" size=5>先检查是否已经加载过这个类，如果有则直接返回</font>，如果<font color="blue" size=5>没有它也不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成</font>，每一个层次的类加载器都是如此，因此<font color="blue" size=5>所有的加载请求最终都应该传送到顶层的启动类加载器中</font>，只有当<font color="blue" size=5>父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</font>。</font>

双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在`java.lang.ClassLoader`的`loadClass()`方法之中，代码简单，逻辑清晰易懂：**先调用==`findLoadedClass()`检查类是否已经被加载过==，若没有加载则调用父加载器的`loadClass()`方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的==`findClass()`方法加载加载指定范围下字节码==，`findClass`方法中会调用==`defineClass`方法将字节码转换为`Class`对象==。**

**双亲委派模型主要是由`ClassLoader#loadClass`实现的，我们只需要自定义类加载器，并且重写其中的loadClass方法，即可破坏双亲委派模型。**

# 扩展知识

## KEVIN介绍的类加载器

### 原理、源码、Demo

![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508031801128.png)

这几个类加载器加载路径范围在`Launcher`类中能查找到：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508031804704.png)

扩展类加载器和应用类加载器都是继承自`URLClassLoader`类（间接继承自`ClassLoader`）
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508031738147.png)

三种类加载器加载范围查看：
1. BootstrapClassLoader加载的类路径
	- `sun.boot.class.path`
2. ExtensionClassLoader加载的类路径
	- `java.ext.dirs`
3. AppClassLoader加载的类路径
	- `java.class.path`
DEMO演示
 `com.mimaxueyuan.jvm.classloader.AppClassLoaderDemo0`
 `com.mimaxueyuan.jvm.classloader.BootstrapClassLoaderDemo0`
 `com.mimaxueyuan.jvm.classloader.ExtensionClassLoaderDemo0`
 父加载器演示：`com.mimaxueyuan.jvm.classloader.ClassLoaderDemo0`

通过参数 `-verbose:class` 可以输出所有的类加载日志

<font color="red" size=5>类加载器重要源码</font>:
1. **加载类：**
	- `java.lang.ClassLoader.loadClass(String)`
	- `java.lang.ClassLoader.loadClass(String, boolean)`
2. **查找类有没有被加载过：**
	- `java.lang.ClassLoader.findLoadedClass(String)`
3. **在指定路径查找并加载类：** 
	- `java.lang.ClassLoader.findClass(String)`
   按照KEVIN讲的，这个方法的功能大概是：建立IO，将磁盘上的字节码文件，以文件输入流动的方式读取到内存字节输出流中；

   参考：KEVIN自定义的类加载器`KevinClassLoader0`中`findClass`方法![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508031831389.png)
4. **字节码二进制流转Class对象：** 在这一步会 **==校验被加载的类是不是以`java.` 开头的，是的话不能加载，保证JDK源码的不被篡改==**
	- `java.lang.ClassLoader.defineClass(String, byte[], int, int)` 
    参考：KEVIN自定义的类加载器`KevinClassLoader0`中`findClass`方法![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202508031858447.png)

### 双亲委托的作用

1. 每个加载器都只加载自己负责范围内的路径下的class文件，所有的类必须先递归到父加载器进行加载，**避免了同一个class被重复加载，保证类一个类的字节码只被加载一次**。
	- 例如在项目中编写一个java.lang.String类
2. **保证了安全性，防止核心类被篡改**
	- 例如自己编写一个类加载器，加载`D:\lib`下的类，来覆盖系统类
3. **对加密后的字节码解密，防止源码泄露**，对应类`KevinClassLoader2`

示例代码: 
- 自定义类加载器加载指定的类：`com.mimaxueyuan.jvm.classloader.KevinClassLoader0`
- 自定义类加载器对字节码解密并加载：
  `com.mimaxueyuan.jvm.classloader.KevinClassLoader2`

`KevinClassLoader2.java`
```java
package com.mimaxueyuan.jvm.classloader;  
  
import java.io.ByteArrayOutputStream;  
import java.io.File;  
import java.io.FileInputStream;  
import java.io.FileOutputStream;  
import java.io.IOException;  
  
/**  
 * @ClassName: KevinClassLoader0 * @Description:TODO(自定义ClassLoader1,从D:\lib下加载classx类文件,并自动解密)  
 * @author: Kevin.Yin  
 * @date: 2019年3月11日 下午3:35:28  
 */public class KevinClassLoader2 extends ClassLoader {  
      
    private String kevinLibPath;  
      
    public KevinClassLoader2(String path) {  
       kevinLibPath = path;  
    }  
  
    /**  
     * @Title: encClassFile* @Description: TODO(加密class文件)     
* @param srcPath  
     * @param destFilePath  
     * @throws IOException        
* @return: void        
     * @throws  
     */    public static void encClassFile(String srcPath,String destFilePath) throws IOException {  
       FileInputStream fin = new FileInputStream(srcPath);  
       FileOutputStream fout = new FileOutputStream(destFilePath);  
       int b = 0;  
       //加密,将原来的1改为0,0改为1  
       while ((b = fin.read()) != -1) {  
          fout.write(b ^ 0xff);  
       }  
       fin.close();  
       fout.close();  
    }  
      
    @Override  
    protected Class<?> findClass(String name) throws ClassNotFoundException {  
       String path = name.replace('.', '/').concat(".classx");  
       File file = new File(kevinLibPath, path);  
       System.out.println("加载:"+file.getAbsolutePath());  
       try {  
          // 读取二进制流  
          FileInputStream is = new FileInputStream(file);  
          ByteArrayOutputStream bos = new ByteArrayOutputStream();  
          int len = 0;  
          try {  
             while ((len = is.read()) != -1) {  
                bos.write(len ^ 0xff);  
             }  
          } catch (IOException e) {  
             e.printStackTrace();  
          }  
          byte[] data = bos.toByteArray();  
          is.close();  
          bos.close();  
          // 重要：将class字节码的二进制流，转换为Class对象  
          return defineClass(name, data, 0, data.length);  
       } catch (IOException e) {  
          e.printStackTrace();  
       }  
       //调用父类的findClass, 父类内部直接抛出ClassNotFoundException异常  
       return super.findClass(name);  
    }  
      
    // 第一步： 加密class文件为classx文件, 使用jd-gui等反编译工具无法反编译  
    public static void main(String[] args) throws Exception {  
       encClassFile("d:/lib/com/mimaxueyuan/jvm/aentity/Kevin2.class","d:/lib/com/mimaxueyuan/jvm/aentity/Kevin2.classx");  
    }  
      
    /* 第二步：加载classx类 */    /*public static void main(String[] args) {       KevinClassLoader2 diskLoader = new KevinClassLoader2("D:\\lib");       try {          //父加载器都加载不到,则使用当前加载器进行加载  
          Class clazz = diskLoader.loadClass("com.mimaxueyuan.jvm.aentity.Kevin2");          if (clazz != null) {             try {                // 初始化对象  
                Object obj = clazz.newInstance();                // 获取hello方法  
                Method method = clazz.getDeclaredMethod("hello", null);                // 通过反射调用hello方法  
                method.invoke(obj, null);             } catch (Exception e) {                e.printStackTrace();             }          }       } catch (ClassNotFoundException e) {          e.printStackTrace();       }    }*/}
```

## JAVA有哪几种默认的类加载器

[48、JDK1.8和1.9中类加载器有哪些不同](2、相关技术/3、JVM/Hollis/48、JDK1.8和1.9中类加载器有哪些不同.md)

## 为什么需要双亲委派模型

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类`java.lang.Object`，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

## loadClass和findClass

**`findClass`用于重写类加载逻辑**、**`loadClass`方法的逻辑里如果父类加载器加载失败则会调用自己的`findClass`方法完成加载**，保证了双亲委派规则。

1. 如果不想打破双亲委派模型，那么只需要重写`findClass`方法即可
2. 如果想打破双亲委派模型，那么就重写整个`loadClass`方法

对照：[43、破坏双亲委派之后，能重写String类吗？](2、相关技术/3、JVM/Hollis/43、破坏双亲委派之后，能重写String类吗？.md)

## 有哪些破坏双亲委派的例子

### 向前兼容

由于双亲委派模型是在JDK1.2之后才被引入的，而类加载器和抽象类java.lang.ClassLoader则是JDK1.0时候就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。

为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的proceted方法findClass()，在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。

JDK1.2之后已不再提倡用户再去覆盖loadClass()方法，应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派模型的。 

### SPI实现

双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢。 

这并非是不可能的事情，一个典型的例子便是JNDI服务，它的代码由启动类加载器去加载(在JDK1.3时放进rt.jar)，但JNDI的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现部部署在应用程序的classpath下的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能“认识”这些代码。

为了解决这个困境，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。

有了线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打坡了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。

Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。

### TOMCAT

一个web容器可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的，如果采用默认的类加载机制，那么就会无法加载多个相同的类。

Tomcat 为了实现隔离性，所以并没有完全遵守双亲委派的原则：
[8、Tomcat的类加载机制是怎么样的？](2、相关技术/3、JVM/Hollis/8、Tomcat的类加载机制是怎么样的？.md)
