参考：[补4_深入浅出JVM（十四）之内存溢出、泄漏与引用](2、相关技术/3、JVM/补4_深入浅出JVM（十四）之内存溢出、泄漏与引用.md)

对象存在引用关系就一定不会别回收吗？不一定，需要看该对象被那种类型引用。

在Java中，**强引用**、**软引用**、**弱引用**、**虚引用**是用于<font color="red" size=5>管理对象生命周期的不同类型的引用</font>。它们的主要作用是<font color="red" size=5>帮助垃圾回收器（GC）决定何时回收对象，从而更高效地管理内存。</font>

==**强***软***弱***虚*==，按照这个顺序，对象的**引用的强度越来越弱**。

# 强引用

强引用是Java的<font color="red" size=5>默认引用形式</font>，使用时不需要显示定义。如果一个对象具有强引用，那垃圾回收器绝不会回收它（可达时）。<font color="red" size=5><font color="blue" size=5>当内存空间不足</font>，Java虚拟机宁愿<font color="blue" size=5>抛出OutOfMemoryError错误</font>，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</font>
```java
String[] arr = new String[]{"a", "b", "c"};
```

## 案例

强引用是默认的引用方式，我们创建的new 一个对象，就是用的强引用，即如果引用一直在，就不会被 GC 回收掉。

在集合中， 如我们常见的`HashMap`使用的引用就是强引用，也就是说垃圾收集的时候，Map中引用的对象不会被GC掉。

# 软引用

软引用是一种相对较弱的引用类型，用于表示对对象的“非强”引用。

软引用是使用`SoftReference`来创建对象的方式，如`SoftReference<Object> softRef = new SoftReference<>(new Object());`就是软引用。

<font color="red" size=5><font color="blue" size=5>当内存不足时</font>，垃圾回收器会<font color="blue" size=5>优先回收软引用指向的对象</font>，以释放内存。软引用可以在系统<font color="blue" size=5>内存充足时保留对象</font>，以提高性能（缓存机制）。</font>
```java
SoftReference<String[]> softBean = new SoftReference<String[]>(new String[]{"a", "b", "c"});
```

## 案例

在 **`Guava Cache`** 中，有关于软引用的使用：
```java
class LocalCache<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
  static class SoftValueReference<K, V> extends SoftReference<V> implements ValueReference<K, V> {
      final ReferenceEntry<K, V> entry;
  
      SoftValueReference(ReferenceQueue<V> queue, V referent, ReferenceEntry<K, V> entry) {
          super(referent, queue);
          this.entry = entry;
      }
  }
}
```

`LocalCache` 类用到了 `SoftReference` 来实现软引用缓存。通过软引用，来方便在内存不足时能自动回收缓存对象，来避免 OOM 的发生。

# 弱引用

弱引用比软引用更弱。**被弱引用指向的对象只能存活到下一次垃圾回收之前**。弱引用是使用WeakReference来创建对象的方式，
```java
WeakReference<Object> weakRef = new WeakReference<>(new Object());
```

如果<font color="red" size=5>一个对象<font color="blue" size=5>只有弱引用指向</font>，即使系统<font color="blue" size=5>内存充足</font>，垃圾<font color="blue" size=5>回收时也会立即回收</font>它。</font>

## 案例

JDK中有一种基于弱引用类型实现的HashMap——WeakHashMap。
```java
public class WeakHashMap<K, V> extends AbstractMap<K, V> implements Map<K, V> {
  //省略部分方法和属性
  private static class Entry<K, V> extends WeakReference<Object> implements Map.Entry<K, V> {
        V value;
        final int hash;
        Entry<K, V> next;

        Entry(Object var1, V var2, ReferenceQueue<Object> var3, int var4, Entry<K, V> var5) {
            super(var1, var3);
            this.value = var2;
            this.hash = var4;
            this.next = var5;
        }
  }
}
```

这里面的 `Entry` 就是一种 `WeakReference` ，即弱引用，也就是说，当`WeakHashMap`中的 **key已经不再被使用的时候，Entry 因为是弱引用，那么就会被自动回收掉**。

另外，为了避免内存泄漏，在 ThreadLocal 中也用到了弱引用：
[58、ThreadLocal为什么会导致内存泄漏？如何解决的？](2、相关技术/2、JUC/Hollis/Java并发/58、ThreadLocal为什么会导致内存泄漏？如何解决的？.md)

# 虚引用

虚引用是最弱的一种引用。<font color="red" size=5>虚引用的存在不会影响对象的生命周期</font>，垃圾回收器在回收对象时不会考虑虚引用。虚引用是使用PhantomReference来创建对象的方式，
```java
PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), referenceQueue);
```

虚引用主要用于跟踪对象被回收的状态，并在对象被回收后进行一些后续处理（如清理本地资源等）。

虚引用通常与 `ReferenceQueue` 结合使用，管理清理逻辑。它在很多需要资源清理的场景中使用，比如文件句柄、数据库连接等。
```java
package com.mimaxueyuan.jvm.gc;  
  
import java.lang.ref.PhantomReference;  
import java.lang.ref.Reference;  
import java.lang.ref.ReferenceQueue;  
import java.util.LinkedList;  
import java.util.List;  
  
/**  
  * @ClassName: PhantomReferenceDemo  * @Description: TODO 虚引用： -verbose:gc -Xms4m -Xmx4m -Xmn2m  
  * @author Kevin.Yin  
  * @date 2019年5月2日 上午8:46:18  
  * */public class PhantomReferenceDemo {  
    private static final List<Object> TEST_DATA = new LinkedList<>();  
    private static final ReferenceQueue<TestClass> QUEUE = new ReferenceQueue<>();  
  
    public static void main(String[] args) {  
        TestClass obj = new TestClass("Kevin PhantomReference Test");  
        PhantomReference<TestClass> phantomReference = new PhantomReference<TestClass>(obj, QUEUE);  
  
        // 该线程不断往列表里插入数据，以促使系统早点进行GC  
        new Thread(() -> {  
            while (true) {  
                TEST_DATA.add(new byte[1024 * 100]);  
                try {  
                    Thread.sleep(1000);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                    Thread.currentThread().interrupt();  
                }  
                // 读取这个虚引用  
                System.out.println(phantomReference.get());  
            }  
        }).start();  
  
        // 这个线程不断读取引用队列，当弱引用指向的对象被回收时，该引用就会被加入到引用队列中  
        new Thread(() -> {  
            while (true) {  
                Reference<? extends TestClass> poll = QUEUE.poll();  
                if (poll != null) {  
                    System.out.println("--- 虚引用对象被jvm回收了 ---- " + poll);  
                    System.out.println("--- 回收对象 ---- " + poll.get());  
                }  
            }  
        }).start();  
  
        // 确保obj只有虚引用指向，而没有强引用指向它  
        obj = null;  
  
        try {  
            // 当前线程一直等待当前线程执行结束才继续执行——>死锁/永久阻塞  
            Thread.currentThread().join();  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
            System.exit(1);  
        }  
    }  
  
    static class TestClass {  
        private String name;  
  
        public TestClass(String name) {  
            this.name = name;  
        }  
  
        @Override  
        public String toString() {  
            return "TestClass - " + name;  
        }  
    }  
}
```

示例输出：
大概执行了20多次向链表中添加100K数据，内存就超过4M了，抛内存溢出
```shell
[GC (Allocation Failure)  1024K->636K(3584K), 0.0012448 secs]
[GC (Allocation Failure)  1657K->820K(3584K), 0.0028135 secs]
[GC (Allocation Failure)  1844K->940K(3584K), 0.0024683 secs]
[GC (Allocation Failure)  1964K->1188K(3584K), 0.0036716 secs]
--- 虚引用对象被jvm回收了 ---- java.lang.ref.PhantomReference@4475eb61
--- 回收对象 ---- null
null
null
null
[GC (Allocation Failure)  2126K->1708K(3584K), 0.0024351 secs]
null
null
null
null
null
null
null
null
null
null
[GC (Allocation Failure) -- 2713K->3550K(3584K), 0.0050151 secs]
[Full GC (Ergonomics)  3550K->1969K(3584K), 0.0265807 secs]
null
null
null
null
null
null
null
null
null
[Full GC (Ergonomics)  2900K->2867K(3584K), 0.0192448 secs]
null
[Full GC (Ergonomics)  2967K->2967K(3584K), 0.0145118 secs]
[Full GC (Allocation Failure)  2967K->2967K(3584K), 0.0143834 secs]
Exception in thread "Thread-0" java.lang.OutOfMemoryError: Java heap space
	at com.mimaxueyuan.jvm.gc.PhantomReferenceDemo.lambda$main$0(PhantomReferenceDemo.java:27)
	at com.mimaxueyuan.jvm.gc.PhantomReferenceDemo$$Lambda$1/1607521710.run(Unknown Source)
	at java.lang.Thread.run(Thread.java:748)

```

另一个示例：
```java 
import java.lang.ref.PhantomReference;  
import java.lang.ref.ReferenceQueue;  
import java.nio.ByteBuffer;  
  
public class PhantomReferenceExample {  
      
    // 定义一个简单的资源管理类  
    static class ResourceCleaner {  
        private final ReferenceQueue<ByteBuffer> queue;  
        private final PhantomReference<ByteBuffer> ref;  
          
        public ResourceCleaner(ByteBuffer buffer) {  
            // 创建一个 ReferenceQueue            this.queue = new ReferenceQueue<>();  
            // 创建一个虚引用并与 ReferenceQueue 关联  
            this.ref = new PhantomReference<>(buffer, queue);  
        }  
          
        public void cleanUp() {  
            // 在某个时间点调用清理方法  
            PhantomReference<ByteBuffer> polledRef = (PhantomReference<ByteBuffer>) queue.poll();  
            if (polledRef != null) {  
                // 进行资源释放操作  
                System.out.println("Cleaning up resources...");  
                // 释放与 ByteBuffer 相关的资源  
                // 在这里可以进行额外的清理工作，如关闭文件句柄等  
            }  
        }  
    }  
      
    public static void main(String[] args) throws InterruptedException  
    {  
        // 创建一个直接内存缓冲区  
        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);  
          
        // 创建 ResourceCleaner 并传入缓冲区  
        ResourceCleaner cleaner = new ResourceCleaner(buffer);  
          
        // 断开对缓冲区的强引用  
        buffer = null;  
          
        // 手动触发垃圾回收（为了示例，实际使用中不建议如此操作）  
        System.gc();  
          
        Thread.sleep(3000); // 等待垃圾回收完成（可选，仅为演示）  
        // 调用清理方法，检查是否有虚引用已被回收并进行清理  
        cleaner.cleanUp();  
    }  
}
```

# 对比

| 特性      | 强引用 | 软引用                                    | 弱引用   | 虚以用   |
| ------- | --- | -------------------------------------- | ----- | ----- |
| 生命周期    | 最长  | 次于强引用                                  | 次于软引用 | 次于弱引用 |
| OOM时被清理 | 否   | 是                                      | 是     | 是     |
| GC时被清理  | 否   | 否(手动调用System.gc()方法不会清理、因内存不足导致GC会被清理) | 是     | 是     |
1. <font color="red" size=5>软引用与弱引用的区别</font>在于：<font color="blue" size=5>软引用在内存充足时手动调用GC方法</font>（例如：System.gc()）**==只有软引用的对象==** <font color="blue" size=5>不会被清理</font>，只有在<font color="blue" size=5>内存不足时才会被清理</font>；而<font color="red" size=5>弱引用只要触发GC</font>，**==只有弱引用的对象==** <font color="red" size=5>就会被清理</font>。
2. <font color="red" size=5>弱引用与虚引用的区别</font>在于：<font color="blue" size=5>虚引用必须配合 ReferenceQueue，get方法返回结果为null</font>，常用于通知程序对象被清理
