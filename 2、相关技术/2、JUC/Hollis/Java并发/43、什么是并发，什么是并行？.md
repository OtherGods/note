# 典型回答

**并发**（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。

那么，操作系统是如何实现这种并发的呢？

现在我们用到操作系统，无论是Windows、Linux还是MacOS等其实都是**多用户多任务分时操作系统**。使用这些操作系统的用户是可以“同时”干多件事的。

但是实际上，对于单CPU的计算机来说，在CPU中，同一时间是只能干一件事儿的。为了看起来像是“同时干多件事”，分时操作系统是把CPU的时间划分成长短基本相同的时间区间,即”时间片”，通过操作系统的管理，把这些时间片依次轮流地分配给各个用户使用。

如果某个作业在时间片结束之前,整个任务还没有完成，那么该作业就被暂停下来,放弃CPU，等待下一轮循环再继续做.此时CPU又分配给另一个作业去使用。

由于计算机的处理速度很快，只要时间片的间隔取得适当,那么一个用户作业从用完分配给它的一个时间片到获得下一个CPU时间片，中间有所”停顿”，但用户察觉不出来,好像整个系统全由它”独占”似的。

所以，在单CPU的计算机中，我们看起来“同时干多件事”，其实是通过CPU时间片技术，并发完成的。

提到并发，还有另外一个词容易和他混淆，那就是并行。

## 并发与并行之间的关系

**并行**（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。

Erlang 之父 Joe Armstrong 用一张比较形象的图解释了并发与并行的区别：
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507062305250.png)

并发是两个队伍交替使用一台咖啡机。并行是两个队伍同时使用两台咖啡机。

映射到计算机系统中，上图中的咖啡机就是CPU，两个队伍指的就是两个进程。


## 多核机器上多线程并发和并行那个效率高？

- **吞吐量 = 单位时间内完成的任务数量 / 任务处理时间**
    - 例如：请求/秒 (QPS)、数据包/秒、帧/秒等。

哪种方式的吞吐量更高，主要<font color="red" size=5>取决于任务的性质</font>：
- **CPU密集型任务：**
    - **并行优势明显：** 如果一个任务可以完美地分解成多个独立的、纯粹计算的子任务（如图像渲染、科学计算、视频编码），那么将这些子任务分配到不同的线程，并让每个线程独占一个CPU核心运行（并行执行），可以充分利用多核的计算能力。
    - **理想情况下的线性提升：** 在无竞争、无阻塞的理想状态下，并行执行的吞吐量理论上可以接近核心数的线性增长。例如，4核上运行4个纯计算线程，吞吐量接近单线程的4倍。
    - **并发的局限：** 如果线程数远大于核心数（比如100个计算线程在4核上并发运行），操作系统需要频繁地进行线程切换。线程切换本身有开销（保存/恢复上下文、缓存失效），大量的时间会浪费在调度上，而不是执行实际计算任务，导致**吞吐量反而可能低于并行执行**，甚至低于核心数较少时的并行执行。
- **I/O密集型任务或混合型任务：**
    - **并发优势显现：** 如果任务涉及大量等待（如网络请求、磁盘读写、数据库查询、用户输入），线程在等待期间会被操作系统挂起（阻塞），此时CPU核心是空闲的。
    - **并发提高利用率：** 通过创建比核心数更多的线程（高并发），当一个线程因I/O阻塞时，操作系统可以立即切换到另一个就绪线程继续执行，**保持CPU核心的忙碌状态**，从而**提高系统的整体吞吐量**。例如，一个处理Web请求的服务，每个请求都需要访问数据库（有等待时间），使用多个线程（并发）可以显著提高每秒处理的请求数（吞吐量）。
    - **纯并行可能低效：** 如果只创建与核心数相等的线程（纯并行），当一个线程阻塞在I/O上时，它所占据的核心就空闲下来，无法处理其他请求，导致CPU资源浪费，吞吐量下降。

**结论：哪个吞吐量高？**
- **对于纯CPU密集型任务：** 在核心数足够的前提下，**线程数与核心数匹配的并行执行通常具有最高的吞吐量**。过多的线程（高并发）会导致调度开销过大，反而降低吞吐量。
- **对于I/O密集型或混合型任务：** **创建比核心数更多的线程（高并发）通常能带来更高的吞吐量**。因为它能更好地利用CPU在I/O等待期间的空闲时间。此时，线程数远大于核心数（高并发）是常态和高效的做法。
- **一般情况（混合型）：** 大多数实际应用是混合型的。最优的线程数（并发度）需要根据任务特性（CPU计算占比 vs. I/O等待占比）、核心数、内存带宽、锁竞争等因素进行测试和调优。目标是**最大化CPU核心的有效利用率**，同时**最小化线程调度和锁竞争带来的开销**。