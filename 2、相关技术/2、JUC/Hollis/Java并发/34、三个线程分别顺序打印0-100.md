
```java
Thread-0: 0
Thread-1: 1
Thread-2: 2
Thread-0: 3
Thread-1: 4
Thread-2: 5
....
Thread-1: 100
```

# 典型回答

这个问题主要考察多线程的线程安全和通信机制，常见的处理方式有notify/synchorized和condition/ reentrantlock。但是往往有同学只注意线程安全，而忽略了通信机制，常见的错误写法如下：
```java
public class Test {

private static int i = 1;

public static void main(String[] args) {
        for (int i = 0; i < 3; i++) {
            new Thread(new Print(i)).start();
        }
    }

    private static class Print implements Runnable {

        private final int index;

        public Print(int index) {
            this.index = index;
        }

        @Override
        public void run() {
            while(true) {
                synchronized (Print.class) {
                    if (i >= 101) {
                        return;
                    }
                    System.out.println("Thread-" + index + " " + i++);
                }
            }
        }
    }
}
```

这样写固然能通过锁来保证循环打印了1-100，但是却不能保证线程是按照顺序打印的，这个时候就需要用到线程的通信机制。

## Synchronized

我们可以结合`Sync和Object#notifyAll`来完成，如下所示
```java
public class print {  
    public static void main(String[] args) {  
        Object lock = new Object();  
        AtomicInteger index = new AtomicInteger(0);  
        SynRunnable synRunnable0 = new SynRunnable(lock, index, 100, 0, 3);  
        SynRunnable synRunnable1 = new SynRunnable(lock, index, 100, 1, 3);  
        SynRunnable synRunnable2 = new SynRunnable(lock, index, 100, 2, 3);  
        new Thread(synRunnable0, "thread0").start();  
        new Thread(synRunnable1, "thread1").start();  
        new Thread(synRunnable2, "thread2").start();  
    }  
}  
  
class SynRunnable implements Runnable {  
      
    // 多线程共享的锁对象  
    private Object lock;  
    // 多线程共享的当前值  
    private AtomicInteger countNum;  
    // 多线程共享的最大值  
    private int countMax;  
    // 多线程共享的索引值  
    private int countIndex;  
    // 多线程共享的容量值  
    private int countCapacity;  
      
    public SynRunnable(Object lock, AtomicInteger countNum, int countMax, int countIndex, int countCapacity) {  
        this.lock = lock;  
        this.countNum = countNum;  
        this.countMax = countMax;  
        this.countIndex = countIndex;  
        this.countCapacity = countCapacity;  
    }  
      
    @Override  
    public void run() {  
        synchronized (lock) {  
            while(countNum.get() < countMax) {  
                if(countNum.get() % countCapacity != countIndex) {  
                    try {  
                        lock.wait();  
                        continue;  
                    } catch (InterruptedException e) {  
                        throw new RuntimeException(e);  
                    }  
                }  
                System.out.println(Thread.currentThread().getName() + ",num=" + countIndex + ",maxNum=" + countNum);  
                countNum.addAndGet(1);  
                lock.notifyAll();  
            }  
        }  
    }  
}
```

## ReentrantLock

我们可以使用ReentrantLock和Condition尝试解决这种问题。大概的解决思路就是先通过lock对资源加锁，然后通过condition指定的唤醒下一个线程。相信大家都已经发现，这种方式比Synchronized的优点就是sync只能唤醒一个线程或者全部唤醒来让大家竞争，但是通过condition我们可以唤醒指定线程，避免资源浪费
```java
public class print {  
    public static void main(String[] args) {  
        ReentrantLock lock = new ReentrantLock();  
        Condition condition0 = lock.newCondition();  
        Condition condition1 = lock.newCondition();  
        Condition condition2 = lock.newCondition();  
        List<Condition> conditions = Arrays.asList(condition0, condition1, condition2);  
        AtomicInteger index = new AtomicInteger(0);  
        ReentrantRunnable reentrantRunnable0 = new ReentrantRunnable(lock, index, 100, 0, 3, conditions);  
        ReentrantRunnable reentrantRunnable1 = new ReentrantRunnable(lock, index, 100, 1, 3, conditions);  
        ReentrantRunnable reentrantRunnable2 = new ReentrantRunnable(lock, index, 100, 2, 3, conditions);  
        new Thread(reentrantRunnable0, "thread0").start();  
        new Thread(reentrantRunnable1, "thread1").start();  
        new Thread(reentrantRunnable2, "thread2").start();  
    }  
}  
  
class ReentrantRunnable implements Runnable {  
      
    // 多线程共享的锁对象  
    private ReentrantLock lock;  
    // 多线程共享的当前值  
    private AtomicInteger countNum;  
    // 多线程共享的最大值  
    private int countMax;  
    // 多线程共享的索引值  
    private int countIndex;  
    // 多线程共享的容量值  
    private int countCapacity;  
    // 多线程共享的条件队列  
    private List<Condition> conditions;  
      
    public ReentrantRunnable(ReentrantLock lock, AtomicInteger countNum, int countMax, int countIndex, int countCapacity, List<Condition> conditions) {  
        this.lock = lock;  
        this.countNum = countNum;  
        this.countMax = countMax;  
        this.countIndex = countIndex;  
        this.countCapacity = countCapacity;  
        this.conditions = conditions;  
    }  
      
    public void singalNext() {  
        int next = countNum.get();  
        if(next == countMax){  
            conditions.stream().forEach(Condition::signal);  
        }  
        int nextInex = next % countCapacity;  
        conditions.get(nextInex).signal();  
    }  
      
    @Override  
    public void run() {  
        lock.lock();  
        try {  
            while(countNum.get() < countMax) {  
                if(countNum.get() % countCapacity != countIndex) {  
                    try {  
                        conditions.get(countIndex).await();  
                        continue;  
                    } catch (InterruptedException e) {  
                        throw new RuntimeException(e);  
                    }  
                }  
                System.out.println(Thread.currentThread().getName() + ",num=" + countIndex + ",maxNum=" + countNum);  
                countNum.addAndGet(1);  
                singalNext();  
            }  
        } finally {  
            lock.unlock();  
        }  
    }  
}
```

## Thread#yield

除了线程之间的通信之外，我们还可以使用一种取巧的方式，就是通过指定线程打印某些值，如Thread0打印0,3,9等值。
核心思想是通过yield自旋的方式，如果当前的值不需要被当前线程打印，那么就让出该线程。如下所示：
```java
private static volatile int count = 0;
private static final int MAX = 100;
static class OtherWorker implements Runnable {

        private final int index;

        public OtherWorker(int index) {
            this.index = index;
        }

        @Override
        public void run() {
            while (count < MAX) {
                while (count % 3 != index) {
                    Thread.yield();
                }
                if (count > MAX) {
                    return;
                }
                System.out.println("Thread-" + index + " " + count);
                count++;
            }
        }
    }
```

这种方式需要线程不停的竞争和自旋，性能显然比不过前两种方法。同时，因为yield并不能保证立刻让出CPU，所以这种方法是有风险的

# 知识扩展

这种问题还有很多变种，如三个线程顺序打印ABC，三个线程按照要求顺序打印ABC等。
这些问题都是上线问题的变体，譬如把1-100换成ABC，常见的1-100转为ABC的代码转换如下所示：
```java
for (int i = 0; i < 100; i ++) { 
    char ascii = (char)(65 + i%3);
}
```


