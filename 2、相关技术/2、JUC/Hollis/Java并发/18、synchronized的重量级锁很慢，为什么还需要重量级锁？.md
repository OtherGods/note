#synchronized的为什么慢 
# 典型回答

[17、synchronized的锁升级过程是怎样的？](2、相关技术/2、JUC/Hollis/Java并发/17、synchronized的锁升级过程是怎样的？.md)

这里提到过synchronized的锁升级过程，其中介绍了偏向锁、轻量级锁以及重量级锁，同时我们也提到过，重量级锁是一种效率比较低的锁，所以很多人说他很慢，所以他叫"重量级锁"。但是既然慢，为啥还要用重量级锁呢？

其实，这个问题有点搞错了synchronized的偏向锁、轻量级锁，和重量级锁之间的目的和原理。synchronized本身是一个重量级锁，然后为了让他有些并发不高的情况下不要这么重才引入的偏向锁和轻量级锁。

为什么本身是一个重量级锁？先说说啥是所谓的重量级锁。

> 重量级锁是指在多线程竞争激烈的情况下，synchronized锁膨胀为一种系统级别的锁机制。与偏向锁和轻量级锁不同，重量级锁会阻塞线程，并会在加锁和解锁过程中频繁地与操作系统交互。

确实，**重量级锁相比轻量级锁和偏向锁更慢，原因是重量级锁会引入线程的阻塞与唤醒**。阻塞和唤醒一个线程需要CPU从用户态切换到内核态，这涉及操作系统的调度，开销较大。

也就是说，当多个线程竞争同一锁时，重量级锁会导致其他线程阻塞，所以他慢，但是其实这种阻塞是有必要的。因为并发抢锁的时候，只有阻塞才能保证了线程对共享资源的安全访问，能够避免数据竞争和不一致性问题。

而且，在非常激烈竞争的场景下，轻量级锁的自旋会导致CPU资源浪费，重量级锁通过阻塞来避免这些资源浪费。对于任务较重的操作，重量级锁能提高系统稳定性，避免性能因频繁自旋而下降。  

相信很多人看到这还是迷迷糊糊地，==举个例子==

*你去食堂买煎饼果子，就只有一个窗口在卖，你去了之后，发现有人在排队了，那你是不是得排队？*

*这不就是重量级锁么，就是大家都想买煎饼果子，但是窗口只有一个，那为了解决这种并发冲突，就只有排队了。*

*那么，如果你去的时候，你发现前面没人，那你就不用排队了，就直接买就行了，这不就是针对重量级锁的所谓优化么。*

也就是说，在并发比较高的时候，或者有激烈的所争抢的时候，必须要用重量级锁才行。（这里谈的是Java原生的关键字中，不考虑reentrantlock这种Java后来出来的类）

# synchronized重量级锁很重的原因

`synchronized` 被称为**重量级锁**，主要是因为它在某些场景下会**触发底层操作系统层面的“互斥量（mutex）”同步机制**，导致线程**阻塞 / 唤醒需要从用户态切换到内核态**，开销较大，影响性能。

## synchronized 为什么“重”？

### 原因 1：进入**阻塞状态的线程**需要操作系统调度

当多个线程竞争锁时，**不能获得锁的线程会阻塞（Block）**，这不是简单的挂起，而是：
- JVM 需要调用操作系统（OS）API，把线程挂起；
- 等锁释放后再由 OS 唤醒；
- 这就涉及了 **用户态 ↔ 内核态** 切换。

> 线程的挂起和唤醒是系统级操作，远远慢于用户态的自旋或无锁操作。

### 原因 2：早期 JVM 直接用“对象监视器”实现锁，效率低

`synchronized` 底层最早使用的是**ObjectMonitor（对象监视器）**机制，当锁被竞争时：
- 会将线程加入 `EntryList` 队列；
- 需要**等待被唤醒后再次尝试获取锁**；
- 频繁阻塞和唤醒开销大。

### 原因 3：锁存在膨胀过程，状态从轻量升级为重量

`synchronized` 在 JVM 中其实不是一开始就“重”的，它有以下几种状态（锁升级）：

|状态|说明|竞争情况|
|---|---|---|
|无锁|没有竞争|单线程执行|
|偏向锁|线程独占，标记偏向线程 ID|无竞争|
|轻量级锁|多线程尝试竞争，使用 CAS|有轻微竞争|
|**重量级锁**|多线程竞争失败，进入阻塞队列|激烈竞争|
- 当轻量级锁竞争失败时，就会升级为重量级锁，**使用操作系统互斥量**，性能最差。

## 举个场景：什么时候会重？

```java
public synchronized void method() {
    // do something
}
```

假设 5 个线程并发访问 `method()`，只有一个能进入，其它 4 个线程：
- 会被阻塞，挂起（操作系统层面）；
- 等到锁释放后唤醒重新竞争；
- 整个过程涉及线程上下文切换 + 阻塞队列操作。

这就是“重量级”的根源。

## 为什么现在说 synchronized 不慢了？

从 **JDK 1.6 起，JVM 对 synchronized 做了大量优化**：
- 引入偏向锁、轻量级锁
- 使用 CAS + 自旋优化
- 减少进入重量级锁的概率

所以在无竞争或轻微竞争下，synchronized 表现其实已经非常优秀。

## 总结

|原因|描述|
|---|---|
|阻塞线程需内核调度|用户态 ↔ 内核态切换，性能开销大|
|线程上下文切换|成本高于无锁或 CAS 逻辑|
|锁升级过程|竞争激烈时升级为重量级锁|
|ObjectMonitor机制|原始实现效率不高，锁竞争会等待|

如果你想了解 [synchronized锁升级全过程图解](https://chatgpt.com/c/f)，或 [轻量级锁 vs 重量级锁性能对比](https://chatgpt.com/c/f)，我可以继续补充。


