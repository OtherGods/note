# TransmittableThreadLocal 原理与源码分析

TransmittableThreadLocal（TTL）是阿里巴巴开源的用于解决异步执行时上下文传递问题的Java库。它是对`InheritableThreadLocal`的增强，特别适用于线程池等会复用线程的场景。

## 核心原理

TTL的核心原理是**捕获-重放**机制：
1. **捕获**：在任务提交到线程池时，捕获当前线程中的所有TTL值
2. **传递**：将这些值包裹在任务中一起传递
3. **重放**：在任务执行时，将捕获的TTL值重放到执行线程中
4. **恢复**：任务执行完成后，恢复执行线程原有的TTL值

## 源码分析

### 1. TransmittableThreadLocal 类

```java
public class TransmittableThreadLocal<T> extends InheritableThreadLocal<T> {
    // 保存所有注册的TTL实例
    private static InheritableThreadLocal<Map<TransmittableThreadLocal<?>, ?>> holder =
        new InheritableThreadLocal<Map<TransmittableThreadLocal<?>, ?>>() {
            @Override
            protected Map<TransmittableThreadLocal<?>, ?> initialValue() {
                return new WeakHashMap<>();
            }
            
            @Override
            protected Map<TransmittableThreadLocal<?>, ?> childValue(Map<TransmittableThreadLocal<?>, ?> parentValue) {
                return new WeakHashMap<>(parentValue);
            }
        };
    
    // 设置值时同时注册到holder中
    @Override
    public final void set(T value) {
        super.set(value);
        if (null == value) {
            removeValue();
        } else {
            addValue();
        }
    }
    
    private void addValue() {
        if (!holder.get().containsKey(this)) {
            holder.get().put(this, null);
        }
    }
}
```

### 2. 捕获与重放机制

关键类`Transmitter`实现了捕获-重放机制：

```java
public class Transmitter {
    // 捕获当前线程的所有TTL值
    public static Object capture() {
        Map<TransmittableThreadLocal<?>, Object> captured = new HashMap<>();
        Map<TransmittableThreadLocal<?>, ?> holder = TransmittableThreadLocal.holder.get();
        for (TransmittableThreadLocal<?> threadLocal : holder.keySet()) {
            captured.put(threadLocal, threadLocal.copyValue());
        }
        return captured;
    }
    
    // 重放捕获的TTL值到当前线程，并返回备份
    public static Object replay(Object captured) {
        @SuppressWarnings("unchecked")
        Map<TransmittableThreadLocal<?>, Object> capturedMap = (Map<TransmittableThreadLocal<?>, Object>) captured;
        Map<TransmittableThreadLocal<?>, Object> backup = new HashMap<>();
        
        // 备份当前值
        for (TransmittableThreadLocal<?> threadLocal : TransmittableThreadLocal.holder.get().keySet()) {
            backup.put(threadLocal, threadLocal.get());
        }
        
        // 清除所有现有值
        for (TransmittableThreadLocal<?> threadLocal : TransmittableThreadLocal.holder.get().keySet()) {
            threadLocal.superRemove();
        }
        
        // 设置捕获的值
        for (Map.Entry<TransmittableThreadLocal<?>, Object> entry : capturedMap.entrySet()) {
            @SuppressWarnings("unchecked")
            TransmittableThreadLocal<Object> threadLocal = (TransmittableThreadLocal<Object>) entry.getKey();
            threadLocal.set(entry.getValue());
        }
        
        // 注册所有捕获的TTL
        TransmittableThreadLocal.holder.get().putAll(capturedMap);
        
        return backup;
    }
    
    // 恢复备份的值
    public static void restore(Object backup) {
        @SuppressWarnings("unchecked")
        Map<TransmittableThreadLocal<?>, Object> backupMap = (Map<TransmittableThreadLocal<?>, Object>) backup;
        
        // 清除所有现有值
        for (TransmittableThreadLocal<?> threadLocal : TransmittableThreadLocal.holder.get().keySet()) {
            threadLocal.superRemove();
        }
        
        // 恢复备份的值
        for (Map.Entry<TransmittableThreadLocal<?>, Object> entry : backupMap.entrySet()) {
            @SuppressWarnings("unchecked")
            TransmittableThreadLocal<Object> threadLocal = (TransmittableThreadLocal<Object>) entry.getKey();
            threadLocal.set(entry.getValue());
        }
        
        // 注册所有备份的TTL
        TransmittableThreadLocal.holder.get().putAll(backupMap);
    }
}
```

### 3. 任务包装器

TTL通过包装Runnable和Callable来实现值的传递：

```java
public class TtlRunnable implements Runnable {
    private final Runnable runnable;
    private final Object captured;
    
    private TtlRunnable(Runnable runnable) {
        this.runnable = runnable;
        this.captured = Transmitter.capture(); // 捕获提交时的TTL值
    }
    
    @Override
    public void run() {
        Object backup = Transmitter.replay(captured); // 重放捕获的值
        try {
            runnable.run();
        } finally {
            Transmitter.restore(backup); // 恢复原来的值
        }
    }
    
    public static Runnable get(Runnable runnable) {
        if (null == runnable) return null;
        if (runnable instanceof TtlRunnable) return runnable;
        return new TtlRunnable(runnable);
    }
}
```

## 简练准确的结论

**TransmittableThreadLocal通过捕获-重放机制，在任务提交时捕获当前线程的上下文值，在任务执行时重放这些值到执行线程，并在执行完成后恢复原线程上下文，从而解决了线程池等异步场景下的上下文传递问题。**

TTL的核心优势：
1. 完整解决了线程池场景下的上下文传递问题
2. 支持值的拷贝和自定义传输逻辑
3. 通过包装器模式实现透明集成
4. 在执行完成后自动清理，避免内存泄漏