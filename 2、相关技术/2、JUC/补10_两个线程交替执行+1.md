## 1、存在线程安全问题的轮流+1

```java
public class Main
{
    private static Object obj = new Object();
    private static  int num = 0;
    
    public static void main(String[] args)
    {
        new Thread(new Runnable()
        {           // 匿名内部类
            @Override
            public void run()
            {
                while (num <= 1000)
                {
                    //偶数
                    if (num % 2 == 0)
                    {
                        System.out.println(Thread.currentThread().getName() + "===" + (num + 1));
                        num += 1;
                    }
                }
            }
        }, "thread1").start();
        
        new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                while (num <= 1000)
                {
                    //奇数
                    if (num % 2 != 0)
                    {
                        System.out.println(Thread.currentThread().getName() + "===" + (num + 1));
                        num+=1;
                    }
                }
            }
        }, "thread2").start();
    }
}
```

**<font color = "red">问题出现位置：</font>**这种方式的线程安全问题会出现在代码中两个if判断处；
**<font color = "red">问题：</font>**原因是共享变量num的可见性；
**<font color = "red">问题产生描述：</font>**当两个线程同时运行一段时间之后，num变为偶数234，线程1可以进入if条件，线程二不能进入if条件（因为num此时是偶数），当线程1执行完+1操作之后（num此时等于235），线程一再次不能进入if条件，因为此时num已经是基数，但线程二不能看到此时的num的值是235（可见性），导致线程二不能进入if，最后导致线程一和线程二都不能进入if，不能对num执行+1，不能满足大于1000退出循环，导致死循环。

## 2、sychronized

```java
public class Main
{
    private static Object obj = new Object();
    private static volatile int num = 0;
    public static void main(String[] args)
    {
        new Thread(new Runnable() {           // 匿名内部类
            @Override
            public void run() {
                synchronized (obj) {
                    while(num <= 1000){
                        if(num %2 == 0){
                            try
                            {
                                obj.wait();
                                if(num > 1000){
                                    continue;
                                }
                            } catch (InterruptedException e)
                            {
                                e.printStackTrace();
                            }
                        }
                        System.out.println(Thread.currentThread().getName() + "===" + (num += 1));
                        obj.notify();
                    }
                }
            }
        }, "thread1").start();
    
        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (obj) {
                    while(num <= 1000)
                    {
                        if(num %2 != 0){
                            try
                            {
                                obj.wait();
                                if(num > 1000){
                                    continue;
                                }
                            } catch (InterruptedException e)
                            {
                                e.printStackTrace();
                            }
                        }
                        System.out.println(Thread.currentThread().getName() + "===" + (num += 1));
                        obj.notify();
                    }
                }
            }
        }, "thread2").start();
    }
}
```

当一个线程开始运行后，如果不符合加一的条件，就wait，否则执行+1，并notify【通过锁同步，并通过wait和notify进行通信】。

## 3、volatile

```java
public class Main
{
    private static Object obj = new Object();
    private static volatile int num = 0;
    
    public static void main(String[] args)
    {
        new Thread(new Runnable()
        {           // 匿名内部类
            @Override
            public void run()
            {
                while (num <= 1000)
                {
                    if (num % 2 == 0)
                    {
                        System.out.println(Thread.currentThread().getName() + "===" + (num + 1));
                        num += 1;
                    }
                }
            }
        }, "thread1").start();
        
        new Thread(new Runnable()
        {
            @Override
            public void run()
            {
                while (num <= 1000)
                {
                    if (num % 2 != 0)
                    {
                        System.out.println(Thread.currentThread().getName() + "===" + (num + 1));
                        num+=1;
                    }
                }
            }
        }, "thread2").start();
    }
}
```

volatile关键字可以保证共享变量num可以在两个线程之间可见。

## 4、两个线程交替+1报错原因

两个线程分别+100次，因为i++操作不是原子操作，所以会出现i的最终结果在2到200之间的情况，分析如下：

**i++**  分为三步：①获取主内存中i的值、②对这个值进行加一操作、③将结果重新写回主内存的i中。

**B**线程在获取到i=0后被A打断（执行完①(或者执行完①②)，但是还未执行③），A在最后一次循环中，在即将获取i = 99的时候被B打断（准备执行①但还未执行），B成功给i赋值为1后（执行完③）被A打断(导致A本来要获取的99变成了1，也就是执行①)，A在将最后一次+1之前被B打断（②③尚未执行，此时A线程中的i = 1），B执行一百次加一完成并成功给i赋值为100（B线程执行完毕），A继续最后一次的循环，A在被打断之前i为1，现在执行+1和赋值，最终i=2。

| 线程A                                                        | 线程B                                                 |
| ------------------------------------------------------------ | ----------------------------------------------------- |
| i = 0;<br />i++;（循环99次）<br />i = 99;<br />最后一次循环中准备获取i时被打断 | i = 0;                                                |
|                                                              | i++;<br />i = 1;<br />执行完一次循环被打断            |
| 最后一次循环中获取i的值本来应该获取99，但是因为线程B将i的值修改为1，所以此时获取的i为1;<br />获取到i的值被打断 |                                                       |
|                                                              | i++;（再循环99次）<br />i = 100;<br />完成100次+1操作 |
| 最后一次循环中对i执行+1，并赋值给i，虽然线程B执行完给i赋值为99，但是线程A之前获取到的i为1，所以对1执行+1；<br />i = 2;<br />完成100次+1操作 |                                                       |

在上表中，出错的原因有两个：

1. i++操作不是原子操作
2. i的值不是线程可见的

这两个原因组合导致出错。