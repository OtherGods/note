# 典型回答

**Spring中Bean的创建过程其实可以分成两步，第一步叫做实例化，第二步叫做初始化。**

<font color="blue">实例化的过程只需要调用构造函数把对象创建出来并给他分配内存空间，而初始化则是给对象的属性进行赋值。</font>

<font color="red" size=5>循环依赖就是发生在Bean初始化最开始，实例化后赋值方法（AbstractAutowireCapableBeanFactory#populateBean）中【我的理解】</font>，可以参考[实例化Bean](4、Spring%20Bean的初始化过程是怎么样的？#实例化Bean)中方法`AbstractAutowireCapableBeanFactory:doCreateBean`

而Spring之所以可以解决循环依赖就是因为**对象的初始化是可以延后的**，也就是说，当我创建一个Bean ServiceA的时候，会先把这个对象实例化出来，然后再初始化其中的serviceB属性。
```java
@Service
public class ServiceA{

	@Autowired
	private ServiceB serviceB;

}


@Service
public class ServiceB{

	@Autowired
	private ServiceA serviceA;

}
```

而当一个对象**只进行了实例化，但是还没有进行初始化时，我们称之为半成品对象**。所以，所谓*半成品对象，其实只是 bean 对象的一个空壳子，还没有进行属性注入和初始化【**只实例化未初始化**】*。

当两个Bean在初始化过程中互相依赖的时候，如初始化A发现他依赖了B，继续去初始化B，发现他又依赖了A，那这时候怎么办呢？大致流程如下：
![1.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202506040958833.png)

通过以上方式，就通过引入三级缓存，解决了循环依赖的问题，在上述流程执行完之后，ServiceA和ServiceB都被成功的完成了实例化和初始化。

以下是`DefaultSingletonBeanRegistry#getSingleton`方法，代码中，包括一级缓存、二级缓存、三级缓存的处理逻辑，该方法是获取bean的单例实例对象的核心方法：
```java
@Nullable
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    // 首先从一级缓存中获取bean实例对象，如果已经存在，则直接返回
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        // 如果一级缓存中不存在bean实例对象，而且当前bean正在创建中，则从二级缓存中获取bean实例对象
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null && allowEarlyReference) {
            // 如果二级缓存中也不存在bean实例对象，并且允许提前引用，则需要在锁定一级缓存之前，
            // 先锁定二级缓存，然后再进行一系列处理
            synchronized (this.singletonObjects) {
                // 进行一系列安全检查后，再次从一级缓存和二级缓存中获取bean实例对象
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    singletonObject = this.earlySingletonObjects.get(beanName);
                    if (singletonObject == null) {
                        // 如果二级缓存中也不存在bean实例对象，则从三级缓存中获取bean的ObjectFactory，并创建bean实例对象
                        ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                        if (singletonFactory != null) {
                            singletonObject = singletonFactory.getObject();
                            // 将创建好的bean实例对象存储到二级缓存中
                            this.earlySingletonObjects.put(beanName, singletonObject);
                            // 从三级缓存中移除bean的ObjectFactory
                            this.singletonFactories.remove(beanName);
                        }
                    }
                }
            }
        }
    }
    return singletonObject;
}
```

# 扩展知识

[27、Spring解决循环依赖一定需要三级缓存吗？](2、相关技术/15、常用框架-SSM+SpringSecurity/Hollis/Spring/27、Spring解决循环依赖一定需要三级缓存吗？.md)

## 三级缓存解决循环依赖问题步骤：

1. 想要创建serviceA，先去一级缓存查看，一级缓存没有`serviceA`
2. 实例化 `serviceA`（`@Autowired serviceB`）【注入 `serviceB`（`@Autowired serviceA`）】
3. `serviceA` 尚未初始化完成（实例化 `serviceA` 之后，初始化 `serviceA` 之前），先将封装了 `serviceA` 的 `ObjectFactory` 放入 3级缓存
4. 初始化 `serviceA` ，向 `serviceA` 中注入 `serviceB` 时发现一级缓存没有 `serviceB`，准备实例化 `serviceB`
---
5. 一级缓存没有`serviceB`
6. 实例化 `serviceB`（`@Autowired serviceA`）【注入 `serviceA`（`@Autowired serviceB`）】
7. `serviceB` 尚未初始化完成（实例化 `serviceB` 之后，初始化 `serviceB` 之前），先将封装了 `serviceB` 的 `ObjectFactory` 放入 3级缓存
8. 初始化 `serviceB`，向 `serviceB` 注入 `serviceA` 时
	1. 先尝试从缓存拿 `serviceA`
		1. 1级没有 → 发现存在循环依赖（因为当前正在创建的单例Bean集合中存在字符串`serviceA` ——> 使用2、3级缓存） → 2级没有 → 3级 `ObjectFactory.getObject()`
			1. `AbstractAutoProxyCreator#getEarlyBeanReference` → `AbstractAutoProxyCreator#wrapIfNecessary` → 判断是否需要代理，需要的话通过SpringAOP（JDK动态代理、CGLIB代理），否则返回半对象
			2. 放入 2级缓存
		2. `serviceB` 注入的是代理的 `serviceA`  
	2. 继续初始化，执行`BeanPostProcessor` 中 `postProcessAfterInstantiation` 方法，如果 `serviceB` 需要代理，则在 `AbstractAutoProxyCreator#wrapIfNecessary` 中对 `serviceB` 代理后存放到一级缓存

9. `serviceB` 初始化完后，`serviceA` 继续初始化，将 `serviceB` 注入到 `serviceA` 中 ，`serviceA` 判断是否需要代理，最终放入一级缓存
