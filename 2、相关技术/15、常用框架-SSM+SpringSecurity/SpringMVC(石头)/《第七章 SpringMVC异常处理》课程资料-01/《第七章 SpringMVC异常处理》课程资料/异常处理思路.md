> 我们知道，系统中异常包括：编译时异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。在开发中，不管是dao层、service层还是controller层，都有可能抛出异常，在springmvc中，能将所有类型的异常处理从各处理过程解耦出来，既保证了相关处理过程的功能较单一，也实现了异常信息的统一处理和维护。

# 异常处理思路

> ![](media/image1.jpeg){width="5.908994969378828in" height="4.710521653543307in"}在springmvc中，异常处理的思路

如

> 上图所示，系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。明白了springmvc 中的异常处理机制，下面就开始分析springmvc中的异常处理。

# 异常处理结构体系

> Spring MVC通过**HandlerExceptionResolver**处理程序的异常,包括处理映射,数据绑定及处理器执行时发生异常。HandlerExceptionResolver仅有一个接口方法:

3.  \* handler mapping or execution, in the typical case to error views. Implementors are

4.  \* typically registered as beans in the application context. 5 \*

<!-- -->

6.  \* \<p\>Error views are analogous to JSP error pages but can be used with any kind of

7.  \* exception including any checked exception, with potentially fine-grained mappings for

8.  \* specific handlers. 9 \*

> 10 \* @author Juergen Hoeller 11 \* @since 22.11.2003
>
> 12 \*/
>
> 13 public interface HandlerExceptionResolver { 14
>
> 15 /\*\*

16. \* Try to resolve the given exception that got thrown during handler execution,

17. \* returning a {@link ModelAndView} that represents a specific error page if appropriate.

18. \* \<p\>The returned {@code ModelAndView} may be {@linkplain ModelAndView\#isEmpty() empty}

19. \* to indicate that the exception has been resolved successfully but that no view

20. \* should be rendered, for instance by setting a status code.

21. \* @param request current HTTP request

22. \* @param response current HTTP response

23. \* @param handler the executed handler, or {@code null} if none chosen at the

24. \* time of the exception (for example, if multipart resolution failed)

25. \* @param ex the exception that got thrown during handler execution

26. \* @return a corresponding {@code ModelAndView} to forward to, or {@code null}

27. \* for default processing

> 28 \*/

29. ModelAndView resolveException(

30. HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);

> 31
>
> 32 }
>
> 当发生异常时,Spring MVC将调用 resolveException()方法,并转到ModelAndView对应视图中,作为一个异常报告页面,反馈给用户! HandlerExceptionResolver拥有4个常见实现类:
>
> ![](media/image2.png){width="6.134641294838145in" height="1.582707786526684in"}

1.  # 异常处理方案

    1.  ## DefaultHandlerExceptionResolver

> ![](media/image3.jpeg){width="6.094600831146106in" height="2.3286450131233596in"}Spring MVC默认装配了DefaultHandlerExceptionResolver,它会将Spring MVC框架的异常转换为相应的相应状态码! 异常和相应状态码对应表
>
> 在web.xml响应状态码配置一个对应页面

## SimpleMappingExceptionResolver

> 如果希望对所有的异常进行统一的处理，比如当指定的异常发生时，把它映射到要显示的错误的网页中，此时用SimpleMappingExceptionResolver进行解析。DispatcherServlet中没有实现SimpleMappingExceptionResolver的Bean，所有需要在springmvc的配置文件中进行配置。
>
> 示例如下：
>
> 发送index.jsp中的超链接请求，控制器捕获请求后处理控制器逻辑，由于在逻辑中， 数组越界，会抛出ArrayIndexOutOfBoundsException异常。
>
> 处理异常
>
> 另外在/WEB-INF/jsp下新建一个error.jsp视图。因为上面配置的InternalResourceViewResolver视图解析器默认把error字符串解析为error.jsp视图。error.jsp内容为：
>
> 下面重新发送index.jsp中的超链接请求后，控制器截获请求并处理请求时，数组越界抛出一个ArrayIndexOutOfBoundsException一个异常，此时由SimpleMappingExceptionResolver异常解析！
>
> ![](media/image4.jpeg){width="6.1337543744531935in" height="2.310937226596675in"}

## AnnotationMethodHandlerExceptionResolver

> Spring MVC 默认注册了 AnnotationMethodHandlerExceptionResolver,它允许通过@ExceptionHandler注解指定处理特定异常的方法!

+----+-----+--------------------------------------------------+
| 6  |     | > System.out.println(\"\[出异常了\]:\" + ex);    |
+====+=====+==================================================+
| 7  |     | > ModelAndView mv = new ModelAndView(\"error\"); |
+----+-----+--------------------------------------------------+
| 8  |     | > mv.addObject(\"exception\", ex);               |
+----+-----+--------------------------------------------------+
| 9  |     | > return mv;                                     |
+----+-----+--------------------------------------------------+
| 10 | > } |                                                  |
+----+-----+--------------------------------------------------+
| 11 |     |                                                  |
+----+-----+--------------------------------------------------+

+------+---+---------------------------------------------------+
| > 14 |   | System.out.println(\"出异常了，算术异常:\" + ex); |
+======+===+===================================================+
| > 15 |   | ModelAndView mv = new ModelAndView(\"error\");    |
+------+---+---------------------------------------------------+
| > 16 |   | > mv.addObject(\"exception\", ex);                |
+------+---+---------------------------------------------------+
| > 17 |   | > return mv;                                      |
+------+---+---------------------------------------------------+
| > 18 |   | > }                                               |
+------+---+---------------------------------------------------+
| > 19 |   |                                                   |
+------+---+---------------------------------------------------+
| > 20 |   | > @RequestMapping(\"/testExceptionHandler1\")     |
+------+---+---------------------------------------------------+
| > 21 |   | > public String test1() {                         |
+------+---+---------------------------------------------------+
| > 22 |   | > String s=null;                                  |
+------+---+---------------------------------------------------+
| > 23 |   | > System.out.println(s.length());                 |
+------+---+---------------------------------------------------+
| > 24 |   | > return \"success\";                             |
+------+---+---------------------------------------------------+
| > 25 |   | > }                                               |
+------+---+---------------------------------------------------+
| > 26 |   |                                                   |
+------+---+---------------------------------------------------+
| > 27 |   | > @RequestMapping(\"/testExceptionHandler2\")     |
+------+---+---------------------------------------------------+
| > 28 |   | > public String test2() {                         |
+------+---+---------------------------------------------------+
| > 29 |   | > int i=100/0;                                    |
+------+---+---------------------------------------------------+
| > 30 |   | > return \"success\";                             |
+------+---+---------------------------------------------------+
| > 31 |   | > }                                               |
+------+---+---------------------------------------------------+
| > 32 | } |                                                   |
+------+---+---------------------------------------------------+

> 目标方法内抛出了一个ArithmeticException异常，将由继承关系最近的异常处理捕捉到，即由handleArithmeticException捕捉到。 若将handleArithmeticException方法注释掉，则发生ArithmeticException异常将由handleArithmeticException2进行处理。
>
> 缺点:
>
> 使用该注解有一个不好的地方就是：进行异常处理的方法必须与出错的方法在同一个Controller里面。
>
> 不能全局控制异常。每个类都要写一遍。

# 全局异常处理

> 上文说到 @ ExceptionHandler 需要进行异常处理的方法必须与出错的方法在同一个Controller里面。那么当代码加入了 @ControllerAdvice，则不需要必须在同一个controller 中了。这也是 Spring 3.2 带来的新特性。从名字上可以看出大体意思是控制器增强。 也就是说，@controlleradvice + @ ExceptionHandler 也可以实现全局的异常捕捉。 请确保此WebExceptionHandle 类能被扫描到并装载进 Spring 容器中。
>
> 此处可以捕捉全局异常,但是不要忘了在spring配置的时候扫描该类!
>
> 若在其他的由@Controller标记的Handler类中的Handle方法抛出异常，且没有在Handler类中定义@ExceptionHandler方法，则会去由@ControllerAdvice标记的类中去找，若也找不到，则在页面抛出异常。
