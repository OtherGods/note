# 学习背景

什么是nginx？

> 【百度百科】  
> Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器…

除了`反向代理`，nginx还支持`正向代理`、`负载均衡`以及基于SSL安全证书的`HTTPS`访问等功能特性~  
本文主要是介绍是`如何配置nginx正向代理、反向代理及负载均衡`，进入正文~

# 一、代理服务

**什么是代理？来一张图了解下**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/63d7c04ece5e4711a41ce42ec0aec644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
代理又分为`正向代理`和`反向代理`。

# 二、正向代理

## 1.1 什么是正向代理？

**先来看张图~**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/8caf69f16d5e44da9b432adc38eaea88.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)

**【再举个栗子】**

> 某同学喜欢`面向搜索引擎编程`，想通过 百度 搜索引擎查找一些学习资料，但是有些网站直接访问可能不太安全，会暴露自己的IP，同学比较苦恼，想着怎样才能使用百度 搜索自己想要的学习资料，又`不会暴露自己的IP`在网站上呢？  
> 这时我告诉该同学，我呢手上刚好有一台`代理服务器`，这台`代理服务器`通过nginx配置了正向代理转发`http`和`https`请求，你呢，只需要在自己的Windows本地电脑的网关配置一下这台代理服务器的IP和端口号，就能正常通过代理服务器访问到百度 并搜索相关的学习资料了，`还不会暴露自己真实的IP`~  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/a2eba1298211484fa0ba4472c3ad2616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)

同学非常兴奋，说自己了解过nginx，但是啥是正向代理啊？

> 正向代理，指的是通过`代理服务器` 代理`浏览器/客户端`去重定向请求访问到`目标服务器` 的一种代理服务。  
> 正向代理服务的特点是`代理服务器` <font color = 'red'>代理的对象是</font> `浏览器/客户端`，也就是对于`目标服务器` 来说`浏览器/客户端`是隐藏的。

同学觉得有点意思，于是又问，那nginx如何实现正向代理啊？

## 1.2 如何实现nginx正向代理？

**（1）正向代理转发https说明**

在实现nginx正向代理之前，先说明一下，现在的网站基本上都是`https`，因此要实现nginx正向代理转发请求，除了要配置转发`http80`端口的请求，还有配置`https443`端口的请求~  
正向代理转发`http`请求很简单，不过正向代理转发`https`请求稍微有一点麻烦，目前网上的教程大多都是如下这样配置的（也不知道他们验证过没。。。）：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/3fdbafa3a4ae4511877cc92dca935715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
一开始我也像上面那样配置，虽然`http`请求正常转发了，但是发现`https`并没有转成功，而是报错`HTTP/1.1 400 Bad Request`~  
后来才了解到，nginx官方并不支持直接转发`https`请求，但是阿里的一个大佬对nginx拓展了一个`ngx_http_proxy_connect_module`模块，并且在`github`上开源了 [https://github.com/chobits/ngx_http_proxy_connect_module](https://github.com/chobits/ngx_http_proxy_connect_module)  
不过维护的`ngx_http_proxy_connect_module`模块的补丁也是有nginx版本限制的（目前维护了`1.4.x~1.19.x`版本），如`README.md`说明：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/441cbacf45104f22b6606d0ea5d9d9f2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
如果你安装的nginx版本不在`1.4.x~1.19.x`这个范围内，那无法支持正向代理转发`https`请求。

**（2）安装nginx**  
如果已安装nginx（可跳过），这里以`1.9.2`版本为例，使用`root`用户进行安装：

```bash
$ cd /usr/nginx
$ wget http://nginx.org/download/nginx-1.9.2.tar.gz
$ tar -xzvf nginx-1.9.2.tar.gz
$ cd /usr/nginx/nginx-1.9.2
$ make && make install
```

这里安装nginx通过`install`进行编译安装，编译后默认安装目录为`/usr/local/nginx`，后续配置新模块`ngx_http_proxy_connect_module`还需要重新`install`编译一次~

**（3）下载新模块**  
GitHub上下载`ngx_http_proxy_connect_module`的`zip`压缩包源码：  
[https://github.com/chobits/ngx_http_proxy_connect_module](https://github.com/chobits/ngx_http_proxy_connect_module)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/0c6287f308fe4c7cbecc2311be59e2f4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)

**（4）解压新模块源码**  
将新模块`ngx_http_proxy_connect_module`源码压缩包上传到服务器`/usr/nginx`目录，并解压并重命名

```bash
$ mkdir -p /usr/nginx
$ cd /usr/nginx
$ /usr/nginx
$ unzip ngx_http_proxy_connect_module-master.zip
$ mv ngx_http_proxy_connect_module-master ngx_http_proxy_connect_module
```

**（5）添加新模块到nginx**  
使用`root`用户进入nginx的资源目录`/usr/nginx/nginx-1.9.2`，给nginx添加新模块`ngx_http_proxy_connect_module`和并重新编译`nginx`

```bash
$ /usr/nginx/nginx-1.9.2
$ patch -p1 < /usr/nginx/ngx_http_proxy_connect_module/patch/proxy_connect.patch
$ ./configure --add-module=/usr/nginx/ngx_http_proxy_connect_module
$ make && make install
```

**–说明：**  
这里`nginx-1.9.2`版本对应`proxy_connect.patch`补丁，其他版本相关补丁支持版本，详情见GitHub~ [https://github.com/chobits/ngx_http_proxy_connect_module](https://github.com/chobits/ngx_http_proxy_connect_module)

使用`root`用户安装和编译新模块完成后，如果你希望后续不使用`root`用户运维，可以授权安装目录`/usr/local/nginx`给`nginx`用户或者其他普通用户~

```bash
chown -R nginx:nginx /usr/local/nginx
chown root:root /usr/local/nginx/sbin/nginx
chmod +s /usr/local/nginx/sbin/nginx
```

**–说明：**  
二进制`/usr/local/nginx/sbin/nginx`文件需要重新归属为`root`用户，并且权限位添加`s`权限（权限位`+s`的二进制文件属于是管道文件，也就是普通用户也可执行该二进制文件，执行后产生的进程属于该文件的权限所有者，这里文件所有者是`root`）  
![在这里插入图片描述](https://img-blog.csdnimg.cn/a9ca712a48dc48ffb7f32f52e804ef03.png)

**（6）修改nginx的配置**  
修改nginx的配置分别添加`http`和`https`的`server`，其他配置保持不变~

```bash
vi /usr/local/nginx/conf/nginx.conf
```

这两个`server`主要配置是对`DNS解析`和`proxy_pass代理`进行：

```bash
#正向代理转发http请求
server {
    #指定DNS服务器IP地址 
    resolver 114.114.114.114;
    #监听80端口，http默认端口80
    listen 80;
    #服务器IP或域名
    server_name  localhost;
	
    #正向代理转发http请求
    location / {
        proxy_pass                 http://$host$request_uri;
        proxy_set_header           HOST $host;
        proxy_buffers              256 4k;
        proxy_max_temp_file_size   0k;
        proxy_connect_timeout      30;
        proxy_send_timeout         60;
        proxy_read_timeout         60;
        proxy_next_upstream error  timeout invalid_header http_502;
    }
}

#正向代理转发https请求
server {
    #指定DNS服务器IP地址 
    resolver 114.114.114.114;
    #监听443端口，https默认端口443
    listen 443;
	
    #正向代理转发https请求
    proxy_connect;
    proxy_connect_allow            443 563;
    proxy_connect_connect_timeout  10s;
    proxy_connect_read_timeout     10s;
    proxy_connect_send_timeout     10s;
    location / {
        proxy_pass http://$host;
        proxy_set_header Host $host;
    }
}
```

**– DNS说明：**  
（国内外）目前比较主流的DNS：  
（国外）谷歌：`8.8.8.8` developers.google.com  
（国外）OpenDNS：`208.67.222.222` signup.opendns.com  
（国内）114：`114.114.114.114` www.114dns.com  
（国内）腾讯：`119.29.29.29` www.dnspod.cn  
（国内）阿里：`223.5.5.5` alidns.com  
（国内）百度：`180.76.76.76` dudns.baidu.com

**（7）检查和刷新nginx配置**

```bash
/usr/local/nginx/sbin/nginx -t
/usr/local/nginx/sbin/nginx -s reload
```

## 1.3 客户端访问（验证正向代理）

客户端要代理访问目标网站示例对象：  
`http://www.baidu.com` 和`https://www.baidu.com`

**（1）客户端–Windows浏览器访问**  
**首先在本地电脑的IE浏览器设置代理服务器和端口**：  
IE->右上角 ->工具 ->Internet选项->连接->局域网（LAN）设置 ->配置代理IP和端口  
![在这里插入图片描述](https://img-blog.csdnimg.cn/b21488d7ea794c8fa4cb98723b594051.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
**浏览器访问**  
http://www.baidu.com/ 和https://www.baidu.com/  
![在这里插入图片描述](https://img-blog.csdnimg.cn/549dc529755a422080f0bc78fd8e998c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)

**实时查看nginx日志**

```bash
tail -f /usr/local/nginx/logs/access.log
```

通过实时查看nginx的访问日志，可以看到Windows下设置代理IP和端口后，本地电脑访问的所有网页会通过`代理服务器`进行访问网页，实现了正向代理的功能，并且`隐藏了用户自己真实的IP`~

**（2）客户端–Linux代理访问**  
Linux下也可以验证`代理服务器`是否能正常代理转发`http`和`https`请求~

```bash
curl http://www.baidu.com/ -v -x 127.0.0.1:80
curl https://www.baidu.com/ -v -x 127.0.0.1:443
```

nginx正向代理转发`https`成功：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/501eef914b384f92b3915d3da3df030e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)

# 二、反向代理

## 2.1 什么是反向代理？

**先来一张图了解下~**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/3f4c149e09344ed6ac04e6078936e11f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
相比于正向代理，反向代理的定义如下：

> 反向代理，指的是`浏览器/客户端`并不知道自己要访问具体哪台`目标服务器`，只知道去访问`代理服务器` ，`代理服务器`再通过`反向代理 +负载均衡`实现请求分发到`应用服务器`的一种代理服务。  
> 反向代理服务的特点是`代理服务器` 代理的对象是`应用服务器`，也就是对于`浏览器/客户端` 来说`应用服务器`是隐藏的。

## 2.2 nginx实现反向代理

**（1）修改nginx配置**  
修改nginx配置`vi /usr/local/nginx/conf/nginx.conf` 在`http`模块中配置如下：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/c10d40072e5e4ceca2f7eb87e1626e8d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
nginx反向代理都是结合负载均衡来实现的，这里先直接提供`反向代理+负载均衡`的配置，`负载均衡`后一章节介绍~

```bash
#反向代理+负载均衡
upstream reverseProxyServer{
    #负载均衡应用服务器A: 权重为10,10s内连接请求失败2次,nginx在10s内认为server是不可用的，将不在发送请求给这台服务器
    server 应用服务器A的IP:8080 weight=10 max_fails=2 fail_timeout=10s; 
    #负载均衡应用服务器B: 代理服务器权重为5,10s内连接请求失败2次,nginx在10s内认为server是不可用的，将不在发送请求给这台服务器
    server 应用服务器B的IP:8080 weight=5 fail_timeout=10s max_fails=2;
    #负载均衡应用服务器C: 代理服务器权重为5,10s内连接请求失败2次,nginx在10s内认为server是不可用的，将不在发送请求给这台服务器
    server 应用服务器C的IP:8080 weight=5 fail_timeout=10s max_fails=2;
}

server {
    #监听80端口，http默认端口80
    listen 80;
    #服务器IP或域名
    server_name  localhost;
    #反向代理请求路径中含有/appname的所有请求到upstream定义的对应反向代理模块
    location /appname {
        proxy_pass http://reverseProxyServer;
    }
}
```

**（2）检查和刷新nginx配置**

```bash
/usr/local/nginx/sbin/nginx -t
/usr/local/nginx/sbin/nginx -s reload
```

**（3）浏览器访问**  
代理服务器部署了tomcat应用，访问tomcat静态页面验证一波~  
`http://代理服务器IP:8080/appname/ReverseProxy1.html`  
![在这里插入图片描述](https://img-blog.csdnimg.cn/10c87548b0fe4c329f33fca424bb7bf7.png)

# 三、负载均衡

## 3.1 什么是负载均衡？

**再来看下前面介绍反向代理的这张图~**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/3f4c149e09344ed6ac04e6078936e11f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0p1c3RpblFpbg==,size_16,color_FFFFFF,t_70)  
可以看到`负载均衡（Load Balance）`的主要作用是采用了`负载均衡算法`将请求分发到`集群模式`中的`应用服务器`上，这样即使某个后台`应用服务器`挂了，其他`应用服务器`还可以正常接收请求，实现了`高可用`，并且集群模式模式下的应用服务器支持`纵向扩展`，可以应对业务快速增长带来的`高并发`应用场景~

## 3.2 负载均衡算法有哪些？

**`负载均衡算法`常用的有`轮询`、`权重`和`ip_hash`算法，默认是`轮询`算法~**

**（1）基于`轮询`的算法**  
原理是每一个请求按时间顺序逐一被分发到不同的应用服务器，如果接收请求的应用服务器挂了，并且请求超过最大失败次数`max_fails`（**1次**），则在失效时间`fail_timeout`（**10秒**）内不会再转发请求到该节点~

```bash
upstream defaultReverseProxyServer{
    server 192.168.0.1:8080; 
    server 192.168.0.2:8080; 
}
```

**（2）基于`权重`的算法**  
原理是每一个请求按权重被分发到不同的应用服务器，同样，如果接收请求的应用服务器挂了，并且请求超过最大失败次数`max_fails`（**默认1次或可设置N次**），则在失效时间`fail_timeout`（**默认10秒，可设置N秒**）内，不会再转发请求到该节点~

```bash
upstream weightReverseProxyServer{
    server 192.168.0.1:8080 weight=10 max_fails=2 fail_timeout=5s;
    server 192.168.0.2:8080 weight=5 max_fails=2 fail_timeout=5s;
}
```

**（3）基于`ip_hash`的算法**  
原理是每一个请求按用户访问IP的哈希结果分配，如果请求来自同一个用户IP则固定这台IP访问一台应用服务器，该算法可以有效解决动态网页中存在的session共享问题。

```bash
upstream ipHashReverseProxyServer{
    ip_hash;
    server 192.168.0.1:8080;
    server 192.168.0.2:8080;
}
```

一般使用的是基于`权重`的算法，因为现在很多情况下都是`集群部署`，而且集群下的各个服务器资源大多都是不均匀的，资源高的则分配权重高一些，资源低的则分配权重低一些，这种情况使用基于`权重`的负载均衡算法，可以更高效的利用资源和提高并发处理能力~


转载自：[https://bbs.huaweicloud.com/blogs/301714](https://bbs.huaweicloud.com/blogs/301714)
