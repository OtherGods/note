## 1、分析思路

### 1.1、步骤一

修改mysql配置文件，开启慢SQL、指定慢SQL存放位置、执行慢SQL阈值，通过慢查询日志去寻找哪些 SQL 执行效率低

### 1.2、步骤二

使用 explain 获取低效率 SQL 的执行计划，主要查看这几个字段：

1. key：查询优化器选择使用的索引，如果为NULL代表没有使用索引
2. type：表示查询时使用的索引的类型
   主要有以下几种：
   1. ALL：全表扫描， 将遍历全表来找到匹配的行。
   2. index：全索引扫描， 会遍历索引树来查找匹配的行
   3. range：范围扫描， 只会扫描索引树中的一个范围来查找匹配的行。
   4. ref：非唯一索引扫描， 只会扫描索引树中的一部分来查找匹配的行。
   5. eq_ref：唯一索引扫描，只会扫描索引树中的一个匹配行。
      1. explain select * from t1 join t2 on t1.id = t2.id where t1.f1 = 's';
      2. 当使用 WHERE 子句中的条件进行关联查询时，如果被关联的表的被关联列上存在唯一索引或主键，MySQL 就会选择使用 eq_ref 访问方式，将该表作为主表进行访问，而被关联的表作为辅助表，只需要访问一次即可。
   6. const：使用唯一性索引做等值查询
      1. explain select * from t2 where f='Hollis';
   7. system：系统表，少量数据，往往不需要进行磁盘IO
3. extra：其他额外信息，包括：
   1. Using where：表示 MySQL 将在存储引擎检索行后，再进行条件过滤（使用 WHERE 子句）；查询的列未被索引覆盖，where筛选条件非索引的前导列或者where筛选条件非索引列。
   2. Using index：表示 MySQL 使用了覆盖索引（也称为索引覆盖）优化，只需要扫描索引，而无需回到数据表中检索行；
   3. Using index condition：表示 MySQL 在使用索引进行查找时，无法使用覆盖索引优化，需要回到数据表中检索行；
   4. Using filesort：表示 MySQL 将使用文件排序而不是索引排序，这通常发生在无法使用索引来进行排序时；
   5. Using temporary：表示 MySQL 创建了临时表来存储查询结果。这通常是在排序或分组时发生的；
   6. ……
4. rows：表示此操作需要扫描的行数，即扫描表中多少行才能得到结果。



### 1.3、步骤三

结合 SQL 与执行计划，进行分析与优化，有两个方向

- 索引：判断是否需要建立索引、索引建立的是否合适、建立的所有是否用到

  - 是否需要建立索引

    - 表数据量太少不需要建立索引
    - 字段的区分度太小（count(distanct 字段名)/count(1)）不需要建立索引
    - 经常改动的字段不需要建立索引

  - 建立的索引是否合适

    - 多个单列索引可以合并为组合索引
    - 执行命令执行show index from tb_name，可以通过观察属性Cardinality来评估索引是否合理。Cardinality值非常关键，它表示索引中不重复记录数量的预估值。它是一个预估值，而不是一个准确的值，基本上我们不可能得到一个准确的值。它会估计索引中不重复记录，如果这个相对值很小，可能就要评估索引是否有意义。https://www.modb.pro/db/365312

  - 索引是否用到

    索引失效的几种情况：【通过执行计划explain查看关键列：key、type、extra、rows等】

    - where条件中使用的or关键字左右字段不是全加索引
    - 模糊匹配中%开头
    - 索引字段上执行算数运算、使用函数
    - 联合索引不满足最左匹配
    - 字符类型的字段上加索引，查找时字符串未加引号，导致隐式类型转换
    - 某些情况下 not in、not exists关键字

- 非索引：SQL语句优化（例如：不使用select *）、数据量（表太大可以分库分表、主从复制等）

  - SQL语句优化
    - limit 50000,10;可以配合where 带有索引的字段>50000;使用
    - 嵌套查询，外表小时用exists（该字段会先查询外表），内表小时用in（该字段会先查询内表）
    - 连接查询可以通过在从表中冗余主表的字段来避免连表
    - 不要使用 select *，去除不需要的字段查询
    - count(1) 比 count(*) 比count(列名)有效
    - 判断是否存在数据使用 exists 而非 count，count 用来获取数据行数
  - 数据量大
    - 单表数据过大，进行分库分表
    - 主从复制
    - 考虑使用非关系型数据库作缓存，提高查询效率
    - 全文索引场景较多，考虑使用 ElasticSearch、solr