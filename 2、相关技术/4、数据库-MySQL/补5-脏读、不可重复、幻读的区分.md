
# 1、不可重复和幻读的区分

## 1.1、代码随想录的八股文

> 1. 什么是幻读幻读?
>    是指在同⼀个事务中，存在前后两次查询同⼀个范围的数据，但是第二次查询却看到了第一次查询没看到的行。
>    注意，幻读出现的场景：
>    
>    1.  事务的隔离级别为可复读，且是当前读
>    2.  幻读仅专指新插入的行
>    
> 2. 幻读的产生：
>    行锁只能锁定存在的行，针对新插⼊的操作没有限定
>
> 3. 幻读带来的问题？
>    1. 对行锁语义的破坏
>    2. 破坏了数据⼀致性
>
> 4. 幻读的避免?
>    存储引擎采⽤加间隙锁的⽅式来避免出现幻读
>
> 5. 间隙锁是啥？它怎么避免出现幻读的？它引⼊了什么新的问题？
>    是专⻔⽤于解决幻读这种问题的锁，它锁的了⾏与⾏之间的间隙，能够阻塞新插⼊的操作 
>    间隙锁的引⼊也带来了⼀些新的问题，⽐如：降低并发度，可能导致死锁。
>    注意，读读不互斥，读写/写读/写写是互斥的，但是间隙锁之间是不冲突的，间隙锁会阻塞插⼊操作另外，间隙锁在可复读级别下才是有效的；
>
>    死锁：不同
>    
>    操控这个间隙，其他线程不能使⽤，加锁时不会检测是否冲突的，但是如果两个都给同 ⼀个间隙上锁，之后两个线程都没办法在这个间隙上更新数据了，都会陷⼊等待另⼀个线程的间隙锁释放，也就是死锁。
>    如果使⽤读提交隔离级别，那么只加⾏锁，不加间隙锁，语句执⾏过程中加上的⾏锁，在语句执⾏完成后，就要把 “不满⾜条件的⾏”上的⾏锁直接释放了，不需要等到事务提交才释放。



## 1.2、知乎

[https://www.zhihu.com/question/392569386/answer/1922737425](https://www.zhihu.com/question/392569386/answer/1922737425)

一个高赞的回复以及相应的评论：

> 作者：linganmm
> 链接：https://www.zhihu.com/question/392569386/answer/1434210648
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 正好在琢磨这个问题，也被搞得头昏脑涨，强答一下，不对之处请牛人指正。
>
> 脏读、不可重复读、幻读，网上介绍这几个概念的博文很多。天下博文一大抄，都没有说清楚不可重复读和[幻读](https://www.zhihu.com/search?q=幻读&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1434210648})的区别，只有一篇文章略微提到了一点，这里结合我的理解说一下。
>
> 其实这三种现象都是并发读写导致的。
>
> 1. “[脏读](https://www.zhihu.com/search?q=脏读&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1434210648})”指读到了<font color ="red">**未提交**</font>的数据，然后基于这个数据做了一些事情，结果做完发现数据被回滚了。可以理解为领导还没下达正式任务你就凭着自己的揣摩开始干活，结果活干完了，任务的内容被改了。
>
> 2. “不可重复读”好一点，读到的是<font color = "red">**已提交**</font>的数据，比如某个读事务持续时间比较长，期间多次读取某个元组，每次读到的都是被别人改过并已提交的不同数据。可以理解为在执行任务的过程中，领导的指令一直在变。。但好歹是正式下达的指令。
>
> 3. “幻读”是和不可重复读一样，都是读到<font color = "red">**已提交**</font>的数据指读的过程中，某些元组被增加~~或删除~~（作者这里说错了，只有增加），这样进行一些集合操作，比如算总数，平均值等等，就会每次算出不一样的数。
>
> 所以“不可重复读”和“幻读”都是读的过程中数据前后不一致，只是前者侧重于修改，后者侧重于增~~删~~。个人认为，严格来讲“幻读”可以被称为“不可重复读”的一种特殊情况，没错的。但是从数据库管理的角度来看二者是有区别的。解决“不可重复读”只要加行级锁就可以了。而解决“幻读”则需要加表级锁，或者采用其他更复杂的技术，总之代价要大许多。这是搞数据库的那帮家伙非要把这两者区分开的动机吧。
>
> 禁止写时读，避免了“脏读”，对应隔离级别read committed。
>
> 禁止读时写，避免了“不可重复读”，对应隔离级别repeatable read。
>
> 而为了避免“幻读”，干脆把整个表给锁住了，只能是[serialize](https://www.zhihu.com/search?q=serialize&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1434210648})了。
>
> 隔离级别越高，[并行度](https://www.zhihu.com/search?q=并行度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1434210648})越低，付出的代价越大。
>
> 顺便说一下，[phantom](https://www.zhihu.com/search?q=phantom&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1434210648})这个词是幻影，幽灵的意思，跟“幻读”的现象没有直接关系。很多文章说遇到“幻读”就像出现幻觉一样，个人以为十分牵强。“幻读”就是软件工程中一个很普通的问题，是人类思虑不周全的结果。老外工程师通过禁止读的时候修改解决了“不可重复读”的问题，本以为万事大吉了，谁知又出现了增加导致的不一致，不由感慨：我X真是个phantom。用中国话说，就是真TM见鬼了。国内翻译成了“幻读”，搞得很神秘，逼格很高的样子。
>
> > 一个看起来貌似很正确的评论：【点赞量高】
> > 删除应该不算幻读，幻读应该特指加入行。delete和update可以对记录加锁，保证事务安全。而insert，由于插入行不存在，无法加锁，只能引入间隙锁解决，这也是幻读单独拿出来的原因。


# 2、脏读、不可重复、幻读的区分

## 2.1、ChatGP：不可重复、幻读的区分

**幻读**和**不可重复读**都是MySQL数据库中在**可重复读**隔离级别下可能出现的现象，但两者之间存在着一些关键的区别。

### 2.1.1、幻读

**幻读**是指在一个事务中**多次读取**相同的数据，**但每次读取的结果**却**不一致**。这是因为在两次读取之间，另一个事务**插入**了新的数据，导致**查询结果集**发生了变化。

举个例子，假设有一个表名为`users`，其中包含一个名为`age`的列。事务A开始一个事务并查询`age`列，此时表中只有两条记录，分别为10和20。然后，事务B插入一条新的记录，`age`值为30。最后，事务A再次查询`age`列，此时却发现结果集变成了三条记录，分别是10、20和30。

在该示例中，事务A两次查询`age`列，但由于事务B在两次查询之间插入了一条新数据，导致两次查询的结果不一致，这就是**幻读**。

### 2.1.2、不可重复读

**不可重复读**是指在一个事务中**多次读取**相同的数据，**但每次读取的**数据**内容**发生了变化**。这是因为在两次读取之间，另一个事务**更新**了数据。

例如，假设有一个表名为`users`，其中包含一个名为`name`的列。事务A开始一个事务并查询`name`列，此时表中只有一条记录，值为`张三`。然后，事务B更新该记录，将`name`改为`李四`。最后，事务A再次查询`name`列，此时却发现该列的值变成了`李四`。

在该示例中，事务A两次查询`name`列，但由于事务B在两次查询之间更新了数据，导致两次查询的结果不一致，这就是**不可重复读**。

### 2.1.3、区别总结

|特征|幻读|不可重复读|
|---|---|---|
|发生条件|插入新数据|更新数据|
|数据变化|查询结果集数量发生变化|数据内容发生变化|
|事务行为|同一事务多次读取|同一事务多次读取|
|影响|导致查询结果不完整|导致查询结果不一致|

### 2.1.4、避免方法

- 提高事务隔离级别，例如使用**串行化**隔离级别。
- 在读取数据后尽快执行更新操作。
- 在应用程序中实现乐观锁。

## 2.2、ChatGP：脏读、不可重复的区分

脏读和不可重复读都是MySQL数据库在可重复读隔离级别下可能出现的现象，但两者之间存在着一些关键的区别：

### 2.2.1、脏读

**脏读**是指一个事务读取了另一个事务**未提交**的数据。由于未提交的数据可能被回滚，因此读取到的数据可能是不正确的。

举个例子，假设有两个事务：事务A和事务B。事务A开始一个事务并更新表 `users` 中的 `age` 列为 30，但并没有提交。然后，事务B读取表 `users` 中的 `age` 列，并看到值为 30。最后，事务A回滚了其更新操作。

在该场景中，事务B 读取到的事务 A 更新的数据是不正确的，因为该更新操作已经被回滚了。

### 2.2.2、不可重复读

**不可重复读**是指在一个事务中**多次读取**相同的数据，**但每次读取的**数据**内容**发生了变化**。这是因为在两次读取之间，另一个事务**更新**了数据。

例如，假设有一个表名为 `users`，其中包含一个名为 `name` 的列。事务 A 开始一个事务并查询 `name` 列，此时表中只有一条记录，值为 `张三`。然后，事务 B 更新该记录，将 `name` 改为 `李四`。最后，事务 A 再次查询 `name` 列，此时却发现该列的值变成了 `李四`。

在该示例中，事务 A 两次查询 `name` 列，但由于事务 B 在两次查询之间更新了数据，导致两次查询的结果不一致，这就是 **不可重复读**。

### 2.2.3、区别总结

|特征|脏读|不可重复读|
|---|---|---|
|发生条件|读取未提交数据|多次读取，数据被更新|
|数据变化|数据可能被回滚|数据内容发生变化|
|事务行为|跨事务|同一事务|
|影响|数据不正确|查询结果不一致|

### 2.2.4、避免方法

- 提高事务隔离级别，例如使用 **串行化** 隔离级别。
- 在读取数据后尽快执行更新操作。
- 在应用程序中实现乐观锁。

希望以上信息能够帮助您理解脏读和不可重复读的区别。
