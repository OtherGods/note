更多内容看《mysql思维导图.mmap》



# 0. 性能分析

MySQL常见瓶颈

- CPU:CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候
- IO:磁盘I/O瓶颈发生在装入数据远大于内存容量时
- 服务器硬件的性能瓶颈：top,free,iostat和vmstat来查看系统的性能状态

# 1.索引优化

使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈。

使用这个关键字可以直到

- 表的读取顺序——id属性
- 数据读取操作的操作类型——select_type属性
- 哪些索引可以使用——possible_keys属性
- 哪些索引被实际使用——keys属性
- 表之间的引用——ref属性
- 每张表有多少行被优化器查询——rows属性

## 1.1 explain属性介绍

- id    查询顺序标识，表示查询中执行select子句或操作表的顺序      如：mysql> explain select * from (select nid,name from tb1 where nid < 10) as B;      
  id值有三种情况：
  1. 如果id相同，那么从上到下按照顺序执行对应的sql语句；
  2. id不同，如果是子查询，id的序号会递增，id值越大的sql语句优先级越高，越先被执行；
  3. id相同和不同同时存在，分别遵循上面两中情况



- select_type    
  - 查询类型
    - SIMPLE     简单查询；
      查询中不包含子查询或者UNION
    - PRIMARY     最外层查询；
      查询中若包含任何复杂的字部份，最外层查询被标记为PRIMARY
    - SUBQUERY    映射为子查询      ；
      在select或where列表中包含的子查询
    - DERIVED     子查询；
      在FROM列表中包含的子查询被标记为DERIVED（衍生、临时表），MYSQL会递归执行这些子查询，把结果放在临时表中
    - UNION      联合；
      若第二个select包含在union之后，则被标记为union；
      若union包含在from子句的子查询中，外层select将被标记为derived
    - UNION RESULT  使用联合的结果；
      从union表获取结果的select
    - ...  
- table    正在访问的表名
  当table的值为derivedN（其中N是一个数字），代表的是一个衍生虚表（临时表），其中N是id的值，这里的N代表的是这个虚表是从哪个id对应的sql语句中衍生出来的



- type --> 根据 type 对应的值可以知道这条sql语句执行的效率    查询时的访问方式，性能：all < index < range < index_merge < ref_or_null < ref < eq_ref < system/const；
  type的值为NULL的时是一种极端。

  - ALL       全表扫描，对于数据表从头到尾找一遍
    select * from tb1;
    特别的：（接下来是对非索引字段查询的举例）如果有limit限制，则在表中找到之后就不再继续向下扫描
    select * from tb1 where email = 'seven@live.com';
    select * from tb1 where email = 'seven@live.com' limit 1;
    虽然上述两个语句都会进行全表扫描，但是第二句使用了limit，则找到一条记录后就不再继续扫描表，比不加limit节省时间。

  - INDEX      全索引扫描，对索引（索引文件）从头到尾找一遍
    select nid from tb1;
    INDEX 和 ALL的区别是select和from中间查找的是不只是索引列

  - RANGE（版本不同可能会有略微差距）
    对索引列进行范围查找
    select * from tb1 where name < 'alex'; 
    PS:                

    - between and                

    - in       

    - 小于、小于等于、大于、大于等于  操作 

      注意：!= 和 > 符号 ，如果在sql查询语句的条件中有这两个符号，即使是对索引列查找（这里where条件后面的 name < 'alex' 就是查找索引列name中值小于‘alex’的所有字段）也不会走索引，也就是说如果sql语句中有这两个符号，那么type的值就不是range，有特殊情况（在 5、正确使用索引中有对它们的补充）

      

  - INDEX_MERGE   合并索引，使用多个单列索引搜索
    select * from tb1 where name = 'alex' or nid in (11,22,33)；       --假设则这里用到的name列和nid列是索引列

    

  - REF       根据索引（是普通索引）查找一个或多个值
    select * from tb1 where name = 'seven'; -- 假设这里用到的name列是普通索引列

  - EQ_REF     连接时使用primary key 或 unique类型
    select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid;
    EQ_REF 和 REF 的区别是索引的类型

  - CONST      常量     --explain的sql语句中有覆盖索引的话type一般是这个
    表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。
    select nid from tb1 where nid = 2 ;

  - SYSTEM     系统              表仅有一行(=系统表)。这是const联接类型的一个特例。
    select * from (select nid from tb1 where nid = 1) as A;  

- possible_keys    可能使用的索引，一个或者多个；查询涉及到的字段上若存在索引，则将该索引列出来，但是不一定被查询实际使用

- key    真实使用的索引，如果为NULL，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中；

- key_len    MySQL中使用索引字节长度，索引中使用的字节数，可以通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好<u>*【也就是同样的查询结果的情况下该值越小越好，如果对于某个查询仅使用一个索引加以限制就能得到正确的、想要的结果，那么就不要使用大于等于两个以上的索引加以限制】*</u>；它显示的值为索引字段的最大可能长度，并非实际使用的长度，即key_len是根据表定义计算而得，不是通过表内检索出来的。

- ref    显示哪一  列/个  索引的被使用了。如果可能的话，是一个常数；那些列或常量被用于查找索引列上的值。

- rows    mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值

- extra    该列包含MySQL解决查询的详细信息，包含不适合在其他列中显示，但是十分重要的额外信息。
  下面标红的几种情况最好不要出现

  - “Using index”      此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。
    如果同时时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而并非执行查找动作
  - “Using where”      这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。    
  - <font color = "red">“Using temporary”      这意味着mysql在对查询结果排序时会使用一个临时表。    常见于order by和分组查询group by。</font>
  - <font color = "red">“Using filesort”      这意味着mysql会对结果数据使用一个外部索引排序，而不是按表内的索引次序从表里读取行。mysql中无法利用索引完成的排序称之为“文件排序”【也就是：sql语句中排序语句没有对应的字段上没有索引】。
    mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。    </font>
  - “Using join buffer”   意味着使用了连接缓存
  - “Range checked for each record(index map: N)”      这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。
  - ……

### 1.1.1 案例演示

![image-20220901114029351](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220901114029351.png)

![image-20220901113955292](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220901113955292.png)





## 1.2 索引分析

### 1.2.1 单表

```sql
CREATE TABLE IF NOT EXISTS `article`(
    `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `author_id` INT (10) UNSIGNED NOT NULL,
    `category_id` INT(10) UNSIGNED NOT NULL , 
    `views` INT(10) UNSIGNED NOT NULL , 
    `comments` INT(10) UNSIGNED NOT NULL,
    `title` VARBINARY(255) NOT NULL,
    `content` TEXT NOT NULL
);
INSERT INTO `article`(`author_id`,`category_id` ,`views` ,`comments` ,`title` ,`content` )VALUES
(1,1,1,1,'1','1'),
(2,2,2,2,'2','2'),
(3,3,3,3,'3','3');

SELECT * FROM ARTICLE;
```

表中没有建立索引（除了主键id）的情况下执行explain sql语句的结果
![image-20220902183811743](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902183811743.png)

可以看出表中type的值为All，是最坏的情况，Extra是Using filesort，也是最坏的情况。

**第一次优化**

对表中三个字段caragory_id、comment、views上建立组合索引；

![image-20220902200319763](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902200319763.png)

执行show index from 表名;查看表中建立的索引的情况
![image-20220902203646029](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902203646029.png)

下面这两条sql语句中只有在comments字段上的条件不同，但是第二条sql语句性能更好。
执行的情况如下：
![image-20220902184348988](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902184348988.png)

![image-20220902184447938](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902184447938.png)

对执行结果的分析：

![image-20220902181828391](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902181828391.png)



**第二次优化**

![image-20220902183207152](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902183207152.png)

![image-20220902183504686](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902183504686.png)

可以从上图中看出来type变为ref，Extar中的Using filesort也消失了。



### 1.2.2 两表

```java
CREATE TABLE IF NOT EXISTS `class`(
    `id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `card` INT (10) UNSIGNED NOT NULL
);
CREATE TABLE IF NOT EXISTS `book`(
    `bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
    `card` INT (10) UNSIGNED NOT NULL
);
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));

INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));
```

建好表之后执行explain

![image-20220902193404931](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902193404931.png)

**第一次优化**

在book表中对card列增加索引

![image-20220902193444267](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902193444267.png)

优化之后执行explain

![image-20220902193532864](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902193532864.png)

可以看到第二行的type变成了ref，rows的变化也比较明显，这是由于left join的特性决定的。left join条件用于决定如何从右表搜索行，左边一定都有，所以left join右边的表一定是关键点；如果把索引加在left join的左边，情况没有将索引加在left join的右边优化的明显。



**第二次优化**
删除第一次由于优化而创建的索引，在class表中对card列增加索引

![image-20220902193931737](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902193931737.png)

修改了表结构之后对同一条sql语句执行explain

![image-20220902194025113](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902194025113.png)

从这两次explain的对比中可以明显的看出来，在当使用lect join的时候应该给left join右表中，on条件中指定的列加索引。

右连接也是同样的思路。

### 1.2.3 三表

```sql
CREATE TABLE IF NOT EXISTS `phone`(
`phoneid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
`card` INT (10) UNSIGNED NOT NULL
)ENGINE = INNODB;

INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));
```

首先将1.2.2节中两张表中我们添加的索引去除掉，三表连接的时候要用到1.2.2中的两张表和1.2.3中的第三张表

如果单单使用单表连接的sql语句，则会发生全表扫描，如下：
![image-20220902210132614](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902210132614.png)

将sql语句中left join换成inner join之后的结果：
![image-20220902210702783](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902210702783.png)

这两次sql语句都会发生全表查询，并且在使用inner join的时候还会进行连接缓存；

**第一次优化**

按照1.2.2节中介绍过的内容，给left join的sql语句中两次left join右边的表分别建立索引：

![image-20220902210855764](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902210855764.png)

优化后执行语句的结果就不贴了，这里只是显示结果：
![image-20220902211046684](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902211046684.png)



## 1.2.4join语句的优化

1. 尽可能减少Join语句中的NestedLoop的循环总次数：“永远用小结果集驱动大的结果集”
2. 优先优化NestedLoop的内层循环
3. 保证Join语句中被驱动表上Join条件字段已经被索引；【驱动表的概念可以去看思维导图：《Mysql的七种常用连接查询.xmind》中的介绍】就像left join右侧的表在on条件中的字段就要加上索引
4. 当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer的设置。

## 1.3索引失效

应该避免索引失效

建表

```sql
CREATE TABLE staffs(
    id INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(24)NOT NULL DEFAULT'' COMMENT'姓名',
    `age` INT NOT NULL DEFAULT 0 COMMENT'年龄',
    `pos` VARCHAR(20) NOT NULL DEFAULT'' COMMENT'职位',
    `add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT'入职时间'
)CHARSET utf8 COMMENT'员工记录表';

INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('z3',22,'manager',NOW());
INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('July',23,'dev',NOW());
INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('2000',23,'dev',NOW());

-- 建立组合索引
ALTER TABLE staffs ADD INDEX index_staffs_nameAgePos(`name`,`age`,`pos`)
```

staffs表中索引的情况
![image-20220902213402679](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220902213402679.png)

### 1.3.1案例

下列列举出来的是常见的索引失效的原因

1. 全值匹配我最爱

2. 最佳左前缀法则
   如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<u>***带头大哥不能死，中间兄弟不能断***</u>。
   
   演示：
   按照第一、二条规则进行的查询：【在这种情况下会用到索引】
   
   ![image-20220903090540901](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903090540901.png)
   
   查询的条件中不使用组合索引的第一列：【在这种情况下不会用到索引】
   
   ![image-20220903090835592](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903090835592.png)
   
   查询的条件中只有组合索引的第一、三列：【只有第一列会被用到索引】
   ![image-20220903091524008](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903091524008.png)
   
   
   
   只要where条件中包含组合索引的全部列，即使这个列在where子句中是乱序的，也没有关系；即使在where子句中使用范围查找的时候也是同样的。（具体例子看1.3.2）
   
   
   
3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描

   演示：下面照片中的两个sql语句在没有expalin的情况下的执行结果是一致的，通过explain查询这两条语句的执行情况

   ![image-20220903092149886](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903092149886.png)

4. 存储引擎不能使用索引中范围条件右边的列，只要是范围条件那么就应该符合这条。
   演示：

   ![image-20220903092444199](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903092444199.png)

5. 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*
   演示：

   在查找时where后对索引的列没有使用范围查找的情况下，使用*进行查找和使用具体字段名进行查找的区别：

   ![image-20220903093336495](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903093336495.png)

   在查找时where后对有索引的列使用了范围查找的情况下，使用*进行查找和使用具体字段名进行查找的区别：【虽然sql中查询的字段不同，但是意思是相同的】

   ![image-20220903094210309](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903094210309.png)
   ![image-20220903094258366](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903094258366.png)

   只使用组合索引的一部分，但是符合最佳左前缀的情况下也尽量使用覆盖索引

   ![image-20220903095033464](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903095033464.png)

6. mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描
   演示：

   ![image-20220903095241821](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903095241821.png)

7. is null,is not null 也无法使用索引
   演示：
   ![image-20220903095402799](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903095402799.png)

8. like以通配符开头（'%abc...'）mysql索引失效会变成全表扫描操作【前提是没有使用覆盖索引，如果使用了覆盖索引，就索引就不会失效】
   演示：
   没有使用覆盖索引的情况：

   ![image-20220903101240408](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903101240408.png)

   使用覆盖索引的情况：

   ![image-20220903110229513](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903110229513.png)
   ![image-20220903110313929](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903110313929.png)

   当like后的查询条件不是以%开头的时候，会使用索引，并且type为range。

   ![image-20220903101305471](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903101305471.png)

   1. 问题：解决like '%字符串%' 索引不被使用的方法？？
      
      ```sql
      CREATE TABLE `tbl_user`(
          `id` INT(11) NOT NULL AUTO_INCREMENT,
          `name` VARCHAR(20) DEFAULT NULL,
          `age`INT(11) DEFAULT NULL,
          `email` VARCHAR(20) DEFAULT NULL,
          PRIMARY KEY(`id`)
      )ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
      
      INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('1aa1',21,'a@163.com');
      INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('2bb2',23,'b@163.com');
      INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('3cc3',24,'c@163.com');
      INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('4dd4',26,'d@163.com');
      ```
      
      在不建索引的时候在sql语句中使用  “%字段名%”  在表中的各个字段上查找都是全表扫描，现在给name和age字段建立索引
      
      ![image-20220903102439505](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903102439505.png)
      
      1. 可以使用主键索引
      2. 使用覆盖索引，查询字段必须是建立覆盖索引字段【推荐使用】
      3. 当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效

9. 字符串不加单引号索引失效（看第三条）
   staffs表中的name是varchar类型的，但是在第二条SQL语句的where条件中使用整数2000去判断，发生了自动类型转换：
   ![image-20220903111150175](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903111150175.png)

   执行explain查看：

   ![image-20220903111231211](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903111231211.png)
   可以看出来第二条SQL语句中没有用到索引。

10. 少用or,用它连接时会索引失效
    ![image-20220903111955418](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903111955418.png)
    虽然在name字段上加上了索引，但是在sql语句中使用了or导致索引失效。

    



### 1.3.2 对1.3.1中特殊情况的补充

```sql
create table test03(
    id int primary key not null auto_increment,
    c1 char(10),
    c2 char(10),
    c3 char(10),
    c4 char(10),
    c5 char(10));

insert into test03(c1,c2,c3,c4,c5) values ('a1','a2','a3','a4','a5');
insert into test03(c1,c2,c3,c4,c5) values ('b1','b2','b3','b4','b5');
insert into test03(c1,c2,c3,c4,c5) values ('c1','c2','c3','c4','c5');
insert into test03(c1,c2,c3,c4,c5) values ('d1','d2','d3','d4','d5');
insert into test03(c1,c2,c3,c4,c5) values ('e1','e2','e3','e4','e5');

create index idx_test03_c1234 on test03(c1,c2,c3,c4);
```

索引结构：
![image-20220903112558641](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903112558641.png)

#### SQL1

组合索引的列在where条件中的顺序不会使索引失效，即使在where子句中进行范围查找的时候也是同样![image-20220903112839686](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903112839686.png)

![image-20220903112926832](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903112926832.png)

![image-20220903114138904](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903114138904.png)

#### SQL2

组合索引中的某一列（下面使用的是组合索引中的c3字段）不在where子句中用于索引，而是在order by子句中用于排序**<u>*（当order by子句后的索引字段的名字的顺序  与  在定义索引时字段名字的顺序不一致的时候基本上都会在extra中有Using filesort）*</u>**![image-20220903114838438](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903114838438.png)

c4列在第一条SQL语句中不会被用于索引，并且在使用组合索引中的列c3进行排序的时候不会使用外部索引排序
![image-20220903114959814](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903114959814.png)

这里对c4字段排序，但是在where子句中没有c3，会在extra声明使用外部索引排序【中间兄弟断开了】
![image-20220903115504370](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903115504370.png)

对c2和c3进行排序，只有c1一个字段用于索引，c5字段索引会失效，没有filesort![image-20220903143906980](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903143906980.png)

和上一个SQL语句一致，只是order by的顺序发生了变化；在这条SQL语句中c1同样会走索引，但是c2和c3会走外部索引排序
![image-20220903144257730](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903144257730.png)



索引建立在c1、c2、c3、c4上面，而c5上面没有索引，所以下面这两条语句没有区别；c1和c2用于索引，c2、c3用于排序，无filesort。
![image-20220903144708634](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903144708634.png)



当order by子句中的带索引的字段的顺序排序和定义索引时索引字段的排序不一致，但是在where子句中使用了这个颠倒顺序的索引，就不会发生外部索引排序，看图理解
![image-20220903150244649](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903150244649.png)
视频中说，第一句SQL不会产生filesort的原因是因为：在第一条SQL中c1和c2是一个常量值（c1字段对应的值为a1，c2字段对应的值a2）



使用group by子句替换order by子句，发现group by子句和order by子句基本没有多大的差别，只是在使用group by的时候基本上都要排序，都会创建一张临时表。
![image-20220903150802101](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903150802101.png)



​	定值、范围还是排序，一般order by是给个范围
​	group by 基本上都需要进行排序，会有临时表产生

### 1.3.3小总结

 like KK%相当于=常量——>常量不对order by子句中

%KK和%KK% 相当于范围

![image-20220903154240576](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903154240576.png)

在上面这张照片中where子句中的条件但凡是 “=”、“ '以为非%开头的字符' %”这两种形式的都相当于常量；常量的概念在sql语句中有order by和group by子句时，对该sql子句执行explain的结果中extar的值是filestore的情况有优化的帮助。
例如：在照片中第一条where子句后面跟上order by b = “xx”; 并对这条SQL执行explain的时候，执行结果的extra中不会有Using filestore出现

示例：在1.3节的staffs表下执行下图sql可以看出来，组合索引(name,age,pos)在执行sql语句的时候，如果最左侧的字段都已经在where子句中被定义为常数的时候，即使在order by子句中不使用在where子句中使用的组合索引部分字段时也不会产生filestore；如果在order by子句中使用where子句中使用的组合索引部分字段时是乱序的，也不会产生filestore
![image-20220903181451535](D:\Tyora\AssociatedPicturesInTheArticles\补1-索引优化分析-来自B站\image-20220903181451535.png)

有关order by的优化去笔记《补2-查询截取分析-来自B站.md》中看

## 1.4 一般性建议

- 对于单键索引，尽量选择针对当前query过滤性更好的索引；
- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好；
- 在选择组合索引时，尽量选择可以能包含当前query中的where子句中更多字段的索引
- 尽可能通过分析统计信息和调整query的写法达到选择合适索引的目的

## 1.5优化总结口诀

全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写星；
不等空值还有or，索引失效要少用；
VARChar引号不可丢；