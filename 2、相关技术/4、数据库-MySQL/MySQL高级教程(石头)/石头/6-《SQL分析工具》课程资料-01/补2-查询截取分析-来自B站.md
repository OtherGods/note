# 1、查询优化（排序优化）	

## 1.1查询优化

永远小表驱动大表类似嵌套循环Nested Loop
![image-20220903162025195](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903162025195.png)

- EXISTS
  select … from table where exists (subquery);
  该语法可以理解为：将主查询的数据，放到子查询中作验证条件，根据验证结果（TURE / FALSE）来决定著查询的数据结果是否得以保留
- 提示
  1. EXISTS (sunquery)只返回TRUE或者FALSE，因此子查询中的select *也可以是select 1或 select 'X'，官方说法是实际执行时会忽略select清单，因此没有区别
  2. EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可以进行实际检验以确定是否有效率问题
  3. EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来代替，何种最优需要具体问题具体分析。

## 1.2 order by关键字优化

<font color = "red">另外一些内容去看笔记《补1-索引优化分析-来自B站.md》，因为那些内容和笔记《补1-索引优化分析-来自B站.md》分不开，所以只能在哪里存放一部分。</font>

解决执行explain之后extra中显示filestore的情况。

**ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序**

建表SQL

```sql
create table tblA(
    #id int primary key not null auto_increment,
    age int,
    birth timestamp not null
);

insert into tblA(age, birth) values(22, now());
insert into tblA(age, birth) values(23, now());
insert into tblA(age, birth) values(24, now());

create index idx_A_ageBirth on tblA(age, birth);

select * from tblA;
```

### 1.2.1 SQL1

当order by子句中的带有索引的字段的顺序和定义组合索引的时候每个字段的顺序一致的时候，不产生filestore![image-20220903170847609](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903170847609.png)

当order by子句中的带有索引的字段的顺序和定义组合索引的时候每个字段的顺序不一致的时候，会产生filestore【前提是乱序的字段中不包含常量】
![image-20220903171028007](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903171028007.png)
![image-20220903171506880](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903171506880.png)
这两条SQL语句是因为在where子句中age使用了范围查找，导致之后虽然使用brith，但是仍会产生filesorted；如果在where子句中age的条件不是范围查找，那么在order by子句中不会出现filestore：
![image-20220903172001323](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903172001323.png)


![image-20220903172225831](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903172225831.png)



### 1.2.2 介绍

MySQL支持两种方式的排序，FileSort和Index。Index效率高，它指MySQL扫描索引本身完成排序。FileSort方式效率较低。

ORDER BY满足两情况，会使用Index方式排序

1. ORDER BY语句使用索引最左前列
2. 使用where子句与Order By子句条件列组合满足索引最左前列

**尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀**

**如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序**

1. 双路排序

   MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输

   从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。

   取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。

2. 单路排序

   从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。

   结论及引申出的问题：由于单路是后出来的，总体而言好过双路，但是用单路有问题（一次没有将全部数据取出需要多访问几次）



**优化策略**
			增大sort_buffer_size参数的设置
			增大max_length_for_sort_data参数的设置

**小总结**
![image-20220903173915780](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903173915780.png)

![image-20220903174326667](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903174326667.png)



## 1.3 GROUP BY关键字优化

group by的优化几乎和order by的优化一致

1. groupby实质是先排序后进行分组，遵照索引建的最佳左前缀
2. 当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置
3. where高于having,能写在where限定的条件就不要去having限定了。



# 2、慢查询日志

看笔记《Mysql专题-SQL分析工具.md》中的内容

# 3、批量数据脚本

向表中插入1000W条数据

1. 建表

```sql
create table dept(
    id int unsigned primary key auto_increment,
    deptno mediumint unsigned not null default 0,
    dname varchar(20) not null default "",
    loc varchar(13) not null default ""
)engine=innodb default charset=GBK;

CREATE TABLE emp(
    id int unsigned primary key auto_increment,
    empno mediumint unsigned not null default 0,
    ename varchar(20) not null default "",
    job varchar(9) not null default "",
    mgr mediumint unsigned not null default 0,
    hiredate date not null,
    sal decimal(7,2) not null,
    comm decimal(7,2) not null,
    deptno mediumint unsigned not null default 0
)ENGINE=INNODB DEFAULT CHARSET=GBK;
```

2. 设置参数log_trust_function_createors
   由于在做大数据插入的时候，MySQL会报一个错，我们需要设置参数开启二进制日志功能

   创建函数，假如报错：This function has noone of DETERMINISTIC……；

   show variables like 'log_bin_trust_function_creators';

   首先执行上一行的sql语句查看Value对应的值，如果为OFF，那么需要执行以下语句开启：

   set global log_bin_trust_function_creators = 1;
   之后再次查询显示结果中Value为ON：
   ![image-20220903185822479](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903185822479.png)

   

   

   由于开启过慢查询日志，因为我们开启bin-log，我们就必须为我们的function指定一个参数

3. 创建函数保证每条数据都不同
   	随机产生字符串
      	随机产生部门编号

   ```sql
   //函数，修改sql语句结束符为$$
   delimiter $$
   create function rand_string(n int) returns varchar(255)
   begin
   declare chars_str varchar(100) default 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
   declare return_str varchar(255) default '';
   declare i int default 0;
   while i < n do
   set return_str = concat(return_str,substring(chars_str,floor(1+rand()*52),1));
   set i=i+1;
   end while;
   return return_str;
   end $$
   
   //函数，修改sql语句结束符为$$
   delimiter $$
   create function rand_num() returns int(5)
   begin
   declare i int default 0;
   set i=floor(100+rand()*10);
   return i;
   end $$
   ```

   

4. 创建存储过程
   	创建往emp表中插入数据的存储过程
      	创建往dept表中插入数据的存储过程

   ```sql
   //存储过程，修改sql语句结束符为$$
   delimiter $$ 
   create procedure insert_emp(in start int(10),in max_num int(10))
   begin
   declare i int default 0;
   #把自动提交设置为0，关闭自动提交
   set autocommit = 0;
   #循环
   repeat
   set i = i+1;
   
   #存储过程执行的内容是循环着向表中插入数据，其中会用到我们自定义的函数
   insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),ran_string(6),'salesman',0001,curdate(),2000,400,rand_num());
   #直到i的值等于参数中传递进来的最大值，就退出循环
   until i=max_num
   #结束循环
   end repeat;
   #手动提交
   commit;
   end $$
   
   //存储过程，修改sql语句结束符为$$
   delimiter $$ 
   create procedure insert_dept(in start int(10),in max_num int(10))
   begin
   declare i int default 0;
   #关闭自动提交
   set autocommit = 0;
   #循环
   repeat
   set i = i+1;
   
   #存储过程执行的任务是循环着向表中插入数据，其中会用到我们自定义的函数
   insert into dept(deptno,dname,loc) values((start+i),ran_string(10),ran_string(8));
   #直到i的值等于参数中传递进来的最大值才退出循环
   until i=max_num
   #结束循环
   end repeat;
   #手动提交
   commit;
   end $$
   ```

   

5. 调用存储过程
   首先将分隔符修改为sql语句默认的分号：delimiter ;

   CALL insert_emp(100,10);
   CALL insert_dept(100,10);

# 4、Show profiles

具体内容看笔记《Mysql专题-SQL分析工具.md》

1. 

# 5、全局查询日志

- 配置启用
  在Windows中是my.ini文件

  ![image-20220903195855344](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903195855344.png)

- 编码启用
  ![image-20220903195928772](D:\Tyora\AssociatedPicturesInTheArticles\补2-查询截取分析-来自B站\image-20220903195928772.png)

- 永远不要在生产环境开启这个功能，只在测试环境中用。