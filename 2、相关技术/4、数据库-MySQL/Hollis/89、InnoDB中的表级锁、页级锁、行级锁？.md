#锁 #MySQL锁种类 
# 典型回答

在数据库中，有各种各样的锁，按**锁的粒度**划分，可分为全局锁、表级锁、行级锁和页级锁。

在InnoDB中，有全局锁、表级锁、行级锁，但是是不支持页级锁的。

## 全局锁

全局锁，是一种影响整个MySQL实例的锁。

例如，`FLUSH TABLES WITH READ LOCK` 命令会锁定整个数据库实例的所有表，主要用于全局备份等操作。这个命令是全局读锁定，**执行了命令之后库实例中的所有表都被锁定为只读**。

## 表级锁

表级锁，顾名思义，就是对整个表加的锁。表级锁有以下几种：

### 意向锁

首先就是意向锁，当一个事务请求获取一个行级锁或表级锁时，MySQL会自动获取相应的表的意向锁。
[24、什么是意向锁？](2、相关技术/4、数据库-MySQL/Hollis/24、什么是意向锁？.md)

这种锁是MySQL自动加的，**不需要我们显示的加**。
当我们尝试向记录上**添加共享锁的时候**，就会**自动给这张表添加一个意向共享锁**。
当我们尝试向记录上**添加排他锁的时候**，就会**自动给这张表添加一个意向排他锁**。

### AUTO-INC锁

AUTO-INC 锁是一种特殊的表级锁，由插入带有 `AUTO_INCREMENT` 列的表的事务获取。在最简单的情况下，如果一个事务正在向表中插入值，任何其他事务都必须等待，以便执行它们自己的插入操作，这样第一个事务插入的行就会接收到连续的主键值。

### 字典锁

字典锁，英文名叫做MetaData Lock，也叫做MDL锁，它是一种用于管理元数据的锁机制，而不是数据本身的锁。

MDL锁用于控制对数据库对象的元数据的并发访问，<font color="red" size=5>数据库会在执行DDL（Data Defination Language）操作时加上字典锁</font>。**字典锁的主要目的是保护数据库中的元数据对象，如表、列、索引、视图等，以确保在DDL操作期间，不会出现数据一致性问题和竞争条件**。
[79、什么是MySQL的字典锁？](2、相关技术/4、数据库-MySQL/Hollis/79、什么是MySQL的字典锁？.md)

### 表级排他&共享锁

InnoDB中，一般我们会做的就是两种操作，即DDL和DML。

DML中。我们日常的对数据库表结构的SELECT、INSERT、UPDATE以及DELETE都不会添加表级别的共享锁及排他锁。而是使用默认的并发控制方式——行级锁。

那除了增删改查以外，还有一些其他的操作，比如ALTER、DROP等对表机构改变的动作，他们加锁的过程添加的是MDL锁，即字典锁。

所以，**InnoDB中的表级锁并不是没用，而是因为他划分的太细了，意向锁、AUTO-INC锁、字典锁等。而剩下的普通的排他锁和共享锁，确认很少才能用得上**。我找了很多资料，也没有明确的看到具体是啥时候，在《MySQL是怎样运行的》这本书中提到过一句：比如在崩溃恢复时。

当然，我们可以自己通过SQL语句来添加表级锁。可以使用 `LOCK TABLES` 手动添加表级锁，但这会阻塞其他所有访问该表的操作，直到执行 `UNLOCK TABLES` 。

`LOCK TABLES` 还可以分为排他和共享：

`LOCK TABLES table READ`：这就是添加表级别的共享锁
`LOCK TABLES table WRITE`：这就是添加表级别的排他锁

还有就是，**Innodb会在倾向于选择行级锁来进行并发控制**，但是如果<font color="red" size=5>在一些极端情况下， 比如说UPDATE操作需要<font color="blue">扫描整个表且对表中许多行进行更新</font>，InnoDB可能会评估行级锁的成本过高，而<font color="blue">采用更粗粒度的锁定策略</font>，比如表级锁</font>。然而，这种情况在InnoDB中是**非常罕见的**，因为InnoDB设计上是倾向于尽可能地使用行级锁。

# 扩展知识

## update时没有用到索引，加什么锁？

相信大家看到过的很多资料中都有过类似的描述“innodb 的 update语句中，如果where条件中没有索引，就不是行级锁了，而是锁表了，就是表级锁”。

我一直也都有这个印象，最开始是从哪看来的，也无从考究了，确实很长一段时间都是这么认为的。但是我发现并不对。

确实，mysql的行级锁锁的是索引，但是当**update语句的where条件中没有用到索引的话，他会做全表扫描，但是也不是全部都锁定。而是把符合条件的记录锁住；**

锁啥呢？**锁主键索引**。没有主键呢？**会自动创建隐式主键锁住**。

判断某表是否有表锁的sql：
```sql
-- 查看当前被锁定的表（表级锁）
SHOW OPEN TABLES WHERE In_use > 0

-- 给tableName表加表写锁和释放当前会话的表锁
LOCK TABLES tableName WRITE;
UNLOCK TABLES;
```

### 实际SQL分析：

表结构
```sql
sql
CREATE TABLE `user` (
  `id` int NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `age` int DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
```

user表内数据如下：

| id  | name  | age |
| --- | ----- | --- |
| 1   | Tom   | 24  |
| 2   | Jerry | 25  |
| 3   | Bob   | 26  |

事务A：
```sql
BEGIN;
UPDATE user SET name = 'Alice' WHERE age = 25;
-- 实际是全表扫描，遍历 id=1,2,3
-- 只有 id=2 满足条件，于是加 X 锁
```

事务B：
```sql
BEGIN;
UPDATE user SET name = 'Alice' WHERE age = 24;
-- 也是全表扫描，遍历 id=1,2,3
-- 当它扫描到 id=2 时，虽然 age != 24，不满足条件
-- 但它必须“读”这行判断 age 是不是 24
-- 而此时该行正被事务A加了排他锁，还未提交
-- 所以事务B会被阻塞在“读这行”的动作上
```

- **事务A并会对 id=2(索引) 加锁,因为它的 WHERE age=25**，但是不会对`id=1`和`id=3`加锁，只是 *==【当前读】这两条记录，会阻塞其他事务中对`id=2`和`id=3`的记录操作==*
- **事务B在更新时并不会对 id=2 加锁，因为它的 WHERE age  <> 24**，但是 *==update是【当前读】，在【当前读】时 `写-写`、`读-写` 相互阻塞==*
	- 事务B需要读取 id=2 的记录字段（比如判断 age 是否等于24）。
	- 这个“读取”是**当前读**（UPDATE 是当前读语义，不是快照读）。
	- 当前读需要读到最新版本，但该行正被事务A持有排他锁修改中，还未提交。
	- 所以事务B会被**阻塞在“读”这行**，等待事务A释放锁。

!!!注意：**阻塞不是因为要加锁，而是因为读冲突**，这点很多人会误解。

**UPDATE 是当前读操作**，不像 SELECT 那样是快照读。
> 所谓当前读（Current Read）：读取的是记录的**最新版本**，为了保证数据一致性，如果这行正在被修改，则**必须等待锁释放才能读取**。

UPDATE 语句在**判断 WHERE 条件是否满足前，不会给记录加锁**！

锁是在 WHERE 条件**满足**之后，MySQL 才加上对应记录锁（X 锁）。

事务B SQL执行过程如下：
- 没有 age 索引 → 全表扫描；
- 扫描每一行，例如扫描到 id=2；
- 判断这行是否满足 `age = 24`，必须读取该行的最新值 → 是 **当前读**；
- **读取时不会加锁**（不满足 WHERE，InnoDB 不加锁）；
- 但如果该行 **正在被另一个事务持有 X 锁（修改中）**，就需要等待其提交才能读；
- 所以虽然不加锁，也会被 **阻塞** → **被动等待它的锁释放**。

#### 总结

<font color="red" size=5>在 UPDATE 语句中，即使是“当前读”，只要该行不满足 WHERE 条件，就不会加锁；但读取过程仍可能因为其他事务持有锁而阻塞。</font>
