# 典型回答

## 共享锁

**共享锁又称读锁，是读取操作创建的锁**。<font color="red" size=5>其他用户可以并发读取数据，但<font color="blue">任何事务都不能对数据进行修改</font></font>（获取数据上的排他锁），直到已释放所有共享锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。**获得共享锁的事务只能读数据，不能修改数据**。
```sql
select …… lock in share mode;
```

在查询语句后面增加 `LOCK IN SHARE MODE` ，MySQL会对查询结果中的每行都加共享锁，**被加了共享锁的记录还可以被其他事务成功申请共享锁，但是不能被申请排他锁**。

## 排他锁

**排他锁又称写锁**，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任何类型的锁。**获得排他锁的事务既能读数据，又能修改数据**。
```sql
SELECT ... FOR UPDATE;
```

在查询语句后面增加FOR UPDATE，MySQL会对查询命中的每条记录都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。

## 注意

<font color="red" size=5>注意区分<font color="blue" size=5>普通select读</font>和<font color="blue" size=5>共享锁读</font></font>
- 普通`select`**==不加锁==**，读取快照，不会与其它事务阻塞
	- 所以事务1执行`update …… where id = 1`时，事务2执行`select * from t where id = 1`不会阻塞
- **==明确使用共享锁才会和写锁互斥阻塞==**
	- 所以事务1执行`update …… where id = 1`时，事务2执行`select * from t where id = 1 in share mode`会阻塞

## 总结

当这一行数据<font color="red" size=5>获取了排他锁</font>，那么其他事务就<font color="red" size=5>不能在对这一行数据添加共享锁或者排他锁</font>。
当这一行数据<font color="red" size=5>获取了共享锁</font>，那么其他事务依然<font color="red" size=5>可以对这一行数据添加共享锁，但不能添加排他锁</font>
