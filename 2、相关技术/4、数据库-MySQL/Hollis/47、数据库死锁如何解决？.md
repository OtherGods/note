# 典型回答

数据库死锁问题是指在多个并发事务中，彼此之间出现了相互等待的情况，导致所有事务都无法继续执行，称为死锁。

关于死锁的概念：
[12、什么是死锁，如何解决？](2、相关技术/2、JUC/Hollis/Java并发/12、什么是死锁，如何解决？.md)

数据库的死锁的发生通常由以下原因导致：
1. **资源竞争**：多个事务试图同时访问相同的资源，如数据库表、行、页或锁。但是它们请求资源的顺序不同，导致互相等待。
2. **未释放资源**：事务在使用完资源后未及时释放资源，导致其他事务无法获得所需的资源。这可能是由于程序中的错误或异常情况引起的。
3. **不同事务的执行速度不同**：如果一个事务在获取资源后执行速度很慢，而其他事务需要等待该事务释放资源，那么可能会导致其他事务超时，从而发生死锁。
4. **操作的数据量过大**：在持有锁的同时，又请求获取更多的锁，导致互相等待。


<font color="red" size=5>如果发生了死锁，如何解决:</font>
1. 大部分现代数据库管理系统在**检测到死锁时会自动干预**。它们通常选择<font color="red" size=5>回滚一个或多个事务来打破死锁</font>。
2. 除了自动干预外，很多 DBMS 也支持**手动强制回滚某些事务**来解决死锁。比如 navicat 解决死锁的办法：[47.1、navicat mysql 死锁造成拥堵（批量kill掉进程方法）](2、相关技术/4、数据库-MySQL/Hollis/47.1、navicat%20mysql%20死锁造成拥堵（批量kill掉进程方法）.md)
3. 还有就是如果你什么都不做，MySQL 自己也可以解决死锁，一种是立刻解决，一种是延迟解决。
	- 如果MySQL开启了死锁检测（`innodb_deadlock_detect = on`），那么他会定时的检测死锁，在检测到死锁后，MySQL将自动选择并终止事务中的一个或多个事务来解决死锁。
	- 如果设置事务等待锁的超时时间（`innodb_lock_wait_timeout`）。当一个事务的等待获取锁的时长超过这个阈值的时候，会对这个事务进行回滚，这样也能解决死锁。

**避免死锁**的方法有：
1. **减少锁的数量**：比如<font color="red" size=5>使用RC来代替RR</font>来避免因为gap锁和next-key锁而带来的死锁情况。
2. **减少锁的时长**：<font color="red" size=5>加快事务的执行速度，降低执行时间</font>，也能减少死锁发生的概率。
3. **固定顺序访问数据**：事务在访问同一张表时，应该以相同的顺序获取锁，这样可以避免死锁的发生。
4. **减少操作的数据量**：尽量减少事务操作的数据量，尽量减少事务的持有时间，这样可以降低死锁的发生几率。

[2、数据库死锁问题排查过程](10、线上问题排查/Hollis/2、数据库死锁问题排查过程.md)
