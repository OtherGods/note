#主从复制过程 #异步复制 #同步复制 #半同步复制 

# 典型回答

[11、InnoDB的一次更新事务过程是怎么样的？](2、相关技术/4、数据库-MySQL/Hollis/11、InnoDB的一次更新事务过程是怎么样的？.md)

看本文之前，请先了解一下binlog、redolog等，知道他们的作用及写入过程。

看到这里默认大家了解以上背景了，那么，正文开始：

MySQL的主从复制，是基于binlog实现的，主要过程是这样的：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507191642933.png)

1. **从服务器在开启主从复制**后，会创建出两个线程：I/O线程和SQL线程
	- **从服务器的I/O线程，会尝试和主服务器建立连接**，相对应的，主服务中也有一个**binlog dump线程， 是专门来和从服务器的I/O线程**做交互的。
	- 从服务器的I/O线程会告诉主服务的dump线程自己要**从什么位置开始接收binlog**
2. **主服务器**在更新过程中，**将更改记录保存到自己的binlog中**，根据不同的binlog格式，记录的内容可能不一样。
3. 在**dump线程检测到binlog变化时，会从指定位置开始读取内容**，然后会被slave的I/O线程把他拉取过去。
	- 这里需要注意，有些资料上面说这里是主服务器向从服务器推的，但是，实际上是从服务器向主服务器拉的（[https://dev.mysql.com/doc/refman/8.0/en/replication-implementation.html](https://dev.mysql.com/doc/refman/8.0/en/replication-implementation.html)）
> 	  *==拉的模式，从库可以自行管理同步进度和处理延迟==*。
4. 从服务器的**I/O线程接收到通知事件**后，会**把内容保存在relay log中**。
5. 从服务器还有一个**SQL线程**，他会不断地**读取他自己的relay log中的内容，把他解析成具体的操作，然后写入**到自己的数据表中。

# 扩展知识

## 复制方式

MySQL目前支持多种复制方式，其中包括了**全同步复制、异步复制和半同步复制**。
- **异步复制**：这是**MySQL默认的复制方式**，在**异步复制的方式中==主库在执行完事务操作以后，会立刻给客户端返回==**。他不需要关心从库是否完成该事务的执行。
  
  这种方式会导致一个问题，那就是当主库出现故障时，主库虽然事务执行完了，但是可能还没来得及把数据同步给从库，就挂了。那么当从库升级为主库之后，他会丢失了这次事务的变更内容。
  
- **全同步复制**：全同步复制的这个方式中，当 **==主库执行完一个事务之后，会*等待所有的从库完成数据复制之后，才会给客户端反馈*==**。
  
  这种方式安全性可以保障了，但是性能很差。如果从库比较多的话，会导致整个过程更加长。

- **半同步复制**：半同步复制是介于全同步复制和异步复制之间的一种方案。他在执行完一个事务之后，也不会立刻给客户端反馈，但是也不会等所有从库都完成事务，而是 **==主服务器*等其中一个从库完成接收到事件*之后，再反馈给客户端==**。
  
  在半同步复制这个方案中，会在事务提交的2阶段都完成之后，等待从库接收到binlog，然后再返回成功。
  [11、InnoDB的一次更新事务过程是怎么样的？](2、相关技术/4、数据库-MySQL/Hollis/11、InnoDB的一次更新事务过程是怎么样的？.md)
  
  在上面这篇中我们画过的一张图，如果把半同步复制的过程也加进去，那么就会变成：
  ![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507191719428.png)

## 主从延迟

[70、什么是数据库的主从延迟，如何解决？](2、相关技术/4、数据库-MySQL/Hollis/70、什么是数据库的主从延迟，如何解决？.md)

## 并行复制

[67、MySQL的并行复制原理](2、相关技术/4、数据库-MySQL/Hollis/67、MySQL的并行复制原理.md)
