# 典型回答

MySQL的Innodb引擎中，支持多种锁级别，包括了**行级锁**和**表级锁**。当多个事务想要访问一个共享资源的时候，如果每个事务都直接请求获取锁，那么就可能会导致互相阻塞，甚至导致死锁。

举个例子：
> 事务A对表Table1中的一行加上了行级锁，这时候这行记录就不能写了。事务B申请对Table1增加了表级锁，如果他申请成功了，那么他就可以修改表中的任意一行记录。这就发生了冲突。
> 
> 那么，想要解决这个问题，就**需要让事务B在对Table1增加表级锁的时候，先判断一下是不是有事务增加过行级锁**。但是，事务B总不能遍历表中数据逐条判断是否有加锁吧？

所以，为了解决这个问题，MySQL引入了意向锁机制。**所以，意向锁是数据库管理系统中用于实现锁协议的一种锁机制，旨在处理不同锁粒度（如行锁和表锁）之间的并发性问题**。（相同锁粒度（如多个行级锁）之间的并发性问题通过行级互斥锁解决。）

> 注意：
> 1. <font color="red" size=5>意向锁并<font color="blue" size=5>不是直接锁定资源</font>，而是为了通知其他事务，以<font color="blue" size=5>防止它们在资源上设置不兼容的锁</font></font>。
> 2. **意向锁并不是直接由用户请求的**，而是由 MySQL 管理的。

<font color="red" size=5><font color="blue" size=5>当一个事务请求获取一个行级锁或表级锁时，MySQL会自动获取相应的表的意向锁</font>。这样，其他事务<font color="blue" size=5>请求获取表锁时，就可以先基于这个意向锁来发现是否有人加过锁</font>，并根据该锁的类型（意向共享锁/意向排他锁）来判断自己是否可以获取锁。这样可以在不阻塞其他事务的情况下，为当前事务锁定资源。</font>

意向锁有两种类型：意向共享锁和意向排他锁。
1. **意向共享锁**： 表示事务打算在资源上设置共享锁（读锁）。这通常用于表示事务计划读取资源，**并不希望在读取时有其他事务设置排它锁**。
2. **意向排它锁**： 表示事务打算在资源上设置排它锁（写锁）。这表示事务计划修改资源，**并不希望有其他事务同时设置共享或排它锁**。

**意向锁是一个表级锁，并且他会在触发意向锁的事务提交或者回滚后释放。**

意向锁其实是一个表级锁！

以下是MySQL官网上给出的这几种锁之间的冲突关系：
![image.png](https://raw.githubusercontent.com/OtherGods/MaterialImage/main/img/202507191143735.png)

