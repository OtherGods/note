**<u>*这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对八股文总结。*</u>**

计算机网络八股文来自：

1. 图解网络-小林coding

# 1、HTTP常见面试题

1. HTTP基本知识
2. GET与POST
3. HTTP特性
4. HTTPS与HTTP
5. HTTP 1.1、HTTP 2、HTTP 3演化

![image-20221004104533792](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004104533792.png)



## 1.1 HTTP基本知识

**HTTP常见状态码：**
![image-20221004105052679](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004105052679.png)

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 1xxx   | 属于提示信息，是协议处理中的一种中间状态码，实际使用的比较少 |
| 2xxx   | 表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态   |
| 200    | 表示一切正常，如果是非HEAD请求，服务器返回的响应头都会有body数据 |
| 204    | 常见的成功状态码，与200基本相同，响应头没有body数据          |
| 206    | 应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态 |
| 3xxx   | 表示客户端请求的资源发送了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向 |
| 301    | 永久重定向，说明请求的资源已经不存在了，需要改用新的URL再次访问 |
| 302    | 临时重定向概念股，说明请求的资源还在，但需要暂时用另一个URL来访问 |
|        | 301和302都会在我响应头中使用字段Location，指明后续要跳转的URL，了浏览器会自动重定向新的URL |
| 304    | 不具有跳转的含义，表示资源未被修改，重定向已经存在的传冲文件，也称为重定向，用于缓存控制 |
| 4xxx   | 类状态码表示客户端发送的报文有误，服务器也无法处理，也就是错误码的含义 |
| 400    | 表示客户端请求的报文有误，但只是个有笼统的错误               |
| 403    | 表示服务器禁止访问该资源，并不是客户端的请求出错             |
| 404    | 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端 |
| 5xxx   | 类状态码表示客户端请求报文正确，但是服务处理时内部出现了错误，属于服务器端的错误码 |
| 500    | 与400类似，是个笼统通用的错误码，服务器发生了什么故障，我们并不知道 |
| 501    | 表示客户端请求的功能展示不支持，类似于即将开业，敬请期待的意思 |
| 502    | 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，然后访问服务器发生了错误 |
| 503    | 当前服务器很忙，在那时无法响应客户端                         |



**Host常见字段：**

1. Host字段：客户端发送请求时，用来指定服务器的域名
   ![image-20221004111541846](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004111541846.png)

1. Content-Length字段：**服务器**返回数据时，表明本次回应的数据长度
2. Connection字段：值为Keep-Alive，最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用
   ![image-20221004111425265](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004111425265.png)

1. Content-Type字段：用于**服务器**回应时，告诉客户端，本次数据是什么格式
2. Accept字段：客户端请求的时候，可以使用Accept字段声明自己可以接受那些数据格式
   ![image-20221004111358999](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004111358999.png)

1. Content-Encoding字段：说明数据的压缩方法，表示**服务器**返回的数据使用了什么压缩格式
2. Accept-Encoding字段：客户端在请求时，用这个字段说明自己可以接受那些压缩方法
   ![image-20221004111335728](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004111335728.png)

## 1.2 GET与POST

GET和POST方法都是安全和幂等的吗？

先说一下幂等的概念：

1. 在HTTP协议里，所谓的[安全]是请求方法不会[破坏]服务器上的资源
2. 所谓的[幂等]，意思是多次执行相同的操作，结果都是[相同]的

所以GET方法是安全且幂等的，因为他是[只读]操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

POST因为是[新增或提交数据]的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。

## 1.3 HTTP特性

特性：

1. 简单
2. 灵活和易于扩展
3. 应用广泛和跨平台

缺点：

1. 无状态双刃剑
2. 明问传输双刃剑
3. 不安全

**HTTP 1.1性能？**

HTTP 协议是基于  TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥。

1. 长连接早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是 
   串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。
   为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 
   TCP 连接的复建⽴和断开所造成的额外开销，减轻了服务器端的负载。
   持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。
   ![image-20221004112745915](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004112745915.png)
2. 管道网络传输
   HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。
   即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。
   举例来说，客户端需要请求两个资源。以前的做法是，在同⼀个TCP连接⾥⾯，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和B 请求。
   ![image-20221004112844321](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004112844321.png)
   但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。要是前面的回应特别慢，后面就会有许多请求排队等着，这称之为[队头阻塞]
3. 对头阻塞
   「请求 - 应答」的模式加剧了 HTTP 的性能问题。
   因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是「队头阻塞」。好⽐上班的路上塞⻋。
   ![image-20221004113020969](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004113020969.png)

## 1.4 HTTP与HTTPS

### 1.4.1 HTTP 与 HTTPS 有哪些区别？

1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。
2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS的握⼿过程，才可进⼊加密报⽂传输。
3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### 1.4.2 HTTPS解决了HTTP的哪些问题

1. 窃听风险：比如通信链路上可以获取通信内容，用户号容易没
2. 篡改风险：比如强制植入垃圾广告，视觉污染
3. 冒充风险：比如冒充淘宝网站

![image-20221004113322039](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004113322039.png)

HTTPS在HTTP与TCP层之间加入了SSL/TSL协议，可以很好的解决上述的风险：

1. 信息加密：交互信息无法被窃取
2. 校验机制：无法篡改通信内容，篡改了之后就不能正常显示
3. 身份证书：证明淘宝是我真的淘宝

### 1.4.3 HTTPS是如何解决上述三个风险的？

1. 混合加密的方式实现信息的机密性，解决了窃听风险

   ![image-20221004113712744](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004113712744.png)
   HTTPS采用的是对称加密和非对称加密结合的[混合加密]方式

   1. 在通信前建立非堆成加密的方式交换[会话密钥]，后续就不再使用非对称加密
   2. 在通信过程中全部使用对称加密的[会话密钥]的方式加密明文数据

   采用[混合加密]方式的原因：

   1. 对称加密只使用一个密钥，运算速度较快，密钥必须保密，无法做到安全的密钥交换
   2. 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢

2. 摘要算法的方式来实现完整性，它能够为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了篡改的风险
   ![image-20221004114231120](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004114231120.png)
   客户端在发送明文之前会通过摘要算法算出明文的[指纹]，发送的时候会把[指纹+明文]以同加密成密文后，发送给服务端，服务端解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的[指纹]和当前算出来的[指纹]做比较，如果[指纹]相同，说明数据是完整的。

3. 将服务器公钥放入数字证书中，解决了冒充的风险
   客户端先向服务端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。这个过程就会存在问题，如何保证公钥不会被篡改和信任度？
   需要借助第三方权威机构CA（数字证书认证机构），将服务器公钥放在数据证书中，只要证书是可信的，公钥就是可信的。
   ![image-20221004114638732](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004114638732.png)
   通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

### 1.4.4 HTTPS是如何建立连接的？其间交互了什么？

SSL/TSL协议基本流程：

1. 客户端向服务器索要并验证服务器的公钥
2. 双方协商生产 [会话密钥] 
3. 双方采用 [会话密钥] 进行加密通信

前两步是SSL/TSL的建立过程，也就是握手阶段。

SSL/TSL的[握手阶段]涉及四次通信，如下图：
![image-20221004115239782](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115239782.png)
![image-20221004115303493](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115303493.png)
![image-20221004115340975](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115340975.png)
![image-20221004115406496](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115406496.png)

SSL/TSL协议建立的详细流程：

1. ClientHello
   首先，由客户端向服务器发起加密请求，也就是ClientHello请求
   在这一步，客户端主要向服务器发送以下信息：

   1. 客户端支持的SSL/TSL协议版本，如TSL 1.2 版
   2. 客户端产生的**随机数（Client Random）**，后面用于产生[会话密钥]
   3. 客户端支持的密码套件列表，如果RSA加密算法

2. ServerHello
   服务器收到客户端请求后，向客户端发出响应，也就是ServerHello。服务器回应的内容有如下内容：

   1. 确认SSL/TSL协议版本，如果浏览器不支持，则关闭加密通信
   2. 服务器产生的**随机数（Server Random）**，用于后面产生[会话密钥]
   3. 确认的密码套件列表，如RSA加密算法
   4. 服务器的数字证书

3. 客户端回应
   客户端收到服务器的回应之后，首先通过浏览器或操作系统中的CA公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端就会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

   1. 一个随机数（pre-master key），该随机数会被服务器公钥加密
   2. **加密**<u>通信算法改变通知</u>，表示随后的信息都将用[会话密钥]加密通信
   3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要算法，用来供服务端校验

   上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的[会话密钥]

4. 服务器的最后回应
   服务器收到客户端的第三个随机数（pre-master）之后，通过协商的加密算法，计算出本次通信的[会话密钥]，然后向客户端发送最后的信息：

   1. **加密**<u>通信算法改变通知</u>，表示随后的信息都将用[会话密钥]加密通信
   2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有的内容发送的数据做个摘要，用来供客户端校验

   至此，整个SSL/TSL的握手阶段全部结束。接下来客户端与服务器进入加密通信，就是完全使用普通的HTTP协议，只不过用 [会话密钥] 加密内容

### 1.4.5 HTTP 1.1、HTTP 2、HTTP 3演变

HTTP1.1相比HTTP1.0性能上的改进：

1. 使用TCP长连接的方式改善了HTTP1.0短连接造成的性能开销。
2. 支持管道（pipeline）网络传输，只要第一个请求发送出去了，不必等其回来，就可以发出第二个请求出去，可以减少整体的响应时间

但是HTTP1.1还是有性能瓶颈：

1. 请求/响应头（Header）未经压缩就发送，首部信息越多延迟就越大，只能压缩Body部分
2. 发送冗余的首部。每次相互发送相同的首部造成的浪费较多
3. 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一致请求不到数据，也就是对头阻塞
4. 没有请求优先级控制
5. 请求只能从客户端开始，服务器只能被动响应



### 1.5 总结

1. https与http相比，多了什么？

   1. 建立连接得时候https比http多了TSL的握手过程
   2. 传输内容的时候，http会把数据进行加密，通常是对称加密

2. SSL与TSL的区别？

   实际上是一个东西，SSL是 [安全套接字] 的缩写，是上世纪90年代中其，网景公司设计的；后来SSL因为应用广泛，已经成为互联网上的标准，IETF就在那一年将SSL标准换，标准化之后的名称改为TLS，中文名字叫做 [传输层安全协议]

3. 为什么SSL的握手是四次？
   SSL/TLS1.2需要4次握手，需要两个RTT时延：

   ![image-20221004150955532](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004150955532.png)
   另外，SSL/TLS 1.3 优化了过程，只需要1个RRT往返时延，也就是只需要3次握手
   ![image-20221004151139554](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004151139554.png)



# 2、HTTPS RSA握手解析

![image-20221004153026080](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004153026080.png)

## 2.1 TLS握手过程

HTTP由于是我明文传输，所谓的明文就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容，所以安全上存在以下三个风险：

1. 窃听风险：比如通信链路上可以获取通信内容
2. 篡改风险：强制植入垃圾广告
3. 冒充风险：冒充淘宝网站

HTTPS在HTTP与TCP层之间加入了TLS协议解决上述风险。
![image-20221004153502657](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004153502657.png)

TLS协议是如何解决HTTP的风险的呢？

1. 信息加密：HTTP交互信息是被加密的，第三方无法窃取
2. 校验机制：校验信息传输过程中是否有被第三方篡改过，如果篡改过，则会有警告提示
3. 身份证书：证明淘宝是淘宝

可见，有了TLS协议，能够保证HTTP通信是我安全的了，那么在进行HTTP通信之前，需要先进行TLS握手。TLS的握手过程如下：
![image-20221004153853505](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004153853505.png)

上图简要概述了TLS的握手过程，其中每一个框都是一个记录，记录是TLS手法数据的基本单位，类似于TCP里的segment。多个记录可以组合一个TCP包发送，所以通常经过四个消息就可以完成TLS握手，也就是需要2个RTT时延，然后就可以在安全的通信环境里发送HTTP报文，实现HTTPS协议。

所以可以发现，HTTPS是应用层协议，需要先完成TCP连接建立，然后走TLS握手过程后，才可以建立通信安全的连接。

事实上，不同的密钥交换算法，TLS的握手过程可能会有一些区别。

这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是堆成加密密钥，而堆成加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非堆成加密的方式来保护堆成加密密钥的协商，这个工作就是密钥交换算法负责的。

接下来，我们就以最简单的RSA密钥交换算法，来看看它的TLS握手过程。



## 2.2 RSA握手过程

传统的TLS握手基本都是使用RSA算法来实现密钥交换的，在将TLS证书部署服务端时，证书文件中包含一对公钥私钥，其中公钥会在TLS握手阶段传送给客户端，私钥一直留在服务端，一定要确保私钥不能被窃取。

在RSA密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传送给服务端。根据非堆成加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后双发就能得到了相同的密钥，再用它加密应用消息。

⽤ Wireshark ⼯具抓了⽤ RSA 密钥交换的 TLS 握⼿过程，你可以从下⾯看到，⼀共经历来四次握⼿：
![image-20221004160626984](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004160626984.png)

对应的过程：
![image-20221004115239782](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115239782.png)
![image-20221004115303493](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115303493.png)
![image-20221004115340975](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115340975.png)
![image-20221004115406496](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004115406496.png)

### 2.2.1 TLS第一次握手

客户端首先会发以恶搞ClientHello消息，字面意思我们也能理解到，这是跟服务器打招呼：
![image-20221004161014223](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004161014223.png)

消息里面有客户端使用的TLS版本号、支持的密码套件列表，以及生成的随机数[Client Random]，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一

### 2.2.2 TLS第二次握手

当服务端收到客户端的ClientHello消息后，会确认TLS版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数[Server Random]

接着返回[Server Hello]消息，消息里面有服务器确认的TLS版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表中选择了一个合适的密码套件。
![image-20221004161421291](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004161421291.png)

可以看到，服务端选择的密码套件是  “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。

就前⾯这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使⽤的密码套件，⽽且你可能发现客户端和服务端都会各⾃⽣成⼀个随机数，并且还会把随机数传递给对⽅。

那这个随机数有啥⽤呢？其实这两个随机数是后续作为⽣成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使⽤的对称加密密钥。

然后服务端为了证明自己的身份，会发送 [Server Certificate] 给客户端，这个消息里含有数字证书。
![image-20221004161628460](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004161628460.png)

随后，服务端发了「Server Hello Done」消息，⽬的是告诉客户端，我已经把该给你的东⻄都给你了，本次打招呼完毕。
![image-20221004161653558](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004161653558.png)



### 2.2.3 客户端验证证书

在这⾥刹个⻋，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？

数字证书和 CA 机构
在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，⼀个数字证书通常包含了：

1. 公钥（申请证书的服务端）
2. 持有者信息（申请证书的服务端的信息）
3. 证书认证机构（CA）的信息
4. CA对这份文件的数字签名及使用的算法
5. 证书有效期
6. 还有一些额外的信息

数字证书的作用是用来认证公钥持有者的身份，以防止第三方进行冒充。说出的简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。

我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的呢？又该怎样认证证书呢？

为了让服务端的公钥被大家信任，服务端的证书都是由CA机构签名的，CA就是网络世界里的公安局、公认中心，具有极高的可信度，所以由他来给各个公钥签名，信任的一方签发的证书那么必然也是被信任的。

之所以要签名是因为签名的作用可以避免中间人在获取证书时对于证书内容的篡改。

**数字证书签发和验证流程**

![image-20221004162958245](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004162958245.png)

CA签发证书的过程，如上图左边部分：

1. 首先CA会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行Hash计算，得到一个Hash值
2. 然后CA会使用自己的私钥将该Hash值加密，生成Certificate Signature，也就是CA对证书做了签名
3. 最后将Certificate Signature添加在文件证书上，形成数字证书

客户端校验服务端的数字证书的过程，如上图右侧部分：

1. 首先客户端会使用同样的额Hash算法获取该证书的Hash值H1
2. 通常浏览器和操作系统继承了CA的公钥信息，浏览器收到证书后可以使用CA的公钥解密Certificate Signature内容，得到一个Hash值H2
3. 最后比较H1和H2，如果值相同，则为可信赖的证书，否则认为证书不可信。

**证书链**

事实上证书的验证过程还存在一个证书信任链的问题，因为我们向CA申请的证书一般不是根证书签发的，而是由于中间证书去签发的，比如百度的证书，从下图你可以看到，证书的层级一般有三级：

![image-20221004163714797](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004163714797.png)

对于这种三级层次关系的证书的验证过程如下：

1. 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就⽆法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。
2. 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA”签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是⾃签证书。应⽤软件会检查此证书有否已预载于根证书清单上，如果有，则可以利⽤根证书中的公钥去验证 “GlobalSign
   Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。
3. “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使⽤ “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com证书的可信性，如果验证通过，就可以信任baidu.com 证书。

在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 
“GlobalSign Organization Validation CA - SHA256 - G2” 证书，⽽ “GlobalSign Organization Validation CA - 
SHA256 - G2” 证书⼜信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

总括来说，由于⽤户信任 GlobalSign，所以由 GlobalSign 所担保的baidu.com 可以被信任，另外由于⽤户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。
![image-20221004164113942](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004164113942.png)

操作系统里一般都会内置一些根证书，例如作者电脑中的根证书如下：
![image-20221004164210944](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004164210944.png)

这样的一层层的验证就构成了一条信任链路，整个证书信任链验证流程如下所示：
![image-20221004164304459](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004164304459.png)

最后一个问题：为什么需要证书链这么麻烦的流程，ROOT CA不直接颁发证书？而是搞这么多中间层级呢？

这是为了确保根证书的绝对安全性，将根证书隔离的越严格越好，不安根证书如果失守了，那么整个信任链都会有问题。

### 2.2.4 TLS第三次握手

客户端验证完证书后，认为可信则继续往下走，接着，客户端就会生成一个新的随即住（pre-master），用服务器的RSA公钥加密该随机数，通过 [Change Cipher Key Exchange] 消息传送给服务端。

![image-20221004164721499](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004164721499.png)

服务端收到后，用RSA私钥解密，得到客户端发来的随机数（pre-master）

至此，客户端和服务端双方都共享了三个随机数，分别是：

1. Client Random
2. Server Random
3. pre-master

于是，双方根据得到的三个随机数，生成会话密钥，它是对称密钥，用于对后续的HTTP请求/响应的数据加密。

生成完会话密钥后，然后客户端发送一个 [Change Cipher Spec] ，告诉服务端开始使用加密方式发送消息。
![image-20221004165028931](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004165028931.png)

然后，客户端再发⼀个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再⽤会话密钥（master secret）加密⼀下，让服务器做个验证，验证加密通信是否可⽤和之前握⼿信息是否有被中途篡改过。

![image-20221004165128794](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004165128794.png)

### 2.2.5 TLS第四次握手

服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双⽅都验证加密和解密没问题，那么握⼿正式完成。
最后，就⽤「会话密钥」加解密 HTTP 请求和响应了。

## 2.3 RSA算法的缺陷

使⽤ RSA 密钥协商算法的最⼤问题是不⽀持前向保密。因为客户端传递随机数（⽤于⽣成对称加密密钥的条件之⼀）给服务端时使⽤的是公钥加密的，服务端收到到后，会⽤私钥解密得到随机数。所以⼀旦服务端的私钥泄漏了，过去被第三⽅截获的所有 TLS 通讯密⽂都会被破解。

为了解决这⼀问题，于是就有了 DH 密钥协商算法，这⾥简单介绍它的⼯作流程。
![image-20221004165539901](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-2\image-20221004165539901.png)



客户端和服务端各⾃会⽣成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各⾃的公钥，通过 TLS 握⼿双⽅交换各⾃的公钥，这样双⽅都有⾃⼰的私钥和对⽅的公钥，然后双⽅根据各⾃持有的材料算出⼀个随机数，这个随机数的值双⽅都是⼀样的，这就可以作为后续对称加密时使⽤的密钥。

 DH 密钥交换过程中，即使第三⽅截获了 TLS 握⼿阶段传递的公钥，在不知道的私钥的情况下，也是⽆法计算出密钥的，⽽且每⼀次对称加密密钥都是实时⽣成的，实现前向保密。

但因为 DH 算法的计算效率问题，后⾯出现了 ECDHE 密钥协商算法，我们现在⼤多数⽹站使⽤的正是 ECDHE 密钥协商算法，关于 ECDHE 握⼿的过程，将在下⼀篇揭晓，尽情期待哦。



