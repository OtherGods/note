#同源 #协议、域名、端口相同为同源 #跨域 #违反同源为跨域 #CORS #反向代理 

参考：
- [18.2、浏览器同源政策及其规避方法](5、计算机网络/Hollis/18.2、浏览器同源政策及其规避方法.md)
- [18.3、跨域资源共享 CORS 详解](5、计算机网络/Hollis/18.3、跨域资源共享%20CORS%20详解.md)

好的，这是一个前端开发中非常核心且常见的问题。我会从基础概念讲起，详细解释跨域、同源以及各种解决方案。

### 1. 同源策略

**同源策略** 是浏览器的一个核心安全功能，它限制了从一个源加载的文档或脚本如何与另一个源的资源进行交互。

#### 什么是"源"？

一个"源"由三部分组成：
1.  **协议** (Protocol)： 如 `http`, `https`
2.  **域名** (Host)： 如 `www.example.com`
3.  **端口** (Port)： 如 `80` (HTTP默认), `443` (HTTPS默认)

**"同源"** 意味着这三者必须**完全相同**。

#### 同源检查示例

假设当前页面网址是：`https://www.example.com:443/home/index.html`

| 请求的URL                                   | 是否同源  | 原因                        |
| :--------------------------------------- | :---- | :------------------------ |
| `https://www.example.com:443/about.html` | **是** | 协议、域名、端口全部相同              |
| `https://www.example.com:443/api/user`   | **是** | 协议、域名、端口全部相同              |
| `http://www.example.com/home/index.html` | **否** | **协议**不同 (HTTP vs HTTPS)  |
| `https://api.example.com/user`           | **否** | **域名**不同 (`www` vs `api`) |
| `https://www.example.com:8080/api/user`  | **否** | **端口**不同 (443 vs 8080)    |

#### 同源策略的限制范围

当不同源时，以下行为会受到阻止：
- **AJAX / Fetch 请求**： 无法读取响应内容（但请求实际上可能已发送到服务器）。
- **Web字体、Web Workers**： 受到限制。
- **DOM 访问**： 无法通过 `iframe` 访问不同源页面的DOM。
- **Cookie、LocalStorage、IndexedDB**： 无法访问（无法共享）。

#### 允许的跨域嵌入操作

有些操作是允许跨域的，这被称为"嵌入资源"：
- `<img>` 标签
- `<link>` 标签（用于CSS）
- `<script>` 标签（这也是JSONP的基础）
- `<iframe>` 可以加载，但不能操作其内容；比如把SMRP系统嵌入到GEAM系统
  - 你的 **JavaScript 无法访问这个 iframe 内部的 DOM**（比如你不能用 `document.getElementById('myIframe').contentDocument.body` 来获取其 body）。反之，iframe 内的脚本也无法访问父页面的 DOM。这是双向隔离的

### 2. 跨域

**跨域** 就是指发起的请求违反了同源策略，即请求的URL与当前页面来源不同。浏览器会拦截这种请求的响应，导致前端JavaScript无法获取到数据。

### 3. 如何解决跨域问题

解决跨域问题有多种方法，适用于不同的场景。

#### 方法一：CORS (跨域资源共享) - 最主流、最推荐的方案

CORS是一种W3C标准，它允许服务器通过设置一系列HTTP响应头来显式地告诉浏览器，允许哪些源的请求。

**1. 简单请求**
满足以下所有条件的请求被视为简单请求：
*   方法为：GET、POST、HEAD
*   Content-Type 为：`text/plain`, `multipart/form-data`, `application/x-www-form-urlencoded`

对于简单请求，浏览器会自动在请求头中添加 `Origin`。服务器需要返回 `Access-Control-Allow-Origin` 头。
```http
// 1. 请求头
Origin: https://www.example.com

// 1. 响应头(服务器设置)中设置允许来自指定源的请求
Access-Control-Allow-Origin: https://www.example.com // 可以使用通配符 '*'代替
```

**2. 预检请求**
不满足简单请求条件的请求（如使用了PUT、DELETE方法，或Content-Type为`application/json`），浏览器会先发送一个 **OPTIONS** 方法的"预检请求"到服务器，询问是否允许实际请求。

服务器需要正确处理这个OPTIONS请求，并返回相应的CORS头。
```http
// 1. 预检请求 (OPTIONS)
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
Origin: https://www.example.com

// 1. 预检响应 (服务器设置)中设置允许来自指定源的请求
Access-Control-Allow-Origin: https://www.example.com //可以使用通配符 '*'代替
// 2. 允许请求的HTTP方法
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
// 3. 允许的请求头
Access-Control-Allow-Headers: Content-Type
// 4. 如果请求需要携带凭证（如Cookies），还需要设置：
Access-Control-Allow-Credentials: true
```

**服务器端CORS配置示例 (Node.js/Express)：**
```javascript
const express = require('express');
const app = express();

// 简单的CORS中间件
app.use((req, res, next) => {
  // 1. 响应头(服务器设置)中设置允许来自指定源的请求
  res.header('Access-Control-Allow-Origin', 'https://www.example.com');
  // 如果允许任意源，使用 '*'
  // res.header('Access-Control-Allow-Origin', '*');
  
  // 2. 允许请求的HTTP方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  // 3. 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  // 4. 允许请求携带凭证（如cookies）
  res.header('Access-Control-Allow-Credentials', 'true');

  // 处理预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

app.get('/api/data', (req, res) => {
  res.json({ message: '这是跨域数据！' });
});

app.listen(3000);
```

#### 方法二：代理服务器

参考：
- [17、什么是正向代理和反向代理？](5、计算机网络/Hollis/17、什么是正向代理和反向代理？.md)
- [1、ChatGPT解释的Nginx解决前后端端口不通导致跨域问题](2、相关技术/14、J2EE基础-Web服务器/Nginx/1、ChatGPT解释的Nginx解决前后端端口不通导致跨域问题.md)

由于同源策略是浏览器的限制，**服务器与服务器之间没有跨域问题**。因此，可以 **==设置一个与自己页面同源的代理服务器，由它来转发请求到目标服务器==**。

**工作流程：**
`浏览器 (https://www.example.com)` --> `同源代理服务器 (/api/proxy)` --> `目标API (https://api.target.com/data)`

**实现方式：**
- **开发环境**： 使用 webpack-dev-server, Vite 等工具提供的 `proxy` 配置。
    ```javascript
    // vite.config.js
    export default {
      server: {
        proxy: {
          '/api': {
            target: 'https://api.target.com',
            changeOrigin: true,
            rewrite: (path) => path.replace(/^\/api/, '')
          }
        }
      }
    }
    ```
*   **生产环境**： 使用 Nginx 或自己编写的后端服务作为代理。
    ```nginx
    # Nginx 配置示例
    location /api/ {
        proxy_pass https://api.target.com/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    ```
	  实际示例：将请求`geam.xxx.com/smrp-proxy/api/users`转发到`smrp.xxx.com/smrp-proxy/api/users`，同时携带cookie
    ```nginx
    # 把SMRP系统嵌入GEAM系统，同时将cookie从GEAM传递到SMRP
    server {
	    listen 80;
	    server_name geam.xxx.com;

		# 代理配置：将 /smrp-proxy/ 路径的请求转发到 smrp.xxx.com
	    location /smrp-proxy/ {
	        # 目标服务器：smrp.xxx.com
	        proxy_pass https://smrp.xxx.com/;
		    
		    # URL 重写：移除 /smrp-proxy 前缀，会将geam.xxx.com/smrp-proxy/api/users转发到smrp.xxx.com/api/users
	        # rewrite ^/smrp-proxy/(.*)$ /$1 break;
	        
	        # 重要：传递原始请求的Cookie
	        proxy_pass_header Set-Cookie;
	        proxy_pass_header Cookie;
	        
	        # 设置正确的请求头
	        proxy_set_header Host smrp.xxx.com;
	        proxy_set_header X-Real-IP $remote_addr;
	        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
	        proxy_set_header X-Forwarded-Proto $scheme;
	        
	        # 确保 Cookie 被正确传递
	        # 将geam.xxx.com的Cookie传递给smrp.xxx.com使用
	        proxy_cookie_domain geam.xxx.com smrp.xxx.com;
	        proxy_cookie_path / /;
	        
	        # 其他代理设置
	        proxy_redirect off;
	        proxy_buffering off;
	    }
	    
	    # 其他 location 配置...
	}
    ```

#### 方法三：JSONP - **古老且有限的方法**

利用 `<script>` 标签没有跨域限制的特性来实现。它只支持 **GET** 请求。

**工作原理：**
1. 前端定义一个全局回调函数。
2. 动态创建一个 `<script>` 标签，其 `src` 指向目标API，并在URL中传递回调函数名。
3. 服务器返回一段JavaScript代码，调用这个回调函数，并将数据作为参数传入。

**前端示例：**
```javascript
function handleResponse(data) {
  console.log('收到数据:', data);
}

const script = document.createElement('script');
script.src = 'https://api.example.com/data?callback=handleResponse';
document.body.appendChild(script);
```

**服务器响应：**
```javascript
// 返回的不是JSON，而是一段可执行的JS代码
handleResponse({ "name": "Alice", "age": 30 });
```

**缺点**：只支持GET，错误处理困难，存在安全风险（如果服务器被黑）。

#### 方法四：WebSocket

WebSocket协议本身支持跨域，可以在建立连接后自由通信。

#### 方法五：修改 `document.domain` - **仅限特定场景**

如果两个页面拥有相同的**一级域名**，但二级域名不同，可以通过将 `document.domain` 设置为相同的一级域名来实现跨域。

**例如：**
`a.example.com` 和 `b.example.com` 都可以设置：
```javascript
document.domain = 'example.com';
```
之后它们就可以相互访问彼此的DOM和Cookie了。

**限制**： 必须同属一个一级域名，且端口必须相同。现代开发中较少使用。

#### 方法六：`window.postMessage`

用于在不同窗口（如iframe、弹出窗口）之间安全地进行跨源通信。

**父窗口发送消息：**
```javascript
const iframe = document.getElementById('myIframe').contentWindow;
iframe.postMessage('Hello!', 'https://child-domain.com');
```

**子窗口接收消息：**
```javascript
window.addEventListener('message', (event) => {
  // 检查消息来源是否可信
  if (event.origin !== 'https://parent-domain.com') return;
  console.log('收到消息:', event.data);
});
```

### 总结与选择建议

| 方法            | 适用场景             | 优点             | 缺点             |
| :------------ | :--------------- | :------------- | :------------- |
| **CORS**      | **前后端分离项目的主流选择** | 标准化、安全、功能完整    | 需要服务器端配合       |
| **代理服务器**     | 开发环境、无法修改目标服务器时  | 前端无需改动，规避浏览器限制 | 需要搭建代理服务，增加复杂度 |
| `JSONP`       | 老旧项目、只读GET请求     | 兼容老浏览器，无需服务器大改 | 仅GET、不安全、错误处理难 |
| `WebSocket`   | 实时双向通信           | 真正的双向通信，不受同源限制 | 不适用于普通API请求    |
| `postMessage` | 窗口/iframe间通信     | 安全可控           | 只适用于窗口间通信      |

**现代Web开发最佳实践：**

1.  **首选 CORS**：如果你的后端服务是你或你的团队可以控制的，这是最标准、最安全的解决方案。
2.  **开发环境用代理**：在开发时，利用构建工具（如Vite、Webpack）的代理功能来避免CORS配置的麻烦。
3.  **生产环境用CORS或Nginx代理**：生产环境中，根据架构选择配置CORS头，或者使用Nginx反向代理。
