<u>这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对面试题总结。</u>

计算机网络面试题来自：

1. 《图解HTTP.pdf》【讲的不是很好】
2. 《计算机网络面试题（2021最新版）.pdf》【上一篇文章】

# 1、图解计算机网络

## 1.1 认识HTTP

HTTP协议是一种超文本传输协议（Hypertext Transfer Protocol）。

超文本传输协议可以进行文字分割：超文本（Hypertext）、传输（Transfer）、协议（Protocol），它们之间的关系如下：
![image-20221002155530571](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002155530571.png)

按照范围的大小： 协议 > 传输 > 超文本。

### 1.1.2 什么是超文本

图片、音频、视频、点击文字能够进行超链接的跳转，这种语义被扩大以后的文本被称之为超文本。

### 1.1.3 什么是传输

两台计算机之间进行通信的时候，我们存储的超文本会被解析成二进制数据包，由传输媒体（例如：同轴电联、电话线、光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称之为传输。

### 1.1.4 什么是协议

网络协议是网络中（包括互联网）传递、管理信息的一些规范，计算机之间相互通信要遵守一定的规则，这些规则被称之为网络协议。

## 1.2 与HTTP相关的组件

### 1.2.1 CDN

CDN全称是Content Delivery Network，即内容分发网络，它应用了HTTP协议里的缓存和代理结束，代替源站响应客户端的请求。CDN是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需要的内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

### 1.2.2 HTML

称之为超文本标记语言，是一种标识性的语言。

## 1.3 与HTTP有关的协议

### 1.3.1 TCP/IP

TCP/IP协议，我们一般称之为协议簇，TCP/IP协议簇中不仅仅只有TCP协议和IPD协议，它们是一系列网络通信协议的统称。其中最核心的两个协议就是TPC/IP协议，其他的还有UDP、ICMP、ARP等，共同洪构成了一个复杂但有层次的协议栈。

TCP协议的全称是Transmission Control Protocol的缩写，意思是传输控制协议，HTTP使用TCP作为通信协议，这是因为TCP是一种可靠的协议，而可靠能保证数据不丢失。

IP协议的全称是Internet Protocol的缩写，它主要解决的是通信双方寻址的问题。

### 1.3.2 DNS

把IP地址i转换为便于人类记忆的协议就是DNS协议。

DNS协议的全称是域名系统（Domain Name System，缩写：DNS），它作为将域名和IP地址相互映射的一个分布式数据库，能够是人们更加方便地访问互联网。

### 1.3.3 URI/URL

人们在浏览器中输入地地址地格式必须是满足URI的规范。

URI的全称是：统一资源标识符，使用它能够唯一的标记互联网上的资源

URL的全称是：统一资源定位符，也就是我们俗称的网址，它实际上是URI的一个子集。

URI不仅包括URL，还包括URN（统一资源名称），它们之间的关系如下：
![image-20221002163235061](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002163235061.png)



### 1.3.4 HTTPS

HTTP一般是明问传输，很容易被攻击者窃取到重要信息，鉴于此，HTTPS应运而生。HTTPS的全称为：HyperText Transfer Protocol over SecureSocket Layer。HTTPS和HTTP有很大的不同在：HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS在HTTP的基础上增加了SSL层，也就是说HTTPS = HTTP + SSL。

## 1.4 HTTP请求响应过程

在浏览器中输入网址后发生了什么？你想要的内容是如何展示出来的？我们通过一个例子来探讨一下，我们假设访问的URL地址为：http://www.someSchool.edu/someDepartment/home.index，当我们输出网址点击回车时，浏览器内部会进行如下操作：

1. DNS服务器会首先进行域名的映射，找到访问 www.someSchool.edu 所在的地址，然后HTTP客户端进程在80端口发起一个到服务器 www.someSchool.edu 的TCP连接（80端口是HTTP的默认端口）。在客户端和服务器进程中都会有一个套接字于其相互连接。
2. HTTP客户端通过它的套接字向服务器发送一个HTTP请求报文。该报文中包含了路径someDepartment/home.index的资源。
3. HTTP服务器通过它的套接字接受该报文，进行请求的解析工作，并从其存储器（RAM或磁盘）中检索出对象www.someSchool.edu/someDepartment/home.index，然后把检索出来的对象进行封装，封装到HTTP响应报文中，并通过套接字向客户端进行发送
4. HTTP服务器随即通知TCP断开TCP连接，实际上是需要等待客户端接受完响应报文才会断开TCP连接
5. HTTP客户端接受完响应报文后，TCP连接会关闭。HTTP客户端从响应中提取出报文中是一个HTML响应文件，并检查该HTML文件，然后循环价差报文其中其他内部对象
6. 检查完成后，HTTP客户端会把对应的资源通过显示器呈现给用户


## 1.5 HTTP请求特征

从1.4的过程中我们可以总结出HTTP进行分组传输是具有以下特征：

1. 支持客户-服务器模式

2. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST、HEAD。每种方法规定了客户与服务器联系的类型不同，由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快

3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记

4. 无连接：无连接的含义是限制每次连接只处理以一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

   > 来自思否上的一个回答：[如何理解HTTP的无连接、短连接、长连接？](https://segmentfault.com/a/1190000015821798)
   >
   > HTTP不是字面意义上的没有连接，事实上，这个也符合HTTP短连接的定义，但是无连接强调的是HTTP的特性，短连接可以理解为一种实现。

   

5. 无状态：HTTP协议是无状态协议。无状态协议是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则他必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。



## 1.6 详解HTTP报文

HTTP协议主要由三大部分组成：

1. 起始行：描述请求或者响应的基本信息
2. 头部字段：使用key-value的形式更加详细的说明报文
3. 消息正文：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据

其中起始行和头部字段并称为请求头/响应头，统称为Header；消息正文也叫实体，称为body。HTTP协议规定每次发送的报文必须有Header，但是可以没有body，也就是说头信息是必须有的，实体信息可以没有。而在header和body之间必须要有一个空行（CRLF），如果用一幅图来表示一下的话，应该是下面这样子的：
![image-20221002181008215](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002181008215.png)



一个http的请求报文示例：

![image-20221002181104189](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002181104189.png)

通过观察这个HTTP报文我们能够学到很多东西：首先，我们看到报文是用普通ASCII文本熟悉恶的，这样保证人能够可以看东，然后我们可以看到每一行和我下一行之间都会换行，而且最后一行（请求头部后）再加上一个回车换行符。

每个报文的起始行都是由三个字段组成：方法、URL字段、HTTP版本字段

## 1.7 HTTP CROS跨域

CROS的全称是Cross-Origin Resource Sharing(CROS)，中文名字是跨域资源共享，它是一种机制：是一种让运行在一个域上的Web应用被准许访问来自不同源服务器上指定资源的机制。

首先来了解一下什么是域？

**Origin**

Web概念中域（Origin）的内容由scheme（protocol）-协议、host（domain）-主机和用户访问它的URL  port-端口定义，仅仅当协议、主机、端口都匹配时两个对象才有相同的来源。这种歇息相同，域名相同，端口相同的安全策略也被称之为同源策略。某些操作仅限于具有相同来源的内容，可以使用CORS取消此限制。

**跨域特点**

举例说明：

```http
(1) http://example.com/app1/index.html
(2) http://example.com/app2/index.html
```

上面这两个URL是否具有跨域问题呢？

上面这两个URL不具有跨域问题，因为这里两个URL具有相同的协议、主机、端口号；

注意：其中协议和域名是不区分大小写的，但是路径部分是路径部分根据服务器平台决定。

![image-20221002183359672](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002183359672.png)



**同源策略**

出于安全的因素，浏览器限制了从脚本发起跨域的HTTP请求。XMLHttpRequest 和其他 Fetch 接口会遵循同源策略  (same-origin policy)  。也就是说使用这些API 的应用程序想要请求相同的资源，那么它们应该具有相同的来源，除非来自其他来来源的响应 包括正确的CORS 标头。

## 1.8 HTTP Cookies

HTTP协议中的Cookies包括Web Cookei和浏览器 Cookie，它是服务器发送到Web浏览器的一小块数据。服务器发送到浏览器的Cookie，浏览器会进行存储，并于下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。

> HTTP Cookie机制是HTTP协议无状态的一种补充和改良

Cookie主要用于下面三个目的：

1. 会话管理：登录、购物车、游戏得分或服务器应该记住的其他内容
2. 个性化：用户偏好、主题或其他设置
3. 追踪：记录和分析用户行为

当接收到客户端发出的HTTP请求的时候，服务器可以发送带有响应的Set-Cookeo标头，Cookie通常由浏览器存储，然后将Cookie与HTTP标头一同向服务器发出请求。可以指定到期日期或持续时间，之后将不再发送Cookie；此外可以这是对特定域和路径的限制，从而限制cookie的发送位置。

**Set-Cookie和Cookie标头**

Set-Cookie  HTTP响应标头将cookie从服务器发送到用户代理，下面是一个发送Cookie的例子：

```http
1   HTTP/2.0 200 OK
2   Content-type: text/html
3   Set-Cookie: yummy_cookie=choco
4 	Set-Cookie: tasty_cookie=strawberry
5
6   [page content]
```

此标头部告诉客户端存储Cookie

现在，随着对服务器的每个请求，浏览器都将使用Cookie头将所有以前存储的cookie发送回服务器（满足域名、路径、未过期……）

```http
1   GET /sample_page.html HTTP/2.0
2   Host: www.example.org
3 Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

Cookie主要分为三类，它们是：会话Cookie、永久性Cookie、Cookie的Secure和HttpOnly标记。

### 1.8.1 会话Cookies

上面示例中创建的是会话Cookie，会话Cookie有个特征，客户端关闭时候Cookie会删除，因为它没有指定Expires或Max-Age指令。

但是，Web浏览器可能会使用会话还原，这会使大多数会话Cookie保持永久状态，就像从未关闭过浏览器一样。

### 1.8.2 永久性Cookies

永久性Cookie不会在客户端关闭时过去，而是在特定日期（Expires）或特定时间长度（Max-Age）外过期。例如：

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

### 1.8.3 Cookie的Secure和HttpOnly标记

安全的Cookie需要经过HTTPS协议通过加密的方式发送到服务器，即使是安全的，也不应该将敏感的信息存储在cookie中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。

**HttpOnly的作用**

1. 会话cookie中缺少HttpOnly属性会导致攻击者可以通过程序（JS脚本、Applet等）获取到用户的cookie信息，造成cookie信息泄漏，增加攻击者的跨栈脚本攻击威胁。
2. HttpOnly是微软对cookie做的扩展，该值指定cookie是否可以通过客户端脚本访问
3. 如果在Cookie中没有设置HttpOnly属性为了true，可能会导致Cookie被窃取。窃取的Cookie可以包含标识站点用户的敏感信息，如 ASP.NET 会话 ID 或 Forms 身份验证票证，攻击者可以重播窃取的Cookie，以便伪装成用户或获取敏感信息，进跨栈脚本攻击等。

### 1.8.3 Cookei的作用域

Domain和Path标识定义了Cookie的作用域：即Cookie应该发送给那些URL。

Domain标识指定了那些主机可以接受Cookie。如果不指定，默认为当前主机（不包含子域名）。如果指定了Domain，则一般包含子域名。

例如：如果设置Domain=mozilla.org，则Cookie也包含在子域名中（如：developer.mozilla.org）

例如：设置Path=/docs，则以下地址都会匹配：

1. /docs
2. /docs/Web/
3. /docs/Web/HTTP



## 1.9 HTTP的优点和缺点

### 1.9.1 HTTP的优点

1. 简单灵活易扩展
   HTTP最重要也是最突出的优点是：简单、灵活、易于扩展。

   HTTP的协议比较简单，它的主要组成就是header+body，头部信息也是简单的文本格式，而且HTTP的请求报文根据英文也能猜测出来个大概意思，降低学习门槛，能够让更多的人研究和开发HTTP应用。

   所以，在简单的基础上，HTTP协议又多了灵活和易扩展的特点。

   HTTP协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被制定死，允许开发者任意定制、扩展或解释，给与了浏览器和服务器最大程度的信任和自由。

2. 应用广泛、环境成熟
   因为过于简单，普及，因此应用很广泛。因为HTTP协议本身不属于一种语言，它并不限定某种编程语言或操作系统，所以天然具有跨语言、跨平台的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有HTTP调用库和外围的开发测试工具。

   随着移动互联网的反战，HTTP的触角已经延伸到了世界的每一个角落，从简单的Web页面到复杂的JSON、XML数据、从台式机上的浏览器到手机上的各种APP、新闻、论坛、购物、手机游戏，你很难找到一个没有使用HTTP的地方

3. 无状态
   无状态即是优点又是缺点。一位内服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务。

### 1.9.2 HTTP的缺点

1. 无状态
   既然服务器没有记忆能力，它就无法支持需要连续多个步骤的事务操。每次都得问一次身份信息，不仅蛮烦，而且增加了不必要的数据传输量。由此出现了Cookie技术。

2. 明问
   HTTP协议里还有一把优缺点一体的双刃剑，就是明文传输。明文的意思就是协议里的报文（准确的说是header部分）不使用二进制数据，而是简单可阅读的问本形式。

   对比TCP、UDP这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器或者Wireshark抓包后，直接用肉眼就可以很容易的查看或修改，为我们的开发调试工作带来极大的便利。

   当然缺点也是显而易见的，就是不安全，可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被更改过。

3. 性能
   HTTP的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。

## 1.10 HTTPS为什么会出现

### 1.10.1 HTTPS解决了什么问题

一个简单的回答可能会是HTTP它不安全。由于HTTP天生明文传输的特性，在HTTP的传输过程中，任何人都可能从中截获、修改或伪造请求发送，所以可以认为HTTP是不安全的；

在HTTP的传输过程中不会验证通信方的身份，因此HTTP信息交换的双方可能会遭到伪装，也就是没有用户验证；

在HTTP的传输过程中，接受方和发送方并不会验证报文的完整性，综上，为了解决上述问题，HTTPS应用而生。

![image-20221002200941248](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002200941248.png)



### 1.10.2 什么是HTTPS

HTTP的定义：<font color = "red">HTTP是一种超文本传输协议（Hypertext Transfer Protocol）协议，它是一个在计算机世界里专门在两个点之间传输文字、图片、音频、视频等超文本数据的约定和规范</font>，那么我们看一下HTTPS是如何定义的？

HTTPS的全称是：Hypertext Trandfer Protocol Secure，它用来在计算机网络上的两个端系统之间进行安全的交换信息（secure communication），它相当于在HTTP的基础上加了一个Secure安全的词眼，那么我们可以给出一个HTTPS的定义：<font color = "red">HTTPS是一个在计算机世界里专门在两个点之间安全的传输文字、图片、音频、视频等超文本数据的约定和规范</font>。<font color = "blue"><u>HTTPS是HTTP协议的一种扩展，它本身并不保证传输的安全性</u></font>，那么谁来保证安全性呢？在HTTPS中，使用传输层安全性（TLS）或安全套接字（SSL）对通信协议进行加密；也就是HTTP+SSL=HTTPS。
![image-20221002202159935](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002202159935.png)

### 1.10.3 HTTPS做了什么

HTTPS协议提供了三个关键的指标：

1. 加密（Encryption），HTTPS通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听它和网站之间的信息交换，或者跟踪用户的活动，范围跟记录等，从而窃取用户信息。
2. 数据一致性（Data integrity），数据在传输过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接受的就是什么。
3. 身份认证（Authentication），是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别），它可以防止中间人攻击并建立用户信任。

有了上面三个关键指标的保证，用户就可以和服务器进行安全的交换信息了。

用户怎么知道网站是HTTPS的还是HTTP的？如下图：

![image-20221002202856798](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002202856798.png)

HTTPS协议其实非常简单，RFC文档很小，只有短短7页，里面规定了新的协议名，默认端口号443，至于其他的应答模式、报文结构、请求方法、URI、头字段、连接管理等都完全沿用HTTP，没有任何新的东西。

也就是说，除了协议名称和默认端口号外（HTTP默认端口80），HTTPS协议在语法、语义上和HTTP一样，HTTP有的，HTTPS也全有，那么HTTPS怎么做到HTTP不能做到的安全型的呢？关键在这个S，也就是SSL/TLS。

### 1.10.4 HTTPS的内核是HTTP

HTTPS并不是一项新的应用层协议，只是通过HTTP通信接口部分由SSL和TLS替代而已；通常情况下，HTTP会先直接和TCP进行通信。

在使用SSL的HTTPS后，则演变为HTTPS先和SSL进行通信，然后再由SSL和TCP进行通信。也就是说HTTPS就是身披了一层SSL的HTTP。

![image-20221002204301743](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002204301743.png)

SSL是一个独立的协议，不只有HTTP可以使用，其他应用层协议也可以使用，比如SMTP（电子邮件协议）、Telent（远程登录协议）等都可以使用。

具体HTTPS的内容还是去看别的地方把，这里介绍的很浅。

## 1.11 Cookie和Session

HTTP协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的例是请求记录；Session和Cokie的主要目的是为了弥补HTTP的无状态协议。

### 1.11.1 Session是什么

客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是Session对象，存储结构为ConcurrentHashMap。Session弥补了HTTP无状态特性，服务器可以利用Session存储客户端在同一个会话期间的一些操作记录。

### 1.11.2 Session是如何判断是否是同一会话？

服务器第一次接收到请求时，开辟了一块Session空间（创建了Session对象），同时生成一个sessionid，并通过响应头Set-Cookie：JSESSIONID=XXXXXX命令，向客户端发送要求设置Cookie的响应；客户端收到响应后，在本机客户端设置了一个JSESSIONID=XXXXXX的Cookie信息，该信息的过期时间为浏览器会话结束。

接下来客户端每次向同意网站发送请求时，请求头都会带上该Cookie信息（包含sessioneid），然后服务器通过读取请求头中的Cookie信息，获取名称为JSESSIONID的值，得到此次请求的sessionid。

### 1.11.3 Session的缺点

Session机制有个缺点，比如服务器存储了Session，就是做了负载均衡之后，加入一段时间内部A的访问数量激增长，会转发到B进行访问，但是B服务器并没有存储A的Session。会导致Session的失效。

## 1.12 JSON Web Token和Session Cookies的对比

> **Session Cookies 来自ChatGPT的介绍：**
> 
> Session Cookies是一种用于维持会话状态的Cookie，它们与服务器端的会话(Session)密切相关，但并不等同于会话(Session)本身。
> 
> 在传统的基于Session的身份验证机制中，服务器会为每个用户创建一个会话，并在服务器端维护该会话的状态信息。而为了跟踪和识别不同的会话，通常会使用Session Cookies来存储会话标识符（Session ID）。

具体而言，当用户第一次访问应用程序时，服务器为其创建一个唯一的Session ID，并将该标识符存储在一个Cookie中，该Cookie被称为Session Cookie。每次用户发送请求时，浏览器会自动将该Cookie包含在请求中，从而允许服务器根据Session ID来识别和关联对应的会话数据。

所以，Session Cookies可以说是用于管理和维持会话状态的Cookie，但本身并不等同于会话(Session)。Session是服务器端的概念，用于存储和管理会话数据，而Session Cookies是通过Cookie机制在客户端存储和传递会话标识符的一种方式。

JSON Web Token简称JWT，他和Session都可以为网站提供用户的身份认证，但是它们不是一回事。

### 1.12.1 下面是JWT和Session Cookies的相同之处

它们即可以对用户进行身份认证，也可以用来在用户单击进入不同页面时以及登录网站或应用程序后进行身份验证。

如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为HTTP是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上另一个页面时，服务器的内存中将不会记住你之前的操作。

![image-20221002223212101](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002223212101.png)

因此，如果你登录并访问了你有权访问的另一个页面时，由于HTTP不会记录你刚刚登录的信息，因此你将再次登录。

JWT和Session Cookies的相同之处是什么？
<font color = "red">那就是它们能够支持你在发送不同请求之间，记录并验证你的登陆状态的一种机制。</font>

### 1.12.2 什么是Session Cookies

Session Cookies也称之为会话Cookies，在Session Cookies中，用户的登陆状态会保存在服务器的内存中。当用户登录时候，Session就被服务端安全的创建。

在每次请求时，服务器都会从会话Cookie中读取SessionId，如果服务端的数据和读取到的SessionId相同，那么服务器就会发送响应给浏览器，允许用户登录一次后就不再登录。

![image-20221002224119649](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221002224119649.png)

### 1.12.3 什么是Json Web Tokens

Json Web Tokens的简称就是JWT，通常可以称之Json令牌，他是RFC 7519中定义的用于安全的将信息作为Json对象进行传输的一种形式。JWT中存储的信息就是经过数字签名的，因此可以被信任和理解，可以使用HMAC算法或者使用RSA/ECDSA的公用/专用密钥对JWT进行签名。

使用JWT主要用于下面两点：

1. 认证：这是使用JWT最常见的一种情况，一旦用户登录，后面每个请求都会包含JWT，从而允许用户访问该令牌锁允许的路由、服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小。
2. 信息交换：JWT是能够安全传输信息的一种方式。通过公钥/私钥对JWT进行签名认证。此外，由于签名是使用head和payload计算的，因此你还可以校验内容是都遭受到篡改。

有关JWT的详细信息可以去看[补4-JWT跨域认证的问题](2、相关技术/13、J2EE基础-Servlet/JavaWeb(石头)/JavaWeb开发实战教程(JSP+Servlet+Mvc)/《第五章%20会话技术Cookie》课程资料/讲义/补4-JWT跨域认证的问题.md)

### 1.12.4 JWT和Session Cookies的不同

JWT和Session Cookies都提供安全的用户身份验证，但是它们之间有以下几点不同：

1. 密码签名
   JWT具有加密签名，而Session Cookies则没有
2. JSON是无状态的
   JWT是无状态的，因为声明被存储在客户端，而不是服务端内存中。
   身份验证可以在本地进行，而不是在请求必须通过服务器数据库或者类似位置中进行。这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。
   
   这里说的无状态指的是：JWT将身份验证和授权的信息直接嵌入到令牌本身中，无需在服务器端存储任何会话信息。这与传统的基于Session的身份验证机制有所不同，后者需要在服务器端存储会话状态。（来自ChatGPT）
3. 可扩展性
   Session Cookies是存储在客户端中的，但是对应的Session是存储在服务器内存中，这就意味着如果网站或应用很大的情况下会耗费大量的资源。由于JWT是无状态的（服务器中无存储的信息），在许多情况下，它们可以节省服务器资源。因此JWT要比Session Cookies具有更强的可扩展性。
4. JWT支持跨域认证
   Session Cookies只能用在单个节点的域或者它的子域中有效。如果他们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。使用JWT可以解决这个问题，使用JWT可以通过多个节点进行用户认证，也就是我们常说的跨域认证。

### 1.12.5 JWT 和 Session Cookies的选型

对于只需要登录用户并访问存储在站点数据库中的一些信息的中小型网站来说，Session Cookies通常能满足。

如果你有企业级站点，应用程序或附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方（包括位于不同域的API），则JWT显然更加合适。

## 1.13 禁用Cookies后如何使用Session

1. 如果禁用了Cookies，服务器仍然会将sessionId以cookie的方式发送给浏览器，但是，浏览器不在保存这个cookie（即sessionId）了
2. 如果想钥继续使用session，需要采用URL重写的方式实现。

## 1.14 TCP和UDP的区别

**UDP是什么？**

全称是User Datagram Protocol，***用户数据报协议***，它不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接受方同意通信之前进行数据传输。

> 数据报是与分组交换网络关联的传输单元

UDP的特点：

1. UDP能支持容忍数据包丢失的带宽密集型应用程序
2. UDP具有低延迟的特点
3. UDP能够发送大量的数据包
4. UDP能够允许DNS查找，DNS是建立在UDP之上的应用层协议

**TCP是什么？**

TCP全称是Transmission Control Protocol，***传输控制协议***，它能够帮助你确定计算机连接到Internet以及它们之间的数据传输，通过三次握手来建立TCP连接，三次握手就是用来启动和确认TCP连接的过程；一旦建立连接后，就可以发送数据了，当数据传输完成之后，会通过关闭虚拟电路有来断开连接。

TCP的特点：

1. TCP能够确保连接的建立和数据包的发送
2. TCP支持错误重传机制
3. TCP支持拥塞控制，能够在网络拥堵的情况下延迟发送
4. TCP能够提供错误校验和，甄别有害的数据包

| TCP                              | UDP                     |
| -------------------------------- | ----------------------- |
| TCP是面向连接的协议                      | UDP是无连接的协议              |
| TCP在发送数据前先需要建立连接，然后再发送数据         | UDP无需建立连接就可以直接发送大量数据    |
| TCP会按照特定顺序重新排列数据包                | UDP数据包没有固定顺序，所有数据包都相互独立 |
| TCP传输的速度比较慢                      | UDP的传输会更快               |
| TCP的头部字节有20字节                    | UDP的头部字节只需要8个字节         |
| TCP是重量级的，在发送任何用户数据之前，TCP需要三次握手连接 | UDP是轻量级的，没有跟踪连接，消息排序等   |
| TCP会进行错误校验，并能够进行错误恢复             | UDP也会错误检查，但会丢失错误的数据包    |
| TCP有发送确认                         | UDP没有发送确认               |
| TCP会使用握手协议，例如SYN、SYN-ACK、ACK     | 无握手协议                   |
| TCP是可靠的，因为它可以确保将数据传送到路由器         | 在UDP中不能保证将数据传送到目标       |



## 1.15 地址栏输入URL发生了什么

1. 首先在浏览器中输入URL地址，按回车

2. 浏览器会根据你输入的URL地址，去查找域名是否被本地DNS缓存，不同浏览第对DNS的设置不同，如果浏览器缓存了你想访问的URL地址，那么就直接返回ip；如果没有缓存你的URL地址，浏览器就会发起系统调用来查询本机hosts文件是否有配置ip地址，如果找到，直接返回。如果找不到，就向网络中发起一个DNS查询。

   互联网中识别主机方式有两种，通过主机名和IP地址，有一种能够把主机名到IP地址的转换服务，这种服务就是由DNS提供的。DNS的全称是Domain Name System  域名系统。DNS是一种由分层的DNS服务器实现的分布式数据库。
   DNS运行在UDP上，使用53端口。
   DNS是一种分层数据库，它的主要层次结构如下：
   ![image-20221003083553594](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-2\image-20221003083553594.png)

   一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的DNS服务器，它是本地DNS服务器。严格来说，本地DNS服务器并不属于上述层次结构。

   DNS涉及两种查询方式：一种是递归查询，一种是迭代查询；如果根域名服务器无法告知本地DNS服务器下一步需要访问哪个顶级域名，就会使用递归查询；如果根域名能够高只DNS服务器下一步要访问的顶级域名服务器，就会使用迭代查询。

   在由根域名服务器——>定义域名服务器——>权威DNS服务器后，由权威服务器告诉本地服务器目目标IP地址，再有本地DNS服务器告诉用户需要访问的IP地址。

3. 浏览器需要和目标服务器建立TCP连接，需要经过三次握手的过程

4. 在建立连接后，浏览器会向目标服务器发起HTTP-GET请求，包括其中的URL，HTTP1.1后默认使用长连接，只需要一次握手即可多次传输数据

5. 如果目标服务器只是一个简单的页面，就会直接返回。但那是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而是会直接重定向，返回的状态码不是200，而是301、302等以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中找打重定向地址，浏览器重新第一步访问即可。然后浏览器重新发起请求，携带的URL，返回状态码200 OK，标识服务器可以响应请求体，返回报文。













