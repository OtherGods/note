**<u>*这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对面试题总结。*</u>**

计算机网络面试题来自：

1. 《图解HTTP.pdf》【下一篇文章】
2. 《计算机网络面试题（2021最新版）.pdf》

# 1、图解计算机网络

见《计算机网络-面试题-2.md》





# 2、计算机网络面试题（2021最新版）

## 1.1、计算机网络体系结构

在计算机网络的基本概念中，分层的体系结构是最基本的。计算机网络系统结构的抽象概念较多，在学习的时候需要多思考。这些概念对后买你的学习很有帮助。

### 1.1.1、网络协议是什么？

在计算机网络要做到有条不紊的交换数据，就必须遵循一些实现约定好的规则，比如交换数据的格式、是否需要发送一个消息。这些规则被称之为网络协议。

### 1.1.2为什么要对网络协议分层？

1. 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。
2. 灵活性好。当其中一层的而技术变化的时候，只要层间接口关系保持不变，其他层不受影响
3. 易于实现和维护
4. 促进标准化工作。分开后，每层功能可以相对简单的被描述

网络协议分层的缺点：功能可能出现在多个层中，产生了额外的开销。

为了使不同体系结构的计算机网络都能互联，国际标准化组织ISO于1997年提出了一个试图管理各种计算机在世界范围内互联网的标准框架，即著名的开放系统互联基本参考OSI/RM，简称OSI。

OSI的七层协议体系结构概念清楚，理论也较为完整，但它即复杂又不适用，TCP/IP体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP是一个四层次体系结构，它包含了应用层、运输层、网际层和网络接口层次（用网际层这个名是情调这一层是为了解决不同网络互连的问题），不过从实质上讲，TCP/IP只有最上面的三层，因为最下面的网络层接口并没有具体的内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可以把最底下的两层称之为网络接口层。

四层协议、五层协议、七层协议的关系如下：

1. TCP/IP是四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层
2. 五层协议的体系结构主要包括：应用层、运输层、网络层、数据链路层、物理层
3. OSI七层协议模型主要包括是：应用层、表示层、会话层、会话层、运输层、网络层、数据链路层、物理层

![image-20220925233235465](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-1\image-20220925233235465.png)



注意：五层协议的体系结构只是为了介绍网络原理而涉及的，实际应用的还是TCP/IP四层体系结构。

## 1.2、TCP/IP 协议族

### 1.2.1、应用层 

应用层的任务是通过应用进程之间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。

对于不同的网络应用需要不同的应用协议。在互联网中应用层协议很多，如：域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。

### 1.2.2、运输层 

运输层的主要任务是负责向两台主机进程之间的通信提供统用的***数据传输服务***。应用程序利用该服务传送应用层报文。

运输层主要使用以下两种协议：

1. 传输控制协议——TCP：提供面向连接的，可靠的数据传输服务
2. 用户数据协议——UDP：提供无连接的，尽最大女里的数据传输服务（不保证数据传输的可靠性）。

|              | UDP（用户数据报协议）                      | TCP（传输控制协议）                      |
| ------------ | ------------------------------------------ | ---------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                                 |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制         |
| 连接对象个数 | 支持一对一，一对多，多对一，多对多交互通信 | 只能是一对一通信                         |
| 传输方式     | 面向报文                                   | 面向字节流                               |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节               |
| 场景         | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如：文件传输 |

每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：

1. 运行在TCP协议上的协议：
   1. HTTP（超文本传输协议）：主要用于普通浏览
   2. HTTPS（安全超文本传输协议）：HTTP协议的安全版本
   3. FTP（文件传输协议）：用于文件传输
   4. POP3（邮局协议）：收邮件用
   5. SMTP（简单邮件传输协议）：用来发送邮件
   6. TELNET（网络电传）：通过一个终端登录到网络
   7. SSH（用于替代安全性差的TELNET）：用于加密安全登录用。
2. 运行在UDP协议上的协议：
   1. BOOTP（启动协议）：应用于无盘设备
   2. NTP（网络时间协议）：用于网络同步
   3. DHCP（动态主机配置协议）：动态配置IP地址
3. 运行在TCP和UDP协议上：
   1. DNS（域名服务）：用于完成地址查找，邮件转发等工作

### 1.2.3、网络层 

网络层的任务就是选择合适的网间路由和交换节点，确保计算机通信的数据及时传送。*<u>在发送数据时，网络层把运输产生的报文段或用户数据报封装成分组和包进行传送。</u>*在TCP/IP体系结构中，由网络层使用IP协议，因此分组也叫IP数据报，简称数据报。

互联网是由于大量的异构网络通过路由器相互连接起来的。互联网使用的网络层协议是无连接的网际协议和许多路由选择协议，因此互联网的网络层也叫做网际层或者IP层。

### 1.2.4、数据链路层 

数据链路层通常称之为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的来链路层的协议。

在两相邻的节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的节点的链路上传输帧。<u>每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</u>。

在接受数据时，控制信息使接受端知道一个帧从哪个比特开始和到哪个比特结束。

一般的web应用的通信传输流是这样：
![image-20220926090416871](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-1\image-20220926090416871.png)

发送端在层与层之间传输数据时，每经过一层次时被打上一个该层所属的首部信息。反之，接受端在层与层之间传输数据时，每经过一层时会把对应的首部信息去掉。

### 1.2.5、物理层

在物理层上所传送的数据单位是比特。物理层的作用是实现相邻计算机节点之间比特流的透明传输，尽量可能屏蔽掉具体传输介质和物理设备的差异。使其上的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说这个电路好像是看不见的。



### 1.2.6、TCP/IP 协议族

在互联网使用的各种协议中最重要和最著名的就是TCP/IP两个协议。现在人们经常提到的TCP/IP并不一定是单指TCP和IP这两个具体的协议，而往往是表示互联网所使用的整个TCP/IP协议族。

![image-20220926092734157](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-1\image-20220926092734157.png)

互联网协议套件（IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被统称为TCP/IP协议族，简称为TPC/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。

<font color = "red">TCP（传输控制协议）和IP（网际协议）</font>是最先定义的两个核心协议，所以才统称为TCP/IP协议族。

## 1.3、TCP的三次握手四次挥手

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此之间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方信息，如果ip地址、端口号等。

TCP可以看成是一种字节流，它会处理IP层或者以下层的丢包，重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以在TCP头部。

一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。<font color = "red">**<u>*通过三次握手建立一个链接，通过四次挥手来关闭一个链接。*</u>**</font>

<font color = "red">*<u>**当一个链接被建立或者终止的时候，交换的报文段只包含TCP头部，而没有数据。**</u>*</font>



### 1.3.1、TCP报文的头部结构 

TCP报文的头部结构：
![image-20220926094434171](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-1\image-20220926094434171.png)

关于头部结构的几个字段的介绍：

1. 序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，<font color = "red">发起方<font color = "blue"><u>***发送数据时***</u></font>对此进行标记【当发送方发送的是不带数据的ACK时，不会修改seq序号】</font>。

2. 确认序号：**ack序号**，占32位，只有**ACK标志位**（注意和ack序号的区别）为1的时候，确认序号字段才有效，ack = seq+1；

   > 教材介绍：
   >
   > ***确认序号（x+1）表示：已经正确接收到了发送过来的序号到x为止的数据，此时ack的值  x+1 表示——>期望受到对方下一个报文段的第一个数据字节的序号***

3. 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：

   1. ACK：确认序号有效
   2. FIN：释放一个链接
   3. PSH：接收方应该尽快将这个报文交给应用层
   4. RST：重置连接
   5. SYN：发送起一个新的连接
   6. URG：紧急指针有效

   需要注意的是：

   1. 不需要将确认序号ack与标志位中的ACK搞混了
   2. 确认方ack=发起方seq+1，两端配对

   

### 1.3.2、三次握手

三次握手的本质是确认通信双方收发数据的能力。

首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。

于是他给我回信，我若收到了，我便知<font color = "red">**<u>*我的发件能力  和  他的收件能力*</u>**</font>是可以的，并且他的发件能力和我的收件能力是可以。

然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。 

这，就是三次握手，本质就是让双方确认：**<font color = "red">我的发件能力和它的收件能力都是可以的</font>**。

![image-20220926101044631](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-1\image-20220926101044631.png)

1. **第一次握手**：客户端向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN（比如：100），客户端向服务端发送报文；
   **发送的报文段包含：**<font color = "red"><u>SYN标志位（也就是SYN=1）</u></font>、<font color = "blue">序列号seq=100</font>。

   > 来自教材：
   >
   > ***这个报文段不能携带数据，但是需要消耗一个序号。***
   
2. **第二次握手：**服务端受到客户端发送过来的报文后，发现SYN = 1，知道这是一个请求连接，于是将客户端口的起始序号100存起来，并随机生成一个服务端的起始序号（比如：300）；然后服务端给客户端回复一段报文；
   **回复的报文包含：**<font color = "blue"><u>SYN和ACK标志（也就是SYN=1、ACK=1）</u></font>、<font color = "red"><u>序列号seq=300</u></font>、<font color = "red"><u>确认号ack=101（客户端发送过来的序列号+1）</u></font>。

   > 来自教材：
   >
   > ***这个报文段不能携带数据，但是需要消耗一个序号。***
   
3. **第三次握手：**客户端收到服务端回复后发现ACK=1，并且ack序号=101，于是知道服务端已经收到了序列号100的那段报文，服务端期望收到客户端下一个报文段的第一个数据的序号为101；同时发现SYN=1，知道了服务端同意了这次连接，于是将服务端的序号300给存下来。然后客户端再回复一段报文给服务端；
   **回复的报文包含：**<u><font color = "blue">ACK标志位（ACK=1）</font></u>、<u><font color = "red">确认号ack=301（服务端发送过来的序列号+1）</font></u>、<font color = "blue"><u>seq = 101</u></font>（**第一次发送报文是占据一个序列号的，所以这次seq就是从101开始；需要注意的是：当发送不携带数据的ACK报文时，是不占据序列号的，所以后面第一次正式发送数据时的seq序还是101**）。

   

4. 当服务端受到报文后发现ACK=1，并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端通过TCP建立了连接。



### 1.3.3、四次挥手

四次握手的目的是关闭一个连接。

![image-20220926104439388](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-面试题-1\image-20220926104439388.png)

比如客户端初始序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发送FIN报文前总共回复了2000个字节的数据。

1. **第一次挥手：**当客户端的数据都传输完成后，客户端向服务端发出连接释放报文（当然数据没发完毕时候也可以发送连接释放报文并停止发送数据）；
   **释放连接报文包含：**<font color = "red"><u>FIN标志位（FIN=1）</u></font>、<font color = "blue"><u>序列号seq=1101</u></font>（100+1+1000，<font color = "bule">**其中的1是建立连接时占的一个序列号**</font>，100是四次挥手背景中客户端在释放连接之前已经发送的字节大小）；需要注意的是：客户端发送出FIN报文后只是不能发送数据了，但还可以正常接收数据，另外<font color = "bule">**FIN报文即使不携带数据也要占据一个序列号**</font>。

2. **第二次挥手：**服务端收到客户端发的FIN报文后给客户端回复确认报文；
   **确认报文包含：**<font color = "blue">ACK标志位（ACK=1）</font>、<font color = "red">确认号ack=1102（客户端FIN报文序列号1101+1）</font>、<font color = "blue">序列号seq=23000（300+2000）</font>。【~~我感觉这里应该是23001，因为在客户端和服务端建立连接的时候服务端也发送了一次SYN报文，并且客户端也返回ACK报文了，不清楚，查一下书？？？~~，***实际上确实和我想的一样，我下载了个抓包工具实际测试了以下，这里确实应该是23001***】

   这个是我在掘金中的一篇文章中找到的，可以去看一下：[iOS：为什么TCP连接要三次握手，四次挥手](D:\Tyora\md类型笔记统一存放位置\计算机网络\iOS：为什么TCP连接要三次握手，四次挥手)

   
   
   此时服务端处于关闭等待状态，而不是立马给客户端发送FIN报文，这个状态还要持续一段时间。因为服务端可能还有数据没有发送完。
   
   
   
   前两次挥手只能确认从客户端到服务端的连接关闭，而从服务端到客户端的连接还需要第三、四次挥手才能关闭。
   
   
   前两次挥手导致整个TCP处于半关闭状态，即客户端已经没有数据要发送了，但是服务端若要发送数据，客户端仍要接受。
   
   
   
3. **第三次挥手：**
   服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文；
   **报文包含：**<font color = "blue">FIN和ACK标志位（FIN=1，ACK=1）</font>、<font color = "red">确认号和第二次握手一样ack=1102</font>，<font color = "blue">序列号seq=2350（2300+50）</font>。

4. **第四次挥手：**客户端收到服务端发送的FIN报文后，向服务端发出确认报文；
   **确认报文包含：**<font color = "blue">ACK标志位（ACK=1）</font>、<font color = "red">确认号ack=2351</font>、<font color = "blue">序列号seq=1102</font>。
   注意：客户端发出确认报文，确认报文后不是立马释放TCP连接，而是要经过2MSL（最长报文段寿命的2倍时长）后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务结束TCP连接的时间要比客户端更早一些。

### 1.3.4、总结三次握手和四次挥手

1. 标志位：
   1. TCP规定：SYN报文段不能携带数据，但要消耗一个序号
   2. TCP规定：ACK报文段可以携带数据，但如果不携带数据则不必小号序号
   3. TCP规定：即使FIN报文不懈怠数据，也要消耗一个序号。
2. 建立连接和关闭连接时间
   1. 客户端建立连接早，关闭连接迟
   2. 服务端建立连接迟，关闭连接早

## 1.4、常见面试题

### 1.4.1、为什么TCP连接的时候是3次？2次不可 以吗？

因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。
如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。

> 上面介绍的原因和教材中的解释是类似的
>
> 教材的解释：
>
> 第三次握手是为了防止客户端发送的已经失效的连接请求报文段突然又传送到了服务端，从而产生错误
>
> 所谓“已经失效的连接请求报文段”是这样的：客户端发送连接请求，但是这个请求（记作Q）在某个网络节点长时间滞留了，以至于Q在客户端和服务端已经建立TCP连接进行交流并释放连接之后才到达服务端，而服务端收到失效的连接请求报文后又以为是客户端发出一次新的连接请求，于是向客户端发出确认报文，同意建立连接，如果采用两次握手，那么只要服务端发出确认，那么在服务端中新的连接就建立了，由于客户端并没有发出建立连接的请求不会对于服务端的响应做出回应，导致服务端B以为新的连接已经建立，并一直等待客户端发送数据，导致服务端的资源白白浪费；如果使用三次握手会解决这样的问题，因为当服务端接受到Q后，对客户端做出响应，由于服务端收不到客户端的确认，就不会在服务端建立连接。



### 1.4.2、为什么TCP连接的时候是3次，关闭的时候却是4次？

因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。客户端发出FIN报文时只能保证客户端没有数据发送了，服务端还有没有数据发送客户端是不知道的；而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端：“我服务端已经收到你的FIN报文了，但是我服务端还有一些数据没有发送完毕”，等服务端的数据发送完毕之后才能给客户端发送FIN报，所以服务端不能一次性将确认报文和FIN报文发送给客户端，这也是关闭连接需要四次握手的原因。

### 1.4.3、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？

这里同样是需要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没有收到确认ack报文就会重新发送第三次挥手报文，这样报文一去一回最长时间就是2MSL，所以需要等待这么长时间来确认服务端确实已经收到了（并且在服务端重新发送第三次挥手报文到客户端后，客户端会重新启动2MLS计时器）；如果客户端没有2MSL的等待时间，而是在发送完ack报文段后立即释放连接，那么就无法收到服务端重发的第三次握手，客户端也不会再重发送第四次握手，导致服务端无法按照正常的步骤进入CLOSED状态。

> 教材中还补充了另外一种原因：
>
> 防止产生像介绍TCP建立连接为什么是三次而不是两次的时候提到的“已经失效的连接请求报文段 ”出现在本连接中。客户端会在发送完最后一个ACK报文段之后，再次经过2MSL，就可以使本连接持续的时间内所产生的所有报文都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。



### 1.4.4、如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP设有一个保活计时器，客户端如果出现故障，服务第不能一直等待下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2个小时，若这两个小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次，若连续发送10个探测报仍然没有反应，服务器就认为客户端出现了故障，接着就关闭连接。

### 1.4.5、什么是HTTP，HTTP 与 HTTPS 的区别

HTTP是一在计算机世界中专门在两个点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

| 区别     | HTTP                                                        | HTTPS                                                        |
| -------- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 协议     | 运行在TCP之上，明文传输，客户端与服务端都无法验证对方的身份 | 身披SSL外壳的HTTP，运行于SSL之上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP |
| 端口     | 80                                                          | 443                                                          |
| 资源消耗 | 较少                                                        | 由于加密处理会消耗更多的CPU和内存资源                        |
| 开销     | 无需证书                                                    | 需要证书，而证书一般需要向认证机构购买                       |
| 加密机制 | 无                                                          | 共享密钥加密和公开密钥加密并用的混合加密机制                 |
| 安全性   | 弱                                                          | 由于加密机制，安全性更强                                     |



### 1.4.6、常用HTTP状态码

HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。

| 类别 | 原因短语                                                |
| ---- | ------------------------------------------------------- |
| 1XX  | Informational（信息性状态码），接受的请求正在处理       |
| 2XX  | Success（成功状态码），请求正常处理完毕                 |
| 3XX  | Redirection（重定向状态码），需要进行附加操作以完成请求 |
| 4XX  | ClientError（客户端错误状态码）服务器无法处理请求       |
| 5XX  | ServerError（服务端错误状态码）服务器处理请求出错       |

常用HTTP状态码：

| 状态码 | 原因短语                                                     |
| ------ | ------------------------------------------------------------ |
| 2XX    | 成功（这系列表明请求被正常处理了）                           |
| 200    | OK，表示从客户端发送来的请求在服务端被正确处理               |
| 204    | No content，表示请求成功，但响应报文不含实体的主体部分       |
| 206    | Partial Content，进行范围请求成功                            |
| 3XX    | 重定向（表明浏览器要执行特殊处理）                           |
| 301    | moved permanently，永久性重定向，表示资源已经被分配了新的URL |
| 302    | found，临时性重定向，表示资源被分配了新的URL                 |
| 303    | other，表示资源存在着另一个URL，应使用GET方法获取资源（对于301/302/303几乎所有浏览器都会删除报文主体并自动用GET重新请求） |
| 304    | not modify，表示服务器允许访问资源，但请求未满足的情况（与重定向无关） |
| 307    | temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变，向新的地址发出请求 |
| 4XX    | 客户端错误                                                   |
| 400    | bad request，请求报文存在语法错误                            |
| 401    | unauthorized，表示发送的请求需要有通过HTTP认证的信息         |
| 403    | forbidden，表示对请求资源的访问被服务器拒绝，可在实体主题部分返回原因描述 |
| 404    | not found，表示在服务器上没有找到请求的资源                  |
| 5XX    | 服务器错误                                                   |
| 500    | internal server error，表示服务器端在执行请求时发生了错误    |
| 501    | Not Implemented，表示服务器不支持当前请求所需要的某个功能    |
| 503    | service unavailable，表明服务暂时处于超负载或正在停机维护，无法处理请求 |



### 1.4.7、GET和POST区别

GET和POST是HTTP协议中的两种方法。HTTP全称为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。

HTTP协议中定义了浏览器和服务器进行交互的不同方法，基本方法有4中，分别是GET、POST、PUT、DELETE。这四种方法可以理解为了：对服务器资源的查、改、增、删。

1. GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器的资源，不进行修改
2. POTS：向服务器提交数据，这就涉及了数据的更新，也就是更改服务器的数据
3. PUT：英文含义是防止，也就是向服务器中添加新的数据，就是所谓的增
4. DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程。

GET和POST请求的区别是：

1. GET是不安全的，因为在传输的过程中，数据被放在请求的URL中；POST的所有操作对于用户来说都是不可见的。但是这种做法也不是绝对的，大部分人的做法也是按照上面的说法来做的，但是也可以在get请求加上request body，给post请求加上URL参数。
2. GET请求提交的url中的数据最多只能是2048个字节，这个限制是浏览器或者服务器给添加的，http协议并没有对于url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止又人恶意发送请求。POST请求则没有大小限制。
3. GET限制FORM表单的数据集的值必须是ASCII字符；而POST支持整个ISO10646字符集。
4. GET执行效率比POST方法好。GET是form提交的默认方法
5. GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一起发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100continue，浏览器再发送data，服务器响应200 ok（返回数据）。

### 1.4.8、什么是对称加密与非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全的将密钥发送给对方；

而非对象加密是指使用一对非对称密钥，即公钥和私钥，公钥可以所以发布，但是私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来非常的慢。

### 1.4.9、什么是HTTP2

HTTP2可以提高了网页的性能。
在HTTP1中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需要等待档期哪六个请求完成后才能发起请求。

HTTP2中引入了多路复用的技术，这个技术可以只通过一个TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。

### 1.4.10、Session、Cookie和Token的主要区别 

HTTP协议本身是无状态的。什么是无状态的呢？即服务器无法判断用户身份。

**什么是cookie？**

cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。

客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站的时候，浏览器会把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份。

**什么是session？**

session是浏览器和服务器会话过程中，服务器分配的一块存储空间。服务器默认为浏览器在cookie中设置sessionid，浏览器在向服务器请求过程中传输cookie包含sessionid，服务器根据sessionid获取出会话中存储的信息，然后确定会话的身份信息。

**cookie与session区别**

1. 存储位置与安全性：cookie数据存放在客户端上，安全性较差，sessin数据存放在服务器上，安全性相对更高
2. 存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无法此限制。
3. 占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。

**什么是Token？**

Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token应运而生。

Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需携带上这个Token便签来请求数据即可，无需再次带上用户名和密码并与服务器中存储的用户名和密码进行对比。使用Token的目的是：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健状。

Token是在服务器端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么服务端会返回Token给前端。前端可以在每次请求的时候带上Token证明自己的合法地位。

**session与Token的区别**

1. session机制导致存在服务器压力增大、CSRF跨站伪造请求攻击，扩展性不强等问题；
2. session存储在服务端，token存储在客户端
3. token提供认证和授权功能，作为身份认证，token安全性比session好；
4. session这种会话存储方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下），<font color = "gree">或者分布式项目（服务端不止一台电脑，并且有物理隔离限制）（这段话是我加上去的，不确定是否正确）</font>

### 1.4.11、Servlet是线程安全的吗

**Servlet不是线程安全，多线程并发的读写会导致数据不同步的问题。**

解决的办法是尽量不要定义name属性（感觉这里说的name属性是定义在我们自定义的Servlet类内部的成员字段），而是要把name变量分别定义在doGet()和doPost()方法内部。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。

注意：多线程的并发读写Servlet类属性会导致数据不同步。但是如果只是并发的读取属性而不写入，则不存在数据不同步的我呢提。因此Servlet里的只读属性最好定义为final类型的。

### 1.4.12、Servlet接口中有哪些方法及Servlet生命周期探秘

在JavaWeb程序中，Servlet主要负责接受用户请求HttpServletRequest，在doGet()、doPost()方法中做出相应的处理，并将响应HttpServletResponse反馈给用户。Servlet可以设置初始化参数，供Servlet内部使用。

Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：

1. void init(ServletConfig config) throws ServletException 
2. void service(ServletRequest req, ServletResponse resp) 
   throws ServletException, java.io.IOException 
3. void destory()
4. java.lang.String getServletInfo() 
5. ServletConfig getServletConfig()

**生命周期：**

Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化。

请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法。

当服务器关闭或者项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的dostroy()方法。

init方法和destory方法之后执行一次，service客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。

### 1.4.13、如果客户端禁止 cookie 能实现 session还能用吗？

Cookei与Session一般认为是两恶搞独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。

但为什么禁用Cookie就不能得到Session？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了SessionID，也就得不到Session了。

假设用户关闭Cookie的情况下使用Session，其实现途径有以下几种：

1. 手动通过URL传值、隐藏表单传递Session ID
2. 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。