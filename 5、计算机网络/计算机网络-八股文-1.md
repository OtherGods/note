**<u>*这里主要记录的是操作系统、计算机网络、linux、计算机组成原理之类的东西，因为这些东西我没有写笔记，所以不能系统的复习，而是直接对八股文总结。*</u>**

计算机网络八股文来自：

1. 《代码随想录知识星球精华-大厂面试八股文v1.2.pdf》
2. 《JavaGuide面试突击版4.0.pdf》

# 1、代码随想录知识星球精华-大厂面试八股文v1.2.pdf

## 1.1 三次握手四次挥手

**三次握手：服务端先从cloese到listen**
![image-20221003172201542](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003172201542.png)

**为什么需要三次握手**

1. 三次握手可以阻止重复历史连接的初始化（主因）【也就是防止两次握手中出现：某个节点中滞留的  “ 已经失效的连接请求报文段 ”  发送到服务器，而服务器得到响应，白白浪费服务器资源的情况出现】
   防止的过程：

   1. 滞留在某个节点的SYN报文段到先达服务端，服务端返回一个ACK+SYN报文
   2. 客户端收到后根据上下文，判断这是一个历史连接（序列号过期或者超时），那么客户端就会发送RST报文给服务端，表示终止这一次连接

2. 三次握手才可以同步双方的初始序列号

3. 三次握手才可以避免资源浪费

   两次握手会造成消息滞留的情况下，服务器重复接收无用的连接请求SYN报文，而造成重新分配资源

**四次挥手：**

![image-20221003180844613](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003180844613.png)

**为什么需要四次挥手**

关闭连接时，客户端发送FIN报文，表示其不再发送数据，但是还可以接受数据，客户端收到FIN报文，先回一个ACK应答报文，服务端可能还需要数据。

服务端收到FIN报文，先回一个ACK应答报文，服务端可能还需要处理和发送，等到其不再发送数据时，才会发送FIN报文给客户端表示同意关闭连接。

从上面的过程可以知道：

1. 服务端通常需要等待数据发送和处理，所以服务端的ACK和FIN一般都会分开发送，从而比三次握手多了一次
2. 第一次ACK应答报文可以省略，因为下一个报文携带了ACK信息，ACK是否出现取决于延迟确认特性；
   延迟确认：即接收方收到包后，如果在那时没有内容回复给发送方，则延迟一段时间再确认，加入在这个时间范围内刚好有数据需要传输，则和确认包一起回复，这种也被称之为数据捎带。延迟确认只是减轻网络负担，未必可以提升网络性能，有些情况下反而会影响性能。

**为什么TIME_WAIT等待的时间是2MSL？** *==为了确保被关闭方正常接收到了第二次ACK==*

1. MSL是报文最大生存时间，它是报文在网络上存在的最长时间，超过这个时间报文将被丢弃
2. 等待MSL两倍：网络中可能存在发送方的数据包，当这些发送方的数据包被接收方处理又会向对方发送响应，所以一来一回需要等待两倍的时间
3. 2MSL是的时间是从客户端接收到FIN后发送ACK开始计时的。
   在TIME-WAIT时间内，因为客户端的ACK没有传输到服务端，这个时候服务端就会从新发送第三次握手（我把这次握手称之为第五次握手），所以2MSL是第四次握手+第五次握手的时间；
   如果客户端会在第2MSL的时候再次收到了服务端重发的FIN报文，那么2MSL时间将会重新计时间。

**为什么需要TIME_WAIT？**

主动发起关闭连接的一方，才会有TIME_WAIT状态，需要这个状态是因为：

1. 防止具有相同[四元组]的[旧]数据包被收到；
   有相同端口的TCP连接被复用之后，被延迟的相同的四元组的数据包抵达了客户端，那么客户是有可能正常接受这个过期的报文，这就会产生数据错乱等严重的问题。

   经过2MSL的时间，足以让发送方和接收方本次连接中在网路中传递的数据包都自然消失，再次出现的数据包一定是新建立连接所产生的。

2. 保证[被动关闭连接]的一方能够正确的被关闭，即保证最后一次握手能够成功。

**TIME_WAIT过长会有什么危害？**

1. 内存资源占用
2. 对端口资源的占用，以恶搞TCP连接至少消耗一个本地端口

## 1.2 HTTP/HTTPS

### 1.2.1 HTTP的特性

1. 简单
   基本报文格式为header+body，头部信息也是key-value简单文本的形式，易于理解
2. 灵活和易于扩展
   1. HTTP协议里的各种请求方法、URI\URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩展
   2. HTTP工作在应用层（OSI第七层），下层可以随意变化
   3. HTTPS就是在HTTP与TCP之间增加了SSL/TSL安全传输层，HTTP/3把TCP换成了基于UDP的QUIC
3. 无状态、明文传输、不安全
   1. 无状态：服务端不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担。但是它在完成有关联性的操作时会变的非常麻烦
   2. 明文传输：传输过程中的信息，是可方便阅读的，通过浏览器的F12控制台或抓包都可以直接肉眼查看，为我们给调试带来了极大的遍历，但信息透明，容易被窃取
   3. 不安全
      1. 通信使用明文（不加密），内容可能被窃听
      2. 不验证通信方的身份，因此有可能遭遇到伪装
      3. 无法证明报文的完整性，所以可能已经遭受到篡改；
         可以使用HTTPS的方式解决，也就是通过引入SSL/TSL层。

### 1.2.2 HTTP与HTTPS的区别

协议：通信双方需要遵守的统一规则

1. HTTP：超文本传输协议
2. HTTPS：超文本安全传输协议
3. SSL：安全套接字
4. TSL：安全传输层协议
5. HTTPS = HTTP + SSL/TSL

### 1.2.3 HTTPS

HTTP：以明文的方式在网络中传输数据

HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL/TSL安全协议，使得报文能够加密传输。

HTTPS在TCP三次握手之后，还需要进行SSL/TSL的握手过程，才可以进入加密报文传输。

HTTP的端口号是80，HTTPS的端口号是443.

HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信赖的。

**特点：**

1. 信息加密：交互信息无法被窃取
2. 校验机制（通过数字签名）：无法篡改通信内容，篡改了就不能正常显示
3. 身份证书（通过数字证书）：证明报文的完整

**优点：**

1. 可以在数据传输过程中使用私钥加密，安全性更高
2. 可认证用户和服务器，确保数据发送到正确的用户和服务器

**缺点：**

1. 握手阶段延时较高：在会话之前还需要进行SSL握手
2. 部署成本高：需要购买CA证书；需要加密解密计算，占用CPU资源，需要服务器配置或数目较高

**加密方式：**

1. 对称加密：只使用一个密钥，运算速度较快，密钥必须保密，无法做到安全的密钥交换

2. 非对称加密：使用公钥和私钥，公钥可以任意分发，私钥保密，解决密钥交换问题，但是速度较慢

3. 混合加密：使用对称加密+非对称加密，实现信息的机密性，解决窃听风险
   HTTPS采用混合加密的方式。

   

   HTTPS混合加密的实际使用——>

   1. 通信建立前：采用非对称的方式交换[会话密钥]，后续不再使用非对称加密
   2. 通信过程中：全部采用对称加密的方式[会话密钥]方式，加密明文数据

4. 验证流程

   1. 客户端发起HTTP请求，连接到服务端
   2. 服务端将自己的信息以数字证书的形式返回给客户端（数字证书包含：公钥、网站地址、证书颁发机构、失效日期等）
   3. 验证证书合法性
      客户端接收到服务端的响应后会先验证证书的合法性（地址是否一致，是否过期等）
   4. 生成随机密码（RSA签名）
      验证通过或者用户接受了不受信任的证书，浏览器会生成一个随机的对称密钥（session key），并用服务端发送的数字证书中的公钥加密，让服务端用自己的私钥解密，解密后用这个对称密钥进行传输
   5. 验证好服务端的身份后，客户端生成一个对称加密的算法和对应的密钥，以服务端的公钥加密后发送给服务端（这是代码随想录中的写法，但是我感觉d和e是同一回事）

5. 数字证书的相关信息

   1. 摘要算法用来实现完整性

   2. 数字签名是私钥对摘要的加密
      可以用来防止身份伪造

   3. 公钥的分发需要使用数字证书
      可以用来做身份验证，必须由CA的信任链来认证，否则就是不可信的

   4. 证书体系中，ROOT CA最大，也叫根证书

      相当于是证明自己是自己，必须相信，如果不相信，这整个信任链就走不下去了。上网的时候只要对方的服务器有证书，就可以顺一直找到根证书来确定是否可信。

   5. 如果遇到伪造CA
      就会将这个CA加入CRL证书吊销列表中，终止信任。

6. 数字证书的获取过程

   1. 根据服务器公钥、证书颁发者、证书用途（也就是服务器提供的服务）、证书过期时间等经过哈希计算得到H1；
   2. 将H1由CA私钥加密生成数字证书
   3. 客户端收到数字证书后经过同样哈希计算得到值H2
   4. 经嵌入在浏览器或者操作系统的CA公钥解密数字证书，对比H1、H2相等验证服务器真实性，取出服务器公钥

7. 输入URL到显示的过程

   1. 相关概念

      1. URL：统一资源定位符（俗称网址）
         格式：Scheme：//host.domain:port/path/filename

         1. Scheme：定义因特网服务类型http/https/ftp/file
         2. Host：定义域主机（http默认为www）
         3. Domain：因特网域名，例如baidu.com
         4. Port：主机上端口号（http：80，https：443）
         5. Path：服务器上的路径（若圣罗，则文档必位于网站根目录）
         6. Filename：文档/资源名称

      2. DNS：域名解析服务器
         **概念：**

         1. DNS协议用来将域名转换为IP地址，也可以将IP地址转换为相应的域名地址
         2. DNS：面向用户，IP：面向主机
         3. 域名服务主要是基于UDP实现的，服务器端口号为53

         **解析过程：**

         1. 浏览器检查浏览器自身的DNS缓存中，是否有域名对应的DNS缓存

         2. 查看系统的hosts文件是否有域名对应的IP地址

         3. 浏览器发起DNS系统调用，向本地配置的首选DNS服务器发起域名解析请求（通过UDP协议向DNS的53端口发起请求）

         4. ⾸先，请求会在运营商DNS服务器（本地服务器）上进⾏请求，若找到对应的条⽬，且没有过期，则解析成 
            功；否则，进⼊5

         5. 运营商DNS服务器，根据解析请求，迭代查询，⾸先找到根域名服务器IP地址，然后找到根域的DNS地址，发 
            送请求

         6. 根域服务器收到请求后，根据域名，返回对应的顶级域服务器IP地址，并返回给运营商DNS服务器

         7. 运营商DNS服务器收到根域名服务器传回来的顶级域名服务器IP地址后，向顶级域名服务器发送请求

         8. 顶级域名服务器收到请求后，返回该域名对应的权威域名服务器IP地址，并返回给运营商DNS服务器

         9. 运营商DNS服务器获得权威域名服务器的响应信息后，返回给请求的主机，DNS解析完成

            DNS主要通过UDP通信，报文结构分为头部header、查询部分、应答部分；例如查询百度对应IP

            ![image-20221003201056798](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003201056798.png)

      3. IP：互联网上的每个网络和每台主机分配的一个逻辑地址

### 1.2.4 HTTP请求

HTTP请求为DNS解析获得IP地址后，通过TCP三次握手，HTTP请求相应信息，关闭TCP连接

1. 当三次握手之后，发送HTTP请求报文；
   其主要由请求行、请求头、请求体构成。
   1. 请求行——>请求方法；URL；协议版本号
      **请求⽅法**： GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE 
      **URL**： <协议>：//<主机>：<端⼝>/<路径>？<参数>
      **协议版本号**： HTTP版本号
      例如：POST /chapter17/user.html HTTP/1.1
   2. 请求头——>包含请求的附加信息，有key：value组成
   3. 请求体
      承载多个请求参数的数据。含回车、换行和请求数据
2. 服务器处理请求并返回HTTP报文
   响应报文主要由响应行、响应头、响应主体构成。
   常见状态码及描述：
   1. 200：客户端请求成功
   2. 206：服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求又来指示客户端期望得到的范围
   3. 301：永久重定向：该资源已经被移动到新位置，将来对该资源的访问都要使用本响应返回的若干个URL之一
   4. 302：临时重定向，亲亲贵的资源现在临时从不同的URI中获得
   5. 304：如果客户端发送⼀个待条件的GET请求并且该请求以经被允许，⽽⽂档内容未被改变，则返回304,该响应不包含包体（即可直接使⽤缓存）
   6. 400：请求报文语法有误，服务器无法识别
   7. 401：请求需要认证
   8. 403：请求的对应资源禁止被访问
   9. 413：请求体过长
   10. 404服务器无法找到对应资源
   11. 500：服务器内部错误
   12. 503：服务器正忙

### <font color = "red" size=5>1.2.5 整个过程</font>

1. 首先，我们在浏览器地址栏中，输入要查找页面的URL，按下Entry
2. 浏览器依次在：浏览器缓存——>>系统缓存——>>路由器缓存  中去寻找匹配的URL，若有，就会直接在屏幕中显示出页面内容。若没有，则跳到第三步
3. 发送HTTP请求前，浏览器需要进行域名解析（即DNS解析），以获取相应的IP地址；（浏览器DNS缓存、路由器缓存、DNS缓存）
4. 获取到IP地址之后，浏览器向服务器发起TCP连接，与浏览器建立TCP三次握手
5. 握手成功之后，浏览器就会向服务器发送HTTP请求，来请求服务器端的数据包
6. 服务器处理从浏览器端收到的请求，接着将数据返回给浏览器
7. 浏览器收到HTTP响应
8. 查询状态，状态成功则进行下一步，不成功则弹出相应指示
9. 再读取页面内容、进行浏览器渲染、解析HTML源码（生成DOM树、解析CSS样式、处理JS交互，客户端和服务器交互）进行展示
10. 关闭TCP连接（四次挥手）

![image-20221003215233167](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003215233167.png)



### 1.2.6 HTTP请求方法

1. GET：申请获取资源，不对服务器产生影响
2. POST：客户端向服务器提交数据。会影响服务器，服务器可能动态创建新的资源或更新原有资源。
3. HEAD：类似GET，仅要求服务器返回头部信息
4. PUT：上传某个资源
5. DELETE：删除某个资源
6. TRANCE：用于测试。要求目标服务器返回原始的HTTP请求内容
7. CONNECT：用于代理服务器
8. OPYION：查询服务器对特定URL支持的请求方法

### 1.2.7 GET和POST的区别

|              | GET             | POST                        |
| ------------ | --------------- | --------------------------- |
| 是否需要建立TCP连接  | 是               | 是                           |
| 是否幂等         | 是               | 否                           |
| 是否会被浏览器主动缓存  | 是               | 否                           |
| 请求的数据保存存储在哪里 | url路径中拼接        | 可以在url路径中，也可以在请求体中          |
| 请求的数据有长度限制吗  | 有，由浏览器和服务器限制    | 有，由于服务器限制，但通常比get请求可以传输的数据多 |
| TCP包         | 在TCP连接中传递一个TCP包 | 在TCP连接中传递两个TCP包             |


**1、GET和POST都是HTTP请求方法**

1. GET：申请获取资源，不对服务器产生影响
2. POST：客户端向服务器提交数据，会影响服务器，服务器可能动态创建新的资源或者更新原有资源
   请求数据：若为GET，则请求数据为空；其主要是在POST中进行使用，使用于需要填表单（FORM）场景

**2、请求报文**

GET请求报文：
![image-20221003220111302](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003220111302.png)
请求方法用的是GET请求，URL为/search/user?q=JakeWharton，协议为HTTP1.1。

POST请求报文：
![image-20221003220136054](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003220136054.png)

请求行中请求方法为POST，URL为空，协议版本为HTTP1.1

与GET不同在于它的请求参数是为位于请求数据中，最后一行name……为请求数据，且，请求数据和请求头之间必须空出一行



安全+幂等
安全：HTTP协议中，安去哪是指请求方法不会普坏服务器上的资源
**幂等：多次执行相同的操作，结果都相同**

GET为安全幂等的，因为它为只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的

**3、特点**

1. GET
   1. GET会被浏览器主动缓存的，如果下一次传输的数据相同，那么就会返回缓存中的内容，以求更快的展示数据
   2. GET的URL有一般都有长度限制，但是需要注意HTTP协议中并未规定GET请求的长度。这个长度限制主要是由浏览器和Web服务器所决定的，摈并且各个浏览器对长度的限制也各不相同
   3. GET方法只产生一个TCP数据包，浏览器会把请求头和请求数据一并发送出去，服务器响应200 ok（返回数据）。
2. POST
   1. POST不安全且不幂等；因为是新增或者提交数据的操作，会修改服务器上的资源且多次提交的数据就会创建多个资源
   2. POST方法的请求信息放置在请求数据中，所以请求信息没有长度限制
   3. POST会产生两个TCP数据包，浏览器会先将请求头发送给服务器，待浏览器响应100 continue，浏览器再发送请求数据，服务器响应200 ok（返回数据）

**4、区别**

实际上本质都是一样的，并无区别

1. 都是HTTP请求协议的请求方法，而HTTP又是基于TCP/IP的关于数据如何在万维网中如何通信的协议，所以GET/POST实际上都是TCP连接
2. 由于HTTP的规定以及浏览器/服务器的限制，导致它们在应用过程中可能会有所不同



### 1.2.8 HTTP keep-alive

1. 重用连接机制

2. 使用方法
   **在请求头中加入Connection：keep-alive**
   通知对应在该请求响应完成之后不要关闭，下一次继续使用。
   问：HTTP能不能一次连接多次请求，不等后端返回？
   答：可以，HTTP本质是使用socket，写入TCP缓冲是可以连接多次的。

   **HTTP无状态**

   即使第一次和服务器连接并且登陆成功之后，第二次请求服务器仍然不知道当前求情的是哪个用户



### 1.2.9 Cookie和Session

1. Cookie
   作用：
   1. 在第一次登陆服务器之后，返回一些数据（cookie）给浏览器
   2. 浏览器将数据保存在本地
   3. 两次发送请求数据时，自动把上一次请求存储的cookie发送给服务器
   4. 服务器通过该数据判断用户

   特点：

   ​		可存储的数据量优先，一般不会超过4KB

2. Session
   Session的作用与Cookie类似，都是为了存储用户相关的信息
   区别：

   1. Cookie存储在本地浏览器
   2. Session存储在服务器

   优势：
           数据存储在服务器更加安全
   缺陷：
   ​        会占用服务器资源



## 1.3 TCP与UDP

### 1.3.1 TCP和UDP的区别

| 区别         | TCP（传输控制协议）                                          | UDP（用户数据报协议）                                        |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接         | 面向连接，在传输前需要三次握手建立连接                       | 不需要连接，即可传输数据                                     |
| 服务形式     | TCP只能一对一，点对点服务                                    | UDP支持一对一、一对多、多对多通信                            |
| 可靠性       | TCP保证数据可靠交付，拥有确认应答和重传机制，无重复、不丢失、按序到达 | 尽可能交付，不保证可靠性                                     |
| 连接控制机制 | 拥有流量控制、拥塞控制，保证传输安全性等                     | UDP在网络拥堵的情况下不会降低发送的速率                      |
| 首部大小     | TCP首部长度不适用选项字段时是20个字节，使用选项字段长度增加（可变） | UDP首部固定8个字节                                           |
| 传输方式     | TCP是基于字节流的，没有边界，但是保证传输顺序和可靠性        | UDP继承了IP层特性，基于数据包，有边界可能出现乱序和丢包      |
| 分片方式     | TCP数据大于MSS时会在TCP层将数据进行分片传输，到达目的地后同样在传输层进行合并，如果有某个片段丢失则只需要重传丢失的分片即可 | UDP数据大于MTU时会在IP层分片，同样也在目的IP层合并，如果某个IP分层丢失，则需要安经所有分片都进行重传，开销大 |

### 1.3.2 为什么要三次握手

1. 避免历史连接以及服务端资源浪费如果是两次握⼿，那么当客户端接收到服务端请求和确认报⽂后TCP连接建⽴。如果此时⽹络状态拥塞，客户端早期发送的请求连接报⽂未到达服务端⽽发⽣传。后正常建⽴连接，传输完毕后断开连接。
   但断开后早期的报⽂⼜被服务端所接收，那么服务端会误认为客户端再次发起连接，因此向客户端返回确认及请求连接报⽂，导致错误发⽣。并且由于此时客户端已断开，服务端⽆法收到客户端进⼀步的报⽂信息，造成服务端为为⽆效连接分配资源，造成浪费。
2. 同步双方序列号
   TCP中序列号和确认应答机制保障了传输的可靠性，因此当第二次握手时服务端向客户端发送请求报文时，需要客户端返回确认报文才保障双方序列号被可靠同步。如果仅有两次握手，只保证了客户端序列号的可靠性。

### 1.3.3 SYN攻击

1. 原理
   攻击者伪造不同IP地址的SYN报文请求连接，服务端收到连接请求后分配资源，回复ACK+SYN包，但是由于IP地址是伪造的，无法收到回应，久而久之造成服务端办理按揭队列被沾满，无法正常工作
2. 避免方式
   1. 修改半连接队列大小
      使服务端能够容纳更多半连接，此外还可以修改服务端超时重传次数，使服务端尽早丢弃无用连接
   2. 正常服务端行为是收到客户端SYN报文后将其加入到内核半连接队列，接着发送ACK+SYN报文给客户端，当收到客户端ACK报文后把连接从半连接队列移到accept队列。
      当办理按揭队列满时，启动syn cooie，后续队列不进入半连接队列，而是计算一个cookie值，作为请求报文序列号发送二哥i客户端，如果服务端收到客户端确认保温，会检查ack包合法性，如果合法直接加入到accept队列

### 1.3.4 为什么需要TIME_WAIT状态

**==确保第二次ACK可以被被关闭方成功接收到，如果被关闭方在1MSL中没有成功接收到第二个ACK，会重新发送第二次FIN==**。

1. 防止旧连接的数据包
   TIME_WAIT状态持续时间为2MSL，经过2MSL时间，旧连接的所有报文都在网络中小时，防止其对新连接的建立以及传输过程造成影响
2. 保持连接正常关闭
   当服务端发送终止连接FIN报文时，进入LAST_ACK状态，等待客户端的确认报文.
   如果FIN报文未正确到达客户，或者客户端的确认报文未正常传输到服务端，此时服务端无法正常关闭连接，因此需要对于FIN报文重传，假如客户端没有TIME——wait状态，直接进入closed状态，那么服务端永远无法收到客户端确认报文，因此无法正常关闭。

### 1.3.5 TCP保活机制

1. 概念：在一个定义的时间段内TCP连接无任何活动时，会启动TCP保活机制每隔一定时间间隔发送一个探测报文，等待响应
2. 机制：
   1. 对端正常响应，重置保活时间
   2. 对端程序崩溃，响应一个RTS报文，将TCP连接重置
   3. 保活报文不可达，等待到保活探测次数后关闭连接
3. TCP为啥还需要流量控制
   1. 由于通讯双方网速不同，通讯任意一方发送过快都会导致对方详细处理不过来，所以就需要把数据放到缓冲区中
   2. 如果缓冲区满了，发送方还在疯狂发送，那么接收方只能把数据包丢失，因此我们需要控制发送速率
   3. 我们缓冲区剩余大小称之为接受窗口，用变量win表示，如果win=0，则发送方停止发送

### 1.3.6 TCP拥塞控制

1. 慢开始和拥塞避免
   慢开始：TCP连接刚刚尽力，一点一点的提速，试探一下网络承受能力，以免扰乱了网络通信的秩序，慢慢的翻倍提速。
   一开始是1，每过一个RTT往返时间之后，乘2，有一个慢启动的阈值，如果超过了这个阈值会进入一个拥塞避免的阶段，然后从乘2变成加1的递增。
   如果遇到网络拥塞的时候，拥塞窗口会直接变成1，然后拥塞窗口的阈值会降低为当前阈值的一般，然后重新开始慢启动。
   但是直接降为1，对传输层会有很大的影响，就有后续的优化，快速重传和快速恢复。
2. 快速重传和快速恢复
   当收到3个重复的ACK的时候执行快重传，将当前窗口的值降为原来的一半。
   阈值也降低为原来的一般，然后每次加1递增，把需要重传的都重传完之后，就进入拥塞避免的阶段，每个RTT加1，然后进入正常流程。

## 1.4 滑动窗口

### 1.4.1 什么是滑动窗口

![image-20221003233540391](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003233540391.png)

TCP每发送一个数据，都需要一个应答，然后继续发送，这样为每个数据包都进行确认应答，***缺点是：数据往返时间越长，网络吞吐量越低***。

引入窗口即使往返时间越长，也不会降低网络通信效率。

可以指定窗口大小，***窗口大小就是无需等待确认应答，继续发送数据的最大值***。

窗口实现就是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已经发送的数据。如果按期收到确认应答，此数据就可以从缓存区清除。

图中的ACK 600确认应答报文丢失也没有关系，因为可以通过下一次确认应答进行确认，只要发送方接收到了ACK 700确认应答，这就意味着700之前的所有数据[接收方]都收到了。这个模式就叫做 **累计确认或者累计应答**。

### 1.4.2 什么决定窗口大小

TCP头部有一个字段叫做window，窗口大小。

**这个字段是接收端告诉发送端自己有多少缓冲区可以接收数据**。于是发送端可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

通常窗口大小是由于接收方的窗口大小来决定的。

### 1.4.3 发送方的滑动窗口

![image-20221004084810666](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004084810666.png)

1. # 1是已经发送并收到ACK确认的数据：1~31字节
2. # 2是已经发送但尚未收到ACK确认的数据：32~45字节
3. # 3是未发送但总大小在接收方处理范围内（接收方还有空间）：46到51字节
4. # 4是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后

![image-20221004085148348](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004085148348.png)

数据全部发送以后，可用窗口大小为0，在没有收到ACK确认应答之前无法继续发送数据。

![image-20221004085243603](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004085243603.png)

在发送方收到接收方成功接收32-36ACK应答后，如果窗口大小不变，则滑动窗口先后移动5个字节，那么52-56变成可用窗口，可以继续发送数据。

### 1.4.4 程序是如何表示发送方的四个部分的

![image-20221004090044410](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004090044410.png)

1. SND.WND：表示发送窗口的大小（大小是由接收方指定的）
2. SUN.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是#2的第一个字节
3. SUN.NXT：也是一个绝对指针，他指向未发送但可发送范围的第一个字节的序列号，也就是#3的第一个字节
4. 指向#4的第一个字节是个相对指针，它需要SND.UNA指针加上SND.WND大小的偏移量，就可以指向#4的第一个字节了。

可用窗口大小 = 发送窗口 - 已发送未确定 = SND.WND - (SND.NXT - SND.UNA)

已发送未确认： = SND.NXT - SND.UNA

### 1.4.5 接收方滑动窗口

![image-20221004090138645](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004090138645.png)

1. # 1 + # 2是已经成功节后并确认的数据（等待应用进程读取）
2. # 3是未收到但可以接受的数据
3. # 4未收到数据并不刻意接受的数据

**三部分两个指针：**

1. RCV.WND：表示接收窗口的大小，它会通告给发送方
2. RCV.NXT：是一个指针，它指向期望从发送发发送过来的下一个数据字节的序列号，也就是#3的第一个字节
3. 指向#4的第一个字节是个相对指针，它只需要RCV.NXT指针加上RCV.WND大小的偏移量，就可以指向#4的第一个字节了



## 1.5 拥塞控制

拥塞控制通过拥塞窗口来防止过多的数据注入网络，使得网络中的路由器或者链路过载。

1. 拥塞窗口cwnd是发送方维护的一个状态变量，根据网络拥塞程序而变化
2. 发送窗口的值是swnd=min(cwnd , rwnd)，也就是拥塞窗口和接受窗口中的最小值
3. 网络中没有出现拥塞，cwns增大，出现拥塞，cwnd减小

其实只要发送方没有在规定时间内接受到ACK应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。

拥塞控制的算法：

1. 慢启动
   慢启动的算法记住一个规则就行：**当发送方每收到一个ACK，拥塞窗口cwnd的大小就会加1**。
   慢启动算法，发包的个数是指数性的增长，1—>2—>4—>8—>2^n^

   有一个慢启动门限ssthresh状态变量

   1. 当cwnd < ssthresh时，使用慢启动算法
   2. 当cwnd >= ssthresh时，就会使用拥塞避免算法

2. 拥塞避免
   一般来说ssthresh的大小是65526字节。超过后会进入拥塞避免算法。
   那么进入拥塞避免算法后，它的规则是：**每当收到一个ACK时，cwnd增加1/cwnd**。
   **拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长**，还是增长阶段，但是增长速度缓慢了一些。
   网络就会慢慢进入了拥塞的状况了，于是就会出现丢包的现象，这时就需要对丢失的数据包进行重传。
   当触发了重传机制，也就进入了拥塞算法。

3. 拥塞发生
   发生拥塞，进行数据重传

   1. 超时重传
      发生超时重传的发生算法：这个时候，ssthresh和cwnd的值会发生变化
      1. ssthresh设为cwnd/2
      2. cwnd重置为1
         ![image-20221004093403980](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004093403980.png)
   2. 快速重传
      TCP认为这种情况不严重，因为大部分没丢，只丢失了一小部分，则ssthresh和cwnd变化如下：
      1. cwnd = cwnd/2，也就是设置为原来的一般
      2. ssthresh = cwnd
      3. 进入快速恢复算法

4. 快速恢复
   ![image-20221004093602043](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004093602043.png)
   快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，还能收到3个重复ACK说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。
   进入快速恢复：

   1. 拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
   2. 传丢失的数据包；
   3. 如果再收到复的 ACK，那么 cwnd 增加 1；
   4. 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说 
       明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊ 
       拥塞避免状态；



## 1.6 web页请求

### 1.6.1 Web的页面请求流程以及涉及到的技术

<font color = "red">【浏览器地址栏输入URL回车后涉及到的流程】</font>

1. 查找DNS缓存

   1. 先查找浏览器DNS缓存，看是否存放目标网络的IP地址
   2. 如果不在浏览器缓存，则浏览器对操作系统发起系统调用，查询操作系统本地缓存
   3. 如果不在操作系统本地缓存，则浏览器会查询阈值相连的路由器缓存
   4. 如果不在路由器缓存，则浏览器会检查ISP【本地通信服务商】缓存

   若以上四步都没有查询到目标网络的IP地址，则发起DNS查询

2. 发起DNS查询
   判断DNS服务器和我们的主机是否在同一子网内

   1. 在同一子网内，则采用ARP地址解析协议对DNS服务器进行ARP查询
   2. 不再同一子网，则采用ARP地址解析协议对默认网关进行查询

   若此时还查询不到IP地址，则根据拿到DNS服务器或默认网关的IP地址，继续进行DNS请求；使用53端口先向本地DNS服务器发送UDP请求包，此处一般使用UDP协议
   **没有查询到 IP 地址**
   则他会发送一个递归查询请求，一层一层向高层DNS服务器查询，知道查询到IP地址，则将结果返回

3. 封装TCP数据包
   拿到IP地址后，根据URL中的端口可知端口号【HTTP：80，HTTPS：443】，一般会先尝试建立HTTP连接；
   **准备TCP数据包：**
        步骤

   1. 将应用层传递下来的实际数据，在传输层添加TCP首部
   2. 将传输层传下来的数据在网络层添加IP首部
   3. 将网络层传输下来的数据，在数据链路层添加以太首部，并在传输介质中进行传输

4. 浏览器与目标服务器建立TCP连接
   经过上述DNS和ARP查询流程后，浏览器会收到目标服务器的IP和MAC地址，经过三次握手后建立TCP连接；

   1. 使用HTTP协议：浏览器发送请求到服务器，如果使用的是HTTP协议，则服务器直接返回结果
   2. 使用HTTPS协议：
      如果不是HTTP协议，则服务器会返回一个以3开头的重定向消息，告诉浏览器使用HTTPS，IP没有变，只是端口号变成443；完成四次挥手。
      重新建立TCP连接，将端口号修改为443，同时沟通好双方的使用的认证算法、加密和解密算法，在此次过程中也会检查对方的CA证书，采用SSL加密技术进行传输数据

5. 浏览器发送HTTP/HTTPS请求到web服务器
   主要使用两种请求方式：

   1. 浏览器发送get请求，要求目标服务器提供输入的网页；
   2. 浏览器发送post请求，表示填写的是表单

6. 服务器处理请求并发挥一个响应
   服务器会从浏览器接受请求并将其传递给请求处理程序并响应

7. 服务器发回一个HTTP响应
   一般响应包含：请求的网页以及状态码，压缩类型，如何缓存的页面，设置cookie

8. 浏览器显示HTML页面

   1. 渲染HTML骨架，涉及到AJAX技术
   2. 渲染HTML标记并发送GET请求以获取网页上的其他元素【图像、CSS样式、JS文件等】，该静态文件一般由浏览器缓存，再次访问，不用重新请求
   3. 最后会看到请求色彩斑斓的网页

### 1.6.2 web页面请求涉及到的问题

1. DNS服务器
   1. 单点故障：
      如果DNS服务器崩溃，那么整个网络随之瘫痪。通信容量，单个DNS服务器不得不处理所有的DNS擦汗寻，这种查询币别可能是上百万上千万几倍，一台服务器很难满足
   2. 远距离集中式数据库：
      单个DNS服务器不可能临近所有的用户，假设在美国的DNS服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥塞的链路，造成严重的时延
   3. 维护：
      维护成本大，而且还需要频繁更新
2. DNS查询的三种方式
   1. 递归查询
      DNS客户端要求DNS服务器将所有请求的资源记录响应客户端，或者如果解析器无法找到该记录，则返回错误消息
   2. 迭代查询
      如果所查询的DNS服务器与查询名称不匹配，则将其返回较低级别域名空间具有权威性的DNS服务器的引用。然后，DNS客户端将对引用地址进行擦汗寻。此国还曾继续使用查询连中的其他DNS服务器，直至发生错误或者超时为止
   3. 非递归查询
      当DNS解析器客户端查询DNS服务器以获取其有权访问的记录时通常会进行此查询，因为其对该记录具有权威性，或者该记录存在于其缓存内。
      DNS服务器通常会缓存DNS记录，查询到来后能够直接返回缓存结果，以防止更多带宽消耗和上有服务器上的负载。
3. HTTPS三次握手流程
   ![image-20221004102116618](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221004102116618.png)

## 1.7 RPC远端过程调用







# 2、JavaGuide面试突击版4.0.pdf

## 2.1 OSI七层模型是什么？每一层的作用是什么？

1. 应用层：为计算机用户提供服务
2. 表示层：数据处理（编解码、加密解密、压缩解压缩）
3. 会话层：管理（建立、维护、重连）应用程序之间的会话
4. 传输层：为两台主机进程之间的通信提供通信的数据传输服务
5. 网络层：路由和寻址（决定数据在网络的游走路径）
6. 数据链路层：帧编码和错误纠正控制
7. 物理层：透明的传输比特流

每一层都使用下一层提供的功能，，比如：传输层要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里。

OSI七层体系结构概念清楚，理论完全，但是比较复杂并且不实用，并且有些功能在多个层中重复出现

## 2.2 TCP/IP四层模型是什么？每一层的作用是什么？

是目前被广泛采用的一种模型，我们可以将TCP/IP模型看作是OSI七层模型的精简版本，由于以下4层组成：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

需要注意的是，我们并不能将TCP/IP四层模型和OSI七层模型完全精确的匹配起来，不过可以简单的将两者对应起来，如下图所示：
![image-20221003091642169](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003091642169.png)

### 2.2.1 应用层

应用层位于传输层之上，只要提供两个终端设备上的应用程序之间信息交换的服务，它***定义了信息交换的格式***，消息会交给下一层传输层来传输。我们把应用层交互的数据单元称为报文。

应用层***定义了网络通信的规则***，对于不同的网络应用需要不同的应用层协议，在互联网中应用层协议很多，如支持Web应用的HTTP协议，支持电子邮件的SMTP协议等等。

### 2.2.2 传输层

传输层的主要任务就是***负责向两台终端设备进程之间的通信提供通用的数据传输服务***。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

运输层主要使用以下两种协议：

1. 传输控制协议TCP：提供面向连接的，可靠的数据传输服务
2. 由用户数据协议UDP：提供无连接的，尽最大努力的数据传输服务（不是保证数据传输的可靠性）

### 2.2.3 网络层

网络层***负责为网上不同主机的分组交换提供通信服务***。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫，IP数据报，简称数据报。

注意：不要把运输层的  “ 用户数据报UDP ”  和  “ IP数据报 ”  弄混。

网络层的还有一个任务是选择合适的路由，使用源主机运输层所传下来的分组，能够通过网络层中的路由器找到目的主机。

这里强调指出：网络层中的“网络”儿子已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。

互联网是由大量的异构网络通过路由器相互连接起来的。互联网使用的王略协议是无连接的网路协议和许多路由选择协议，因此网络层也叫做网际层或IP层。

### 2.2.4 网络接口层

网络接口层可以看作是数据链路层和物理层的合体

1. 数据链路层：将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送成帧。每一帧包括数据和必要的控制信息
2. 物理层：实现相邻计算机之间比特流的透明传输，尽可能屏蔽具体传输介质和窝里设备之间的差异



### 2.2.5 总结

1. 网络层协议：
   1. HTTP协议：超文本传输协议，网页浏览常用的协议
   2. DHCP协议：动态主机配置
   3. DNS系统原理：域名系统
   4. FTP协议：文件传输协议
   5. Telenet协议：远程登陆协议
   6. 电子邮件协议（SMTP、POP3、IMAP）
2. 传输层协议
   1. TCP协议
      1. 报文段结构
      2. 可靠数据传输
      3. 流量控制
      4. 拥塞控制
   2. UDP协议
      1. 报文段结构
      2. RDT（可靠数据传输协议）
3. 网络层协议
   1. IP协议（TCP/IP协议的基础，分为IPv4、IPv6）
   2. ARP协议（地址解析协议，用于解析IPD地址和MAC地址之间的映射）
   3. ICMP协议（控制报文协议，用于发送控制信息）
   4. NAT协议（网络地址转换协议）
4. 网络接口层
   1. 差错检测技术
   2. 多路访问协议（信道复用技术）
   3. CSMA/CD协议
   4. 以太网技术

## 2.3 为什么网络要分层？

复杂的系统需要分层，一位内每一层都需要专注于一类事情。网络分层也是一样，每一层只有专注于做一类事情；分层的作者认为原因包括三个：

1. 各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道如何调用下层提供好的功能就可以了（可以简单理解为接口调用），这个和我们对开发时系统进行分层是一个道理。
2. 提高了整体灵活性：每一层都可以使用最合适的技术来实现，你只需要保证提供的功能以及暴漏的接口的规则没有改变就行了。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。
3. 大问题化小：将复杂的网络间问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使负责的计算机网络系统变得更加已与设计，实现和标准化。这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分级为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。



## 2.5 TCP和UDP的区别

| 区别                   | TCP（传输控制协议）                                          | UDP（用户数据报协议）                                        |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 是否面向连接           | 是，在传输数据之前必须先建立连接，数据传送结束后要释放连接   | 否，在传输数据之前不需要先建立连接                           |
| 是否可靠               | 是，提供可靠的传输服务，TCP在传输数据之前，会有三次握手来建立连接，而在数据传递时，有确认、滑动窗口、重传、拥塞控制机制。通过TCP连接传输的数据，无差错、不丢失、不重复、并且按顺序到达 | 否，远程主机在收到UDP报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺利到达 |
| 是否有状态             | 是，和是否可靠传输相对应，TCP传输是又状态的，这个状态说的是TCP会去记录自己发送消息的状态比如消息是否发送 了、是否被接收了等等；为此TCP需要维持复杂的连接状态表 | 否，和是否可靠传输相对应，UDP是无状态服务，简单来说就是不管发出去之后的事情了（渣男协议） |
| 传输效率               | 较慢，由于TCP传输时多了连接、确认、重传机制，所以TCP的传输效率比UDP低很多 | 较快                                                         |
| 传输形式               | 字节流                                                       | 数据报文段                                                   |
| 首部开销               | 20~60 bytes                                                  | 8 bytes                                                      |
| 是否提供广播或多播服务 | 否，TCP只支持点对点通信                                      | 是，UDP支持一对一、一对多、多对多                            |

简单表：
![image-20221003115412659](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003115412659.png)

## 2.6 什么时候选择TCP，什么时候选择UDP？

1. UDP一般用于即使通信，比如：语音、视频、直播等等。这些场景对数据的准确性要求不是很高，比如你看视频即使少个一两帧，实际给人的感觉区别也并不大
2. TCP用于传输准确性要求特别高的场景，比如文件传输、发送和接受邮件、远程登录等等。



## 2.7 使用TCP的协议有那些？使用UDP的协议有那些？

运行在TCP协议上的协议：

1. HTTP协议：超文本传输协议，主要是为Web浏览器与Web服务器之间的通信而设计的。当我们使用浏览器浏览网页的额时候，我们的网页就是通过HTTP请求进行加载的。
2. HTTPS协议：更安全的超文本传输协议，身披SSL外衣的HTTP协议
3. FTP协议：文件传输协议，提供文件传输服务，基于TCP实现可靠的传输。使用FTP传输文件的好处是可以屏蔽操作系统和文件存储方式
4. SMTP协议：简单邮件传输协议的缩写，基于TCP协议，用来发送电子邮件。注意：接受邮件的协议不是SMTP而是POP3协议。
5. POP3/IMAP协议：POP3和IMAP两者都是负责邮件接受的协议
6. Telent协议：远程登录协议，通过一个终端登录到其他服务器，被一种称之SSH的非常安全的协议所取代
7. SSH协议：是目前较为可靠的，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄漏问题。SSH建立在可靠的传输协议TCP之上。

运行于UDP协议之上的协议：

1. DHCP协议：动态主机配置协议，动态配置IP地址
2. DNS：域名系统将人类可读的域名转换为机器可读的IP地址。我们可以将其理解为专为互联网设计的电话簿。实际上DNS同时支持UDP和TCP协议。



## 2.8 TCP三次握手和四次挥手



## 2.9 TCP如何保证传输的可靠性

需要注意的是（常见误区）：

- 发送端不等同于客户端
- 接收端不等同于服务端

TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。



## 2.10 从输入URL到页面展示到底发生了什么

### 2.10.1 来自图解HTTP的一张图片

![image-20221003151305717](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003151305717.png)

### 2.10.2思否上的一篇文章

总体来说分为以下几个过程:

1. DNS解析
   DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的?
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

## 2.11 HTTP状态码有那些

![image-20221003170032955](D:\Tyora\AssociatedPicturesInTheArticles\计算机网络-八股文-1\image-20221003170032955.png)





## 2.12 HTTP和HTTPS的区别有那些

1. 端⼝号  ：HTTP 默认是 80，HTTPS 默认是 443。

2. URL 前缀  ：HTTP 的 URL 前缀是      http://  ，HTTPS 的 URL 前缀是 https://  。

3. 安全性和资源消耗  ： HTTP 协议运⾏在 TCP 之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。HTTPS 是运⾏在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运⾏在TCP 之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说，HTTP 安全性没有 HTTPS ⾼，但是 HTTPS ⽐ HTTP 耗费更多服务器资源。

4. HTTP协议通信过程
   HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：

   1. 服务器在80端口等待客户的请求
   2. 浏览器发起到服务器的TCP连接（创建套接字Socket）
   3. 服务器接受来自浏览器的TCP连接
   4. 浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息
   5. 关闭TCP连接

   HTTP协议优点：扩展性强、速度快、跨平台支持性好

5. HTTPS协议通信过程
   HTTPS协议是HT
   
6. 是基于HTTP的，也是用TCP作为底层协议，并额外使用SSL/TLS协议用作加密和安全认证，默认端口443；HTTPS协议中，SSL通道通常使用基于密钥的加密算法，密钥长度通常是40比特或128比特。
   HTTPS协议尤蒂埃纳：保密性号、信任度高。

## 2.13 HTTP1.0和HTTP1.1有什么区别

1. 连接方式：HTTP1.0为短连接，HTTP1.1支持长连接
2. 状态响应码：HTTP1.1中新加入了大量的状态码，光是错误响应码状态就新增了24种。
3. 缓存处理：在HTTP1.0中主要使用header中的If-Modified-Since,Expires 来做为缓存判断的标 
   准，HTTP1.1 则引⼊了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
4. Host头处理：HTTP1.1在请求头张加入了Host字段。

## 2.14 URI和URL的区别是什么

1. URI是统一资源标志符，可以唯一标识一个资源
2. URL是统一资源定位符，可以提供该资源的路径，他是一种具体的URI，即URI可以用来标识一个资源，而且还指明了如何locate这个资源

URI的作用就像身份证号一样，URL的作用就像家庭住址一样，URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。



