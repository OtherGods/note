# 1.为什么需要分布式锁

在Java中，我们学习过多线程，也会学到锁。其中，锁解决的是多线程环境下，对共享资源的操作的问题。

而在分布式中，会变成一个多进程多线程的更复杂的环境。那么，这时候，我们也需要一个锁的机制，来解决共享资源的问题。独立进程中，锁可以放到进程里。多进程环境下，锁就必须放在一个通用的第三方存储空间中。这就是分布式锁。常见的场景如 **商品库存**，MQ消息去重等，都可以通过分布式锁来解决。核心就是两个目的：

1. 对共享资源的操作的互斥。

2. 对共享资源的操作的串行化。

假设有两个进程，要对同一个资源进行操作，在分布式锁的帮助下，它们可能是下面这样的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201208123201767.png)
对于任意一个进程来说，在操作资源之前，必须先获取分布式锁。获取成功，则可以进行操作，获取失败，则需要等待或返回失败。

# 2.Redis分布式锁(答案)

基于Redis的分布式锁，是常见的分布式锁实现方式之一。它通过以下一些机制来解决分布式锁的相关问题。

1. 通过**setnx命令的排他性**来达成锁的互斥。setnx命令的特性是，在插入一个key、value对时，当key不存在时，可以设置成功，返回1，当key已经存在时，会设置失败，返回0。

2. **通过锁超时来达成避免死锁的问题**。当在Redis中插入key成功后，即认为获取锁成功，当锁使用完成后，需要删除相应key，即释放锁。当删除失败时，就会出现死锁问题。这时候，可以通过在set时，设置超时时间来解决。如设置超时时间为10s等。

3. 通过独立线程来完成锁续租。由于加入了锁超时机制，所以，有可能会发生任务还未完成，锁就被释放的问题。**一些分布式锁的开源框架**，会通过一个单独线程，来不断通过exprie命令重刷key的过期时间，来达成一个锁续租的目的。

4. 通过value来配合解决锁重入问题。在分布式锁下，value可以是当前进程或线程的一个唯一id，当获取锁时，如果发现锁已经存在，可以根据value值来判断，是否可以获取锁，来达成一个锁重入的目的。

**分布式锁**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201208123329466.png)


