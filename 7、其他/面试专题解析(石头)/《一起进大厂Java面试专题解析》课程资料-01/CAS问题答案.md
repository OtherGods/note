

CAS（Compare-and-Swap），即比较并替换，java并发包中许多Atomic的类的底层原理都是CAS。

它的功能是判断内存中某个地址的值(V)是否为预期值(A)，如果是就改变成新值(B)，整个过程具有原子性。

具体体现于sun.misc.Unsafe类中的native方法，调用这些native方法，JVM会帮我们实现汇编指令，这些指令是CPU的原子指令，因此具有原子性。

适用场景：

　　1. CAS 适合简单对象的操作，比如布尔值、整型值等；

　　2. CAS 适合冲突较少的情况，如果太多线程在同时自旋，那么长时间循环会导致 CPU 开销很大；

CAS的缺点：

　　1. **CPU开销过大** ： 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。

　　2. **不能保证代码块的原子性**：CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized或lock了。

  3. **ABA问题**：如果内存地址V初次读取的值是A，在CAS等待期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。(取钱案例)

     如何解决: 除了Compare比较内存中某个地址的值(V)是否为预期值(A)，之外，还要添加版本号这个维度！

