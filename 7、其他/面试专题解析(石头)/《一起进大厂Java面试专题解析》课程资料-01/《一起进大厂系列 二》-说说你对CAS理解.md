[TOC]


## 1.场景引入，问题凸现
示例程序：启动两个线程，每个线程中让静态变量count循环累加100次。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210628180032272.png)
最终输出的count结果是什么呢？一定会是200吗？
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210628180052417.png)
>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。

Synchronized  Lock悲观锁

为什么这么说呢？关键在于**性能**问题。

Synchronized关键字会让没有得到锁资源的线程进入`BLOCKED`状态，而后在争夺到锁资源后恢复为`RUNNABLE`状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。

尽管Java1.6为`Synchronized`做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。

## 2.更高效的方案：AtomicXXXX 原子类

所谓原子操作类，指的是`java.util.concurrent.atomic`包下，一系列以`Atomic`开头的包装类。例如`AtomicBoolean`，`AtomicInteger`，`AtomicLong`。它们分别用于`Boolean`，`Integer`，`Long`类型的原子性操作。

现在我们尝试在代码中引入`AtomicInteger`类：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210628180258587.png)
使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。

## 3.什么是CAS？

CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。

这样说或许有些抽象，我们来看一个例子：

1.在内存地址V当中，存储着值为10的变量。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084333924.png)
2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084341959.png)
3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084350761.png)
4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084404753.png)
5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为**自旋**。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084421780.png)
6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084433433.png)
7.线程1进行SWAP，把地址V的值替换为B，也就是12。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629084445598.png)
从思想上来说，`Synchronized属于悲观锁`，悲观地认为程序中的并发情况严重，所以严防死守。`CAS属于乐观锁`，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。

## 4.CAS的缺点
- **CPU开销较大**
在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。


- **不能保证代码块的原子性**
CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。


- **ABA问题**
这是CAS机制最大的问题所在。
什么是ABA问题？怎么解决？

## 5.遗留的两个问题：

- Java当中CAS的底层实现
- CAS的ABA问题和解决方法


首先看一看`AtomicInteger`当中常用的自增方法 incrementAndGet：

```java
public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next)){
            return next;
        }
    }
}

private volatile int value;

public final int get() {
    return value;
}
```

这段代码是一个无限循环，也就是CAS的自旋。循环体当中做了三件事：
1.获取当前值。
2.当前值+1，计算出目标值。
3.进行CAS操作，如果成功则跳出循环，如果失败则重复上述步骤。


这里需要注意的重点是 get 方法，这个方法的作用是获取变量的当前值。

如何保证获得的当前值是内存中的最新值呢？很简单，用volatile关键字来保证。有关volatile关键字的知识，我们之前有介绍过，这里就不详细阐述了。

接下来看一看compareAndSet方法的实现，以及方法所依赖对象的来历：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103252286.png)

compareAndSet方法的实现很简单，只有一行代码。这里涉及到两个重要的对象，一个是unsafe，一个是valueOffset。



什么是unsafe呢？Java语言不像C，C++那样可以直接访问底层操作系统，但是JVM为我们提供了一个后门，这个后门就是unsafe。unsafe为我们提供了硬件级别的原子操作。



至于valueOffset对象，是通过unsafe.objectFieldOffset方法得到，所代表的是AtomicInteger对象value成员变量在内存中的偏移量。我们可以简单地把valueOffset理解为value变量的内存地址。



我们上面说过，CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。



而unsafe的compareAndSwapInt方法参数包括了这三个基本元素：valueOffset参数代表了V，expect参数代表了A，update参数代表了B。


正是unsafe的compareAndSwapInt方法保证了Compare和Swap操作之间的原子性操作。
## 6.ABA问题
什么是ABA呢？假设内存中有一个值为A的变量，存储在地址V当中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103331157.png)
时有三个线程想使用CAS的方式更新这个变量值，每个线程的执行时间有略微的偏差。线程1和线程2已经获得当前值，线程3还未获得当前值。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103343668.png)
接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获得了当前值B。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103400585.png)
再之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103415229.png)
最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值”A，并且经过compare检测，内存地址V中的实际值也是A，所以成功把变量值A更新成了B。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103428251.png)
这个过程中，线程2获取到的变量值A是一个旧值，尽管和当前的实际值相同，但内存地址V中的变量已经经历了A->B->A的改变。

当我们举一个提款机的例子。假设有一个遵循CAS原理的提款机，小灰有100元存款，要用这个提款机来提款50元。

由于提款机硬件出了点小问题，小灰的提款操作被同时提交两次，开启了两个线程，两个线程都是获取当前值100元，要更新成50元。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103553329.png)

理想情况下，应该一个线程更新成功，另一个线程更新失败，小灰的存款只被扣一次。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103605821.png)

线程1首先执行成功，把余额从100改成50。线程2因为某种原因阻塞了。这时候，小灰的妈妈刚好给小灰汇款50元。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103631120.png)
线程2仍然是阻塞状态，线程3执行成功，把余额从50改成100。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103647202.png)
线程2恢复运行，由于阻塞之前已经获得了“当前值”100，并且经过compare检测，此时存款实际值也是100，所以成功把变量值100更新成了50。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103704660.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103714171.png)
这个举例改编自《java特种兵》当中的一段例子。原本线程2应当提交失败，正确余额应该保持为100元，结果由于ABA问题提交成功了。

## 7.ABA问题解决
什么意思呢？真正要做到严谨的CAS机制，我们在Compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。


我们仍然以最初的例子来说明一下，假设地址V中存储着变量值A，当前版本号是01。线程1获得了当前值A和版本号01，想要更新为B，但是被阻塞了。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103838937.png)
这时候，内存地址V中的变量发生了多次改变，版本号提升为03，但是变量值仍然是A。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103852503.png)
随后线程1恢复运行，进行Compare操作。经过比较，线程1所获得的值和地址V的实际值都是A，但是版本号不相等，所以这一次更新失败。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210629103906892.png)
在Java当中，AtomicStampedReference类就实现了用版本号做比较的CAS机制。

## 8.小结
1. Java语言CAS底层如何实现？

    利用unsafe提供了原子性操作方法。


2. 什么是ABA问题？怎么解决？

    当一个值从A更新成B，又更新会A，普通CAS机制会误判通过检测。
   利用版本号比较可以有效解决ABA问题。


