# 1.索引概述

MySQL官方对索引的定义为：

**索引（index**）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足**特定查找算法的数据结构**，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

如下面的示意图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216223633292.png)

左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含**索引键值**和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。

> 以空间换时间：
>
> 索引、ES、页面静态化、缓存(浏览器缓存、JVM缓存、Redis缓存)...
>
> 索引有利于查询、不利于增删改~~

# 2.索引优势劣势
## 2.1.优势
1）类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。
2）通过索引列对数据进行排序，**降低数据排序的成本，降低CPU的消耗**

## 2.2.劣势

1）实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。

> 以空间换时间： 索引、ES、Redis、页面静态化

2）虽然索引**大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE**。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

> CRUD     CREATE     READ(使用最频繁)    UPDATE    DELETE

# 3.常见索引

索引是在MySQL的**存储引擎层**中实现的，而不是在服务器层实现的。所以每种**存储引擎**的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：

- **BTREE 索引**：**最常见的索引类型，大部分索引都支持 B 树索引**。
- **HASH 索引**：只有Memory引擎支持，使用场景简单。
- **R-tree 索引**（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。
- **Full-text** （全文索引）：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224141789.png)

我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 **B+tree 索引**，统称为索引。

二叉树遍历：https://www.cnblogs.com/du001011/p/11229170.html

# 3.索引结构

## 3.1.BTree

BTree又叫**多路平衡搜索树**，一颗m叉的BTree特性如下：

- 树中每个节点最多包含m个孩子。
- 除根节点与叶子节点外，每个节点至少有[**ceil**(m/2)]个孩子。
- 若根节点不是叶子节点，则至少有两个孩子。
- 所有的叶子节点都在同一层。
- 每个非叶子节点由**n个key与n+1个指针**组成，其中`[ceil(m/2)-1] <= n <= m-1`

**以5叉BTree为例**，key的数量：公式推导`[ceil(m/2)-1] <= n <= m-1`。所以 `2 <= n <=4` 。**当n>4时，中间节点分裂到父节点**，两边节点分裂。插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。

演变过程如下：
1). 插入前4个字母 C N G A
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224432272.png)
2). 插入H，n>4，中间元素G字母向上分裂到新的节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224447922.png)
3). 插入E，K，Q不需要分裂
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224508906.png)

4). 插入M，中间元素M字母向上分裂到父节点G
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224524701.png)
5). 插入F，W，L，T不需要分裂
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224552882.png)
6). 插入Z，中间元素T向上分裂到父节点中
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224618504.png)
7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224651954.png)
8). 最后插入S，N P Q R节点n>5，中间节点Q向上分裂，但分裂后父节点DGMT的n>5，中间节点M向上分裂
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216224711724.png)
到此，该BTREE树就已经构建完成了， BTREE树和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快！

## 3.2.B+Tree
B+Tree是**B树的变种**，有着比B树更高的查询性能，来看下m阶B+Tree特征：

1、有m个子树的节点包含有m个元素（B-Tree中是m-1）

2、**根节点和分支节点中不保存数据**，**只用于索引，所有数据都保存在叶子节点中**。

3、所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素。

4、叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216225837921.png)

```java
1、红点表示是指向卫星数据的指针，指针指向的是存放实际数据的磁盘页，卫星数据就是数据库中一条数据记录。

2、叶子节点中还有一个指向下一个叶子节点的next指针，所以叶子节点形成了一个有序的链表，方便遍历B+树。
```

### 3.2.1.B+树的优势

**1、更加高效的单元素查找**
B+树的查找元素**3**的过程：

**第一次磁盘IO**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216230021926.png)
**第二次磁盘IO**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216230042993.png)
**第三次磁盘IO**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216230102663.png)
这个过程看下来，貌似与B树的查询过程没有什么区别。但实际上有两点不一样：

a、首先B+树的中间节点不存储卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素，如此一来，相同数量的数据下，B+树就相对来说要更加**矮胖**些，磁盘IO的次数更少。

b、由于只有叶子节点才保存卫星数据，B+树每次查询都要到叶子节点；而B树每次查询则不一样，最好的情况是根节点，最坏的情况是叶子节点，没有B+树稳定。

**2、叶子节点形成有顺链表，范围查找性能更优**
**B树范围查找3-8的过程**

a、先查找3

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020121623023778.png)
b、再查找4、5、6、7、8，中间过程省略，直接到8的查找
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020121623025122.png)
这里查找的范围跨度越大，则磁盘IO的次数越多，性能越差。

**B+树范围查找3-11的过程**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216230316372.png)
先从上到下找到下限元素3，然后通过链表指针，依次遍历得到元素5/6/8/9/11；如此一来，就不用像B树那样一个个元素进行查找。

### 3.2.2.小结
1.单节点可以存储更多的元素，使得查询磁盘IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。


## 3.3.MySQL中的B+Tree
MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有**顺序指针的B+Tree，提高区间访问的性能**。

MySQL中的 B+Tree 索引结构示意图:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201216230659908.png)

# 4.索引分类

1）单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
2）唯一索引：索引列的值必须唯一，但允许有空值
3）复合索引：即一个索引包含多个列 

4）全文索引

# 5.索引实践

本篇文章，我们将从索引基础开始，介绍什么是索引以及索引的几种类型，然后学习如何创建索引以及索引设计的基本原则。
本篇文章中用于测试索引创建的user表的结构如下：

```sql
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `gender` int(1) NOT NULL,
  `age` int(3) NOT NULL,
  `status` int(1) NOT NULL,
  `remark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;
```

## 5.1索引类型

查看索引详情

```
SHOW INDEX FROM table_name;
```
例如：

```sql
mysql> SHOW INDEX FROM user;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY  |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
1 row in set (0.03 sec)

```

## 5.2.主键索引

1）单值索引：即一个索引只包含单个列，一个表可以有多个单列索引
2）唯一索引：索引列的值必须唯一，但允许有空值
3）复合索引：即一个索引包含多个列

它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。主键索引就是之前的主键约束！

**Primary key**

```sql
mysql> SHOW INDEX FROM user;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY  |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
1 row in set (0.03 sec)

```
>注意：一个表只能有一个主键
## 4.2.唯一索引
唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
**创建唯一索引:**

```
ALTER TABLE table_name ADD UNIQUE (column);
```
示例：

```sql
mysql> alter table user add unique(name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW INDEX FROM user;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY  |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | name     |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
2 rows in set (0.03 sec)
```
**创建唯一组合索引：**

```
ALTER TABLE table_name ADD UNIQUE (column1,column2);
```
**示例：**

```sql
mysql> ALTER TABLE user ADD UNIQUE unique_name_age (name,age);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW INDEX FROM user;
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY         |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | name            |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | unique_name_age |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | unique_name_age |            2 | age         | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
4 rows in set (0.03 sec)
```
## 5.3.普通索引

最基本的索引，它没有任何限制。

**创建普通索引：**

```
ALTER TABLE table_name ADD INDEX index_name (column);
```
**示例：**

```sql
mysql> alter table user add index index_name(name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW INDEX FROM user;
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY         |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | name            |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | unique_name_age |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | unique_name_age |            2 | age         | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          1 | index_name      |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
5 rows in set (0.03 sec)
```
## 5.4.组合索引

组合索引，即一个索引包含多个列。多用于避免回表查询。
**创建组合索引：**

```
ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);
```
示例：

```sql
mysql> alter table user add index index_name_age(name,age);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW INDEX FROM user;
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY         |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | name            |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | unique_name_age |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          0 | unique_name_age |            2 | age         | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          1 | index_name      |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          1 | index_name_age  |            1 | name        | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          1 | index_name_age  |            2 | age         | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
+-------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
7 rows in set (0.05 sec)
```
## 5.5.全文索引

全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。
**创建全文索引**

```
ALTER TABLE table_name ADD FULLTEXT (column);
```
**示例：**

```sql
mysql> ALTER TABLE user ADD FULLTEXT (remark);
Database changed
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW INDEX FROM user;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY  |            1 | id          | A         |           0 | NULL     | NULL   |      | BTREE      |         |               |
| user  |          1 | remark   |            1 | remark      | NULL      | NULL        | NULL     | NULL   | YES  | FULLTEXT   |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
2 rows in set
```
>备注:  如果是InnoDB，改为MyISAM，InnoDB老版本不支持FULLTEXT类型的索引
## 5.6.删除索引

索引一经创建不能修改，如果要修改索引，只能删除重建。
删除索引：

```
DROP INDEX index_name ON table_name;
```

# 7.索引设计原则

>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。

- 对查询频次较高，且数据量比较大的表建立索引。
- 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。
- 使用唯一索引，区分度越高，使用索引的效率越高。**电话号码、邮箱**
- 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。
- 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。
- 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。

> 具体的SQL语句，添加合适的索引！  合适！！










